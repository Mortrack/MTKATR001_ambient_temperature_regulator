/* USER CODE BEGIN Header */
/** @addtogroup main
 * @{
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#if ETX_OTA_VERBOSE
    #include <stdio.h>	// Library from which "printf" is located at.
#endif
#include <stdint.h> // This library contains the aliases: uint8_t, uint16_t, uint32_t, etc.
#include "app_side_etx_ota.h" // This custom Mortrack's library contains the functions, definitions and variables required so that the Main module can receive and apply Firmware Update Images to our MCU/MPU.
#include "5641as_display_driver.h" // This custom Mortrack's library contains the functions, definitions and variables that together operate as the driver for the 5641AS 7-segment Display Device.
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define APLICATION_FIRMWARE_ADDRESS					(ETX_APP_FLASH_ADDR)					/**< @brief Designated Memory Location address for the Application Firmware. */
#define COLD_FAN_MAX_COMPARE_VALUE					(1818)									/**< @brief Maximum possible value for the Compare Register designated for the Cold Fan's PWM with respect to the ARR defined in the STM32CubeMx App. */
#define HOT_FAN_MAX_COMPARE_VALUE					(1818)									/**< @brief Maximum possible value for the Compare Register designated for the Hot Fan's PWM with respect to the ARR defined in the STM32CubeMx App. */
#define COLD_FAN_TIMER_CHANNEL                      (TIM_CHANNEL_1)                         /**< @brief Timer Channel towards which the Cold Fan is connected to. */
#define HOT_FAN_TIMER_CHANNEL                       (TIM_CHANNEL_2)                         /**< @brief Timer Channel towards which the Hot Fan is connected to. */
#define ADC_POLL_TIMEOUT                            (100)                                   /**< @brief Designated Timeout for polling one Channel of the ADC of our MCU/MPU from which the MTKATR001 Temperature Sensors Outputs will be read from. */
#define ADC_BITS_IN_DECIMAL_VALUE                   (4095.0)                                /**< @brief Bits of our MCU/MPU's ADC but in its equivalent decimal value. */
#define MCU_POWER_SUPPLY_VOLTAGE                    (3.3)                                   /**< @brief Power Supply Voltage with which our MCU/MPU is being electrically energized with. */
#define LM35_VOLTAGE_TO_CELSIUS_CONSTANT            (100.0)                                 /**< @brief Constant of the LM35 Temperature Sensor with which the Celsius Temperature can be obtained whenever multiplying this Constant with the Voltage read from the LM35 Sensor Output Pin. */
#define INTERNAL_AMBIENT_TEMP_ERROR_ALLOWED			(0.5)									/**< @brief Designated Error allowed in Celsius Degrees for the Internal Ambient Temperature to have. */
#define MAJOR 										(1)										/**< @brief Major version number of our MCU/MPU's Application Firmware. */
#define MINOR 										(0)										/**< @brief Minor version number of our MCU/MPU's Application Firmware. */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;

TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;

UART_HandleTypeDef huart3;

/* USER CODE BEGIN PV */
// NOTE: "hadc1" is used for the ADCs used to read the Temperature Sensors Outputs
// NOTE: "htim2" is used by the 5641AS Display Driver Library.
// NOTE: "htim3" is used to generate two PWMs in its Channel 1 and Channel 2, for the Cold and Hot Fans respectively.
// NOTE: "huart3" is used for communicating with the host that will be sending firmware images to our MCU via the ETX OTA Protocol with the BT Hardware Protocol.
const uint8_t APP_version[2] = {MAJOR, MINOR};		/**< @brief Global array variable used to hold the Major and Minor version number of our MCU/MPU's Application Firmware in the 1st and 2nd byte respectively. */
firmware_update_config_data_t fw_config;			        /**< @brief Global struct used to either pass to it the data that we want to write into the designated Flash Memory pages of the @ref firmware_update_config sub-module or, in the case of a read request, where that sub-module will write the latest data contained in the sub-module. */
etx_ota_custom_data_t etx_ota_custom_data;			        /**< @brief	Global struct where it is desired to hold the handling data for any received ETX OTA Custom Data. */
HM10_GPIO_def_t GPIO_is_hm10_default_settings;              /**< @brief Global variable that will to hold the GPIO pin parameters of the Input Mode GPIO Pin to be used so that our MCU can know whether the user wants it to set the default configuration settings in the HM-10 BT Device or not. */
Display_5641AS_peripherals_def_t display_peripherals;       /**< @brief Global variable used to indicate the GPIO Output peripheral pins of our MCU/MPU with which we want the @ref display_5641as to control the 5641AS 7-segment Display Device. */
uint16_t display_output[DISPLAY_5641AS_CHARACTERS_SIZE];    /**< @brief Global array variable used to hold the ASCII characters that are to be sent to the @ref display_5641as . */
uint16_t ascii_error_code[DISPLAY_5641AS_CHARACTERS_SIZE];  /**< @brief Global array variable used to hold the corresponding @ref MTKATR001_Status error code in its equivalent ASCII Characters in case that the main program has a Hard-Crash or fails for whatever reason. */
int8_t desired_internal_ambient_temperature = 25;           /**< @brief Global variable that contains the Desired Internal Ambient Temperature at which it is desired that the MTKATR001 System regultates its internally controlled temperature to. */
uint8_t desired_hot_fan_duty_cycle = 100;                   /**< @brief Global variable that contains the Hot Fan Duty Cycle desired in the MTKATR001 System. @note The fan controlled by the PWM to which this duty cycle is linked to will bring hot air inside the MTKATR001 System. @note This value should always be equal or greater and 0 and equal or lower than 100. */
uint8_t desired_cold_fan_duty_cycle = 100;                  /**< @brief Global variable that contains the Cold Fan Duty Cycle desired in the MTKATR001 System. @note The fan controlled by the PWM to which this duty cycle is linked to will bring cold air inside the MTKATR001 System. @note This value should always be equal or greater and 0 and equal or lower than 100. */
uint8_t desired_hot_water_temperature = 60;                 /**< @brief Global variable that contains the Hot Water Temperature desired in the MTKATR001 System. @details This Global Variable will basically define the temperature at which the MTKATR001 System will regulate the Hot Water to, which is the Water that will be used to bring Hot Air inside the MTKATR001 System via the Hot Fan. */
uint8_t desired_hot_water_min_temperature = 50;             /**< @brief Global variable that contains the Hot Water Minimum Temperature desired in the MTKATR001 System. @details This Global Variable will be used as a threshold so that whenever the Hot Water's Temperature lowers below this point, then the MTKATR001 System will start heating it until it reaches the value of the @ref desired_hot_water_temperature Global Variable. */
uint8_t desired_cold_water_max_temperature = 10;            /**< @brief Global variable that contains the Cold Water Maximum Temperature desired in the MTKATR001 System. @details This global Variable will be used as a threshold so that whenever the Cold Water's Temperature is higher than this point, then the MTKATR001 System will emit a signal to the user to request to him/her to change the Cold Water for one colder than the value assigned to this variable. */
float current_hot_water_temperature;                        /**< @brief Global variable that contains the current Hot Water Temperature. */
float current_cold_water_temperature;                       /**< @brief Global variable that contains the current Cold Water Temperature. */
float current_internal_ambient_temperature;                 /**< @brief Global variable that contains the current Internal Ambient Temperature. */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART3_UART_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM3_Init(void);
static void MX_ADC1_Init(void);
/* USER CODE BEGIN PFP */

/**@brief   Selects a desired Channel at a specified ADC of our MCU/MPU and then gets the current output from it.
 *
 * @details This function will start by changing the Configuration Settings of the given ADC Handler to the requested
 *          Channel. Then that ADC will be enabled to then Poll the Output of the requested ADC and Channel. Finally,
 *          the Output Value will be stored into the requested Destination and then this ADC will be stopped.
 *
 * @notoe   This function will always set a sampling time of 239.5 ADC Cycles for the Channel selected.
 *
 * @param[in] hadc      Pointer towards the structure of the ADC from which it is desired to select a desired Channel.
 * @param adc_channel   Channel that wants to be selected from the desired ADC.
 * @param[out] dst      Pointer towards the Memory Address Location where the obtained ADC Output will be stored at.
 *
 * @retval  HAL_OK      If there are no HAL Errors during the ADC and Channel selection and the retrieval of the
 *                      respective output value from the requested ADC and Channel.
 * @retval  HAL_ERROR   If there was a HAL Error during the processes made by this function for the requested ADC and
 *                      Channel. Note that if this case gives place, then the ADC's Output might not have been retrieved
 *                      and, therefore, it would be best to consider that the Output was not obtain for safety purposes.
 * @retval  HAL_BUSY    If the ADC was Busy during a request made to it by this function. Note that if this case gives
 *                      place, then the ADC's Output might not have been retrieved and, therefore, it would be best to
 *                      consider that the Output was not obtain for safety purposes.
 * @retval  HAL_TIMEOUT If the Timeout @ref ADC_POLL_TIMEOUT expired during a request made to the ADC. Note that if this
 *                      case gives place, then the ADC's Output might not have been retrieved and, therefore, it would
 *                      be best to consider that the Output was not obtain for safety purposes.
 *
 * @author 	Cesar Miranda Meza (cmirandameza3@hotmail.com)
 * @date	February 10, 2024.
 */
static HAL_StatusTypeDef get_adc_output(ADC_HandleTypeDef *hadc, uint32_t adc_channel, float *dst);

/**@brief	Initializes the @ref display_5641as .
 *
 * @details	Before initializing that module, this function will populate the required parameters for that purpose by
 *          populating the fields contained in the @ref display_peripherals Global Variable with the following fixed
 *          GPIO Output Peripherals:<br>
 *          <ul>
 *              <li>GPIOB Pin 0 --> 5641AS Display Terminal A</li>
 *              <li>GPIOB Pin 1 --> 5641AS Display Terminal B</li>
 *              <li>GPIOA Pin 2 --> 5641AS Display Terminal C</li>
 *              <li>GPIOA Pin 3 --> 5641AS Display Terminal D</li>
 *              <li>GPIOB Pin 5 --> 5641AS Display Terminal E</li>
 *              <li>GPIOB Pin 6 --> 5641AS Display Terminal F</li>
 *              <li>GPIOB Pin 7 --> 5641AS Display Terminal G</li>
 *              <li>GPIOB Pin 8 --> 5641AS Display Terminal Dp</li>
 *              <li>GPIOB Pin 9 --> 5641AS Display Terminal K1</li>
 *              <li>GPIOB Pin 12 --> 5641AS Display Terminal K2</li>
 *              <li>GPIOB Pin 13 --> 5641AS Display Terminal K3</li>
 *              <li>GPIOB Pin 14 --> 5641AS Display Terminal K4</li>
 *          </ul>
 *          In addition, a fixed On-Time and Off-Time steps will be defined, with the values of 6 and 4 respectively.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	February 06, 2024
 */
static void custom_initialize_5641as_display_driver(void);

/**@brief	Gets the equivalent of a certain number to its equivalent ASCII Numeric Characters.
 *
 * @details	This function is only able to get the equivalent ASCII Numeric Characters for any number greater than -10
 *          and lower than 100, with one decimal digit at the most.
 *
 * @details The \p dst param is expected to have a length of 3 bytes. In the first byte of the \p dst param, the value
 *          of the tens digit from the \p src param is going to be stored, if there is any. The value of the ones digit
 *          from the \p src param is going to be stored in the second byte of the \p dst param. Finally, the value of
 *          the tenths digit (i.e., the decimal digit) of the \p src param is going to be stored in the third byte of
 *          the \p dst param.
 *
 * @retval  0   If the given number to convert is greater than -10 and lower than 100 and if its conversion was
 *              successfully made and retrieved.
 * @retval  -1  If this function did not attempted to get or convert the requested number due to either being equal or
 *              lower than -10, or equal or greater than 100.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	March 26, 2024
 */
static int convert_number_to_ASCII(float src, uint16_t *dst);

/**@brief	Initializes the @ref firmware_update_config sub-module and then loads the latest data that has been written
 *          into it, if there is any. However, in the case that any of these processes fail, then this function will
 *          endlessly loop via a \c while() function and set the corresponding @ref MTKATR001_Status Exception Code on
 *          the Display driven by @ref display_5641as .
 *
 * @details	In case that all the processes conclude successfully, the latest data of the @ref firmware_update_config
 *          sub-module will be copied into the global struct \c fw_config .
 *
 * @details	A maximum of three attempts to initialize this module will be made, with a delay of 0.5 seconds each.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	November 19, 2023
 */
static void custom_firmware_update_config_init();

/**@brief	Initializes the @ref bl_side_firmware_update with a desired Hardware Protocol and, only in the case that the
 *          initialization is unsuccessful, then this function will endlessly loop via a \c while() function and set the
 *          corresponding @ref MTKATR001_Status Exception Code on the Display driven by @ref display_5641as .
 *
 * @details	This function populate the fields required for initializing the @ref bl_side_firmware_update via the
 *          @ref init_firmware_update_module function. In the case where that function initializes the
 *          @ref bl_side_firmware_update successfully, then this @ref custom_firmware_update_config_init function will
 *          terminate. Otherwise, it will endlessly loop via a \c while() function and set the corresponding
 *          @ref MTKATR001_Status Exception Code on the Display driven by @ref display_5641as .
 *
 * @note    The @ref fw_config Global struct must have already been populated with the latest data written into the
 *          @ref firmware_update_config before calling this function.
 *
 * @param hw_protocol   ETX OTA Hardware Protocol that is desired to enable whenever using the ETX OTA Protocol.
 * @param[in] p_huart   Pointer to the UART that wants to be used from our MCU/MPU as the means for using the chosen ETX
 *                      OTA Hardware Protocol.
 *
 * @author	César Miranda Meza
 * @date	November 19, 2023
 */
static void custom_init_etx_ota_protocol_module(ETX_OTA_hw_Protocol hw_protocol, UART_HandleTypeDef *p_huart);

/**@brief	Validates the CRC of our MCU/MPU's current Application Firmware and, only in the case that the Application
 *          Firmware is not valid or is corrupted, then this function will endlessly loop via a \c while() function and
 *          set the corresponding @ref MTKATR001_Status Exception Code on the Display driven by @ref display_5641as .
 *
 * @details	This function reads the data stored in the @ref firmware_update_config via the @ref fw_config Global struct
 *          to get the recorded CRC of the Application Firmware and it calculates the CRC of the actual Application
 *          Firmware currently installed in our MCU/MPU. After this, both CRCs are used for validating our MCU/MPU's
 *          current Bootloader Firmware. If both CRCs match, then this function will terminate. Otherwise, it will
 *          endlessly loop via a \c while() function and set the corresponding @ref MTKATR001_Status Exception Code on
 *          the Display driven by @ref display_5641as .
 *
 * @note    The @ref fw_config Global struct must have already been populated with the latest data written into the
 *          @ref firmware_update_config before calling this function.
 *
 * @author	César Miranda Meza
 * @date	November 19, 2023
 */
static void validate_application_firmware();

/**@brief   Gets the PWM Compare value required to set a desired PWM Duty Cycle.
 *
 * @param desired_duty_cycle    The desired Duty Cycle value from which it is desired to calculate the PWM Compare value
 *                              from.
 *
 * @note    If the \p desired_duty_cycle param has an invalid value, then its value will be changed as in the following:<br>
 *          <ul>
 *              <li>if \p desired_duty_cycle param < 0, then \p desired_duty_cycle param will be adjusted to 0.</li>
 *              <li>if \p desired_duty_cycle param > 100, then \p desired_duty_cycle param will be adjusted to 100.</li>
 *          </ul>
 *
 * @param max_compare_value     Maximum possible value for the Compare Register designated for the PWM with which the
 *                              desired FAN is to be driven with. Note that, according to the STMicroelectronics
 *                              documentation this maximum value should be equal to the ARR value defined in the
 *                              STM32CubeMx App plus 1.
 *
 * @return  The PWM Compare value required to set the requested PWM Duty Cycle with respect to the given Max Compare
 *          value.
 *
 * @note    \f$pwmCompareValue = \frac{(desiredDutyCycle)(maxCompareValue)}{100}\f$
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date    February 06, 2024.
 */
static uint16_t get_compare_value_for_fan_pwm(uint16_t desired_duty_cycle, uint16_t max_compare_value);

/**@brief   Reads the ADC1-CH0 and then updates the @ref current_cold_water_temperature Global Variable.
 *
 * @details This function will jump into an infinite while-loop if something goes wrong with the ADC1-CH0 when reading
 *          it and will also display the corresponding @ref MTKATR001_Status Exception Code via the 7-segment Display
 *          Device.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	February 11, 2024.
 */
static void update_current_cold_water_temperature(void);

/**@brief   Reads the ADC1-CH1 and then updates the @ref current_hot_water_temperature Global Variable.
 *
 * @details This function will jump into an infinite while-loop if something goes wrong with the ADC1-CH1 when reading
 *          it and will also display the corresponding @ref MTKATR001_Status Exception Code via the 7-segment Display
 *          Device.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	February 11, 2024.
 */
static void update_current_hot_water_temperature(void);

/**@brief   Reads the ADC1-CH4 and then updates the @ref current_internal_ambient_temperature Global Variable.
 *
 * @details This function will jump into an infinite while-loop if something goes wrong with the ADC1-CH4 when reading
 *          it and will also display the corresponding @ref MTKATR001_Status Exception Code via the 7-segment Display
 *          Device.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	February 11, 2024.
 */
static void update_current_internal_ambient_temperature(void);

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
/**@brief	MTKATR001 Exception codes.
 *
 * @details	These Exception Codes are returned by the functions of the @ref main to indicate the resulting status of
 *          having executed the process contained in each of the processes of the main application. For example, to
 *          indicate that the process executed by a certain function was successful or that it has failed.
 */
typedef enum
{
    MTKATR001_EC_OK                                 = 0U,   //!< MTKATR001 System Process was successful.
    MTKATR001_EC_STOP                               = 1U,   //!< MTKATR001 ETX OTA Protocol Process or transaction has been stopped.
    MTKATR001_EC_NR		                            = 2U,	//!< MTKATR001 ETX OTA Protocol has concluded with no response from Host.
    MTKATR001_EC_NA                                 = 3U,   //!< MTKATR001 ETX OTA Payload received or to be received Not Applicable.
    MTKATR001_EC_ERR                                = 4U,   //!< MTKATR001 ETX OTA Protocol has failed.
    MTKATR001_EC_INIT_FW_UPDT_CONF_MODULE_ERR       = 5U,   //!< MTKATR001 Firmware Update Configurations Sub-module could not be initialized. @note If this problem persists each time you energize the MTKATR001 Device, then this unfortunately means that the MCU/MPU's Flash Memory lifetime of the MTKATR001 Device has expired.
    MTKATR001_EC_INIT_ETX_OTA_MODULE_ERR            = 6U,   //!< MTKATR001 ETX OTA Module could not be initialized. @note This case can might give place if the connection or requests between the Bluetooth Device and our MCU/MPU was temporarily lost or if a wrong configuration setting was sent to that Bluetooth Device. However, if this problem persists each time after energizing the MTKATR001 Device, then it is very likely that the Bluetooth Device's lifetime has expired.
    MTKATR001_BOOTLOADER_FIRMWARE_VALIDATION_ERR    = 7U,   //!< MTKATR001 Bootloader Firmware Validation was unsuccessful. @note If this case ever gives place, although there is a ridiculously small probability that this can be due to a Bootloader Firmware that was mistakenly received as successful, when it was actually not it, the way most probable reason this Error will give place is due to having tampered with our MCU/MPU's Flash Memory (e.g., By attempting to reverse engineering it).
    MTKATR001_APPLICATION_FIRMWARE_VALIDATION_ERR   = 8U,   //!< MTKATR001 Application Firmware Validation was unsuccessful. @note If this case ever gives place, although there is a ridiculously small probability that this can be due to an Application Firmware that was mistakenly received as successful, when it was actually not it, the way most probable reason this Error will give place is due to having tampered with our MCU/MPU's Flash Memory (e.g., By attempting to reverse engineering it).
    MTKATR001_HOT_WATER_TEMP_IS_UNDER_SHORTCIRCUIT  = 9U,   //!< MTKATR001 Hot Water Temperature Sensor is currently under a short-circuit. @note If this Error gives place, you can calmly disconnect the MTKATR001 Device from the AC Plug since it has a solid and very safe short-circuit protection that will not allow the current to go very high ever. However, the Hot Water Temperature Sensor will require to be changed with a new one after this in order for the MTKATR001 System to work as expected the next time you plug it back again the AC Cord.
    MTKATR001_COLD_WATER_TEMP_IS_UNDER_SHORTCIRCUIT = 10U,  //!< MTKATR001 Cold Water Temperature Sensor is currently under a short-circuit. @note If this Error gives place, you can calmly disconnect the MTKATR001 Device from the AC Plug since it has a solid and very safe short-circuit protection that will not allow the current to go very high ever. However, the Cold Water Temperature Sensor will require to be changed with a new one after this in order for the MTKATR001 System to work as expected the next time you plug it back again the AC Cord.
    MTKATR001_COLD_WATER_TEMP_ADC_ERR               = 11U,  //!< MTKATR001 ADC with which the Cold Water Temperature Sensor is being read with has responded with a HAL error/problem. @note If this problem persists each time you energize the MTKATR001 Device, then this unfortunately means that either the MCU/MPU's ADC lifetime or even the lifetime of the actual MCU/MPU of the MTKATR001 Device has expired.
    MTKATR001_HOT_WATER_TEMP_ADC_ERR                = 12U,  //!< MTKATR001 ADC with which the Hot Water Temperature Sensor is being read with has responded with a HAL error/problem. @note If this problem persists each time you energize the MTKATR001 Device, then this unfortunately means that either the MCU/MPU's ADC lifetime or even the lifetime of the actual MCU/MPU of the MTKATR001 Device has expired.
    MTKATR001_INTERNAL_AMBIENT_TEMP_ADC_ERR         = 13U   //!< MTKATR001 ADC with which the Internal Ambient Temperature Sensor is being read with has responded with a HAL error/problem. @note If this problem persists each time you energize the MTKATR001 Device, then this unfortunately means that either the MCU/MPU's ADC lifetime or even the lifetime of the actual MCU/MPU of the MTKATR001 Device has expired.
} MTKATR001_Status;

/**@brief	ASCII code character definitions that are available in the @ref display_5641as and that are used by the
 *          @ref convert_number_to_ASCII function for converting numbers into their equivalent ASCII Numeric Characters.
 *
 * @note    These definitions are defined with respect to the decimal value that corresponds for each of the available
 *          ASCII code characters.
 */
typedef enum
{
    Command_NULL_in_ASCII                   = 0,     //!< \f$[NULL]_{ASCII} = 0_d\f$.
    Letter_minus_sign_in_ASCII              = 45,    //!< \f$-_{ASCII} = 45_d\f$.
    Number_0_in_ASCII	                    = 48,    //!< \f$0_{ASCII} = 48_d\f$.
    Number_1_in_ASCII	                    = 49,    //!< \f$1_{ASCII} = 49_d\f$.
    Number_2_in_ASCII	                    = 50,    //!< \f$2_{ASCII} = 50_d\f$.
    Number_3_in_ASCII	                    = 51,    //!< \f$3_{ASCII} = 51_d\f$.
    Number_4_in_ASCII	                    = 52,    //!< \f$4_{ASCII} = 52_d\f$.
    Number_5_in_ASCII	                    = 53,    //!< \f$5_{ASCII} = 53_d\f$.
    Number_6_in_ASCII	                    = 54,    //!< \f$6_{ASCII} = 54_d\f$.
    Number_7_in_ASCII	                    = 55,    //!< \f$7_{ASCII} = 55_d\f$.
    Number_8_in_ASCII	                    = 56,    //!< \f$8_{ASCII} = 56_d\f$.
    Number_9_in_ASCII	                    = 57,    //!< \f$9_{ASCII} = 57_d\f$.
    Number_0Dp_in_ASCII	                    = 256,    //!< \f$0._{ASCII} = 256_d custom value\f$.
    Number_1Dp_in_ASCII	                    = 257,    //!< \f$1._{ASCII} = 257_d custom value\f$.
    Number_2Dp_in_ASCII	                    = 258,    //!< \f$2._{ASCII} = 258_d custom value\f$.
    Number_3Dp_in_ASCII	                    = 259,    //!< \f$3._{ASCII} = 259_d custom value\f$.
    Number_4Dp_in_ASCII	                    = 260,    //!< \f$4._{ASCII} = 260_d custom value\f$.
    Number_5Dp_in_ASCII	                    = 261,    //!< \f$5._{ASCII} = 261_d custom value\f$.
    Number_6Dp_in_ASCII	                    = 262,    //!< \f$6._{ASCII} = 262_d custom value\f$.
    Number_7Dp_in_ASCII	                    = 263,    //!< \f$7._{ASCII} = 263_d custom value\f$.
    Number_8Dp_in_ASCII	                    = 264,    //!< \f$8._{ASCII} = 264_d custom value\f$.
    Number_9Dp_in_ASCII	                    = 265     //!< \f$9._{ASCII} = 265_d custom value\f$.
} Display_ASCII_Characters;

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART3_UART_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_ADC1_Init();
  /* USER CODE BEGIN 2 */

    /* Send a message from the Application showing the current Application version there. */
    #if ETX_OTA_VERBOSE
        printf("Starting Application v%d.%d\r\n", APP_version[0], APP_version[1]);
    #endif

    /* Initialize the 5641AS 7-segment Display Driver module. */
    custom_initialize_5641as_display_driver();
    display_output[0] = Number_8Dp_in_ASCII;
    display_output[1] = Number_8Dp_in_ASCII;
    display_output[2] = Number_8Dp_in_ASCII;
    display_output[3] = Number_8Dp_in_ASCII;
    set_5641as_display_output(display_output);

    /* We initialize the Firmware Update Configurations sub-module and the ETX OTA Firmware Update module, and also validate the currently installed Application Firmware in our MCU/MPU. */
    // NOTE: These initializations must be made in that order. After those, you may call the initialization functions of your actual application.
    custom_firmware_update_config_init();
    custom_init_etx_ota_protocol_module(ETX_OTA_hw_Protocol_BT, &huart3);
    validate_application_firmware();

    /* Initialize the Cold and Hot Fan's PWMs. */
    HAL_TIM_PWM_Start(&htim3, COLD_FAN_TIMER_CHANNEL); // Starting the PWM of Timer3-CH1 for the Cold Fan.
    HAL_TIM_PWM_Start(&htim3, HOT_FAN_TIMER_CHANNEL); // Starting the PWM of Timer3-CH2 for the Hot Fan.

    /* Set 0 Duty Cycle for the Cold and Hot Fan's PWMs. */
    __HAL_TIM_SET_COMPARE(&htim3, COLD_FAN_TIMER_CHANNEL, 0); // Setting the High State Duration (i.e., Pulse Width) of the Cold Fan to zero.
    __HAL_TIM_SET_COMPARE(&htim3, HOT_FAN_TIMER_CHANNEL, 0); // Setting the High State Duration (i.e., Pulse Width) of the Hot Fan to zero.
    // uint16_t get_compare_value_for_fan_pwm(uint16_t desired_duty_cycle, uint16_t max_compare_value);

    /* Turn Off the Water Heating Resistor, the IATR LED and the 5641AS 7-segment Display Device. */
    // NOTE: This has already been done from the STM32CubeMx Peripherals Configuration Settings.

    /* Set default MTKATR001 System Parameters values. */
    // NOTE: These default values have already been assigned at the moment of declaring the variables that will hold such values.
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */

      /* Validate whether the Hot Water Temperature Sensor is currently under a short-circuit or not. */
      if (HAL_GPIO_ReadPin(Hot_Water_Shortcircuit_Indicator_GPIO_Input_GPIO_Port, Hot_Water_Shortcircuit_Indicator_GPIO_Input_Pin) == GPIO_PIN_RESET)
      {
		  while (1)
		  {
			  convert_number_to_ASCII(MTKATR001_HOT_WATER_TEMP_IS_UNDER_SHORTCIRCUIT, ascii_error_code);
			  ascii_error_code[3] = 0;
			  display_output[0] = 'E';
			  display_output[1] = 'r';
			  display_output[2] = 'r';
			  display_output[3] = '=';
			  set_5641as_display_output(display_output);
			  HAL_Delay(2000);
			  set_5641as_display_output(ascii_error_code);
			  HAL_Delay(2000);
		  }
      }
      /* Validate whether the Cold Water Temperature Sensor is currently under a short-circuit or not. */
      else if (HAL_GPIO_ReadPin(Cold_Water_Shortcircuit_Indicator_GPIO_Input_GPIO_Port, Cold_Water_Shortcircuit_Indicator_GPIO_Input_Pin) == GPIO_PIN_RESET)
      {
		  while (1)
		  {
			  convert_number_to_ASCII(MTKATR001_COLD_WATER_TEMP_IS_UNDER_SHORTCIRCUIT, ascii_error_code);
			  ascii_error_code[3] = 0;
			  display_output[0] = 'E';
			  display_output[1] = 'r';
			  display_output[2] = 'r';
			  display_output[3] = '=';
			  set_5641as_display_output(display_output);
			  HAL_Delay(2000);
			  set_5641as_display_output(ascii_error_code);
			  HAL_Delay(2000);
		  }
      }
      /* Show the Desired Internal Ambient temperature at the MTKATR001's Display if the user requests it. */
      else if (HAL_GPIO_ReadPin(Show_desired_internal_ambient_temperature_GPIO_Input_GPIO_Port, Show_desired_internal_ambient_temperature_GPIO_Input_Pin) == GPIO_PIN_SET)
      {
          convert_number_to_ASCII((float) desired_internal_ambient_temperature, display_output);
          display_output[3] = 'C';
          set_5641as_display_output(display_output);
          HAL_Delay(1000);
      }
      /* Show the current Application Firmware Version at the MTKATR001's Display if the user requests it. */
      else if (HAL_GPIO_ReadPin(Show_current_firmware_version_GPIO_Input_GPIO_Port, Show_current_firmware_version_GPIO_Input_Pin) == GPIO_PIN_SET)
      {
          display_output[0] = '\0';
          display_output[1] = 'A';
          display_output[2] = 'F';
          display_output[3] = '=';
          set_5641as_display_output(display_output);
          HAL_Delay(500);
          convert_number_to_ASCII((float)(APP_version[0]) + ((float)APP_version[1]/10.0), display_output);
          display_output[3] = 0;
          set_5641as_display_output(display_output);
          HAL_Delay(500);
      }
      /* Show the Duty Cycle of the Hot Fan at the MTKATR001's Display if the user requests it. */
      else if (HAL_GPIO_ReadPin(Show_hot_fan_duty_cycle_GPIO_Input_GPIO_Port, Show_hot_fan_duty_cycle_GPIO_Input_Pin) == GPIO_PIN_SET)
      {
          if (desired_hot_fan_duty_cycle == 100)
          {
              display_output[0] = '1';
              display_output[1] = '0';
              display_output[2] = '0';
              display_output[3] = 'd';
          }
          else
          {
              convert_number_to_ASCII((float) desired_hot_fan_duty_cycle, display_output);
              display_output[3] = 'd';
          }
          set_5641as_display_output(display_output);
          HAL_Delay(1000);
      }
      /* Show the Duty Cycle of the Cold Fan at the MTKATR001's Display if the user requests it. */
      else if (HAL_GPIO_ReadPin(Show_cold_fan_duty_cycle_GPIO_Input_GPIO_Port, Show_cold_fan_duty_cycle_GPIO_Input_Pin) == GPIO_PIN_SET)
      {
          if (desired_cold_fan_duty_cycle == 100)
          {
              display_output[0] = '1';
              display_output[1] = '0';
              display_output[2] = '0';
              display_output[3] = 'd';
          }
          else
          {
              convert_number_to_ASCII((float) desired_cold_fan_duty_cycle, display_output);
              display_output[3] = 'd';
          }
          set_5641as_display_output(display_output);
          HAL_Delay(1000);
      }
      /* Proceed into the main code if both the short-circuits validations passed and if the user did not requested to see a specific MTKATR001 System Parameter. */
      else
      {
          /* Read and get the Cold Water Temperature. */
          update_current_cold_water_temperature();

          /* Read and get the Hot Water Temperature. */
          update_current_hot_water_temperature();

          /* Read and get the Current Internal Ambient temperature. */
          update_current_internal_ambient_temperature();

          // DELETE THE FOLLOWING TEST CODE:
          while(1)
          {
        	  update_current_internal_ambient_temperature();
			  convert_number_to_ASCII(current_internal_ambient_temperature, display_output);
			  display_output[3] = 'C';
			  set_5641as_display_output(display_output);
			  HAL_Delay(1000);
          }

          /* Check whether Cold or Hot Water is needed to respectively lower or raise the Internal Ambient Temperature in the MTKATR001 System, and take the corresponding actions to achieve it. */
          if (current_internal_ambient_temperature >= (((float) desired_internal_ambient_temperature)-INTERNAL_AMBIENT_TEMP_ERROR_ALLOWED))
          {
              /* Turn Off the Hot Fan and Hot Water Pump to stop throwing heat inside the MTKATR001 System. */
              __HAL_TIM_SET_COMPARE(&htim3, HOT_FAN_TIMER_CHANNEL, get_compare_value_for_fan_pwm(0, HOT_FAN_MAX_COMPARE_VALUE));
              HAL_GPIO_WritePin(Hot_Water_Pump_GPIO_Output_GPIO_Port, Hot_Water_Pump_GPIO_Output_Pin, GPIO_PIN_RESET);

              /* Check whether Cold Water is needed to lower the Internal Ambient Temperature in the MTKATR001 or if the Current Internal Temperature is within the desired Temperature range, and take the corresponding actions. */
              if (current_internal_ambient_temperature <= (((float) desired_internal_ambient_temperature)+INTERNAL_AMBIENT_TEMP_ERROR_ALLOWED))
              {
                  /* Turn Off the Cold Fan and Cold Water Pump to stop throwing Cold Air inside the MTKATR001 System. */
                  __HAL_TIM_SET_COMPARE(&htim3, COLD_FAN_TIMER_CHANNEL, get_compare_value_for_fan_pwm(0, COLD_FAN_MAX_COMPARE_VALUE));
                  HAL_GPIO_WritePin(Cold_Water_Pump_GPIO_Output_GPIO_Port, Cold_Water_Pump_GPIO_Output_Pin, GPIO_PIN_RESET);

                  /* The Desired Internal Ambient Temperature has been reached. Therefore, turn On the IIART LED. */
                  HAL_GPIO_WritePin(IIATR_LED_GPIO_Output_GPIO_Port, IIATR_LED_GPIO_Output_Pin, GPIO_PIN_SET);

                  /* Show the value of the Current Internal Ambient Temperature on the 7-segment Display Device. */
                  convert_number_to_ASCII(current_internal_ambient_temperature, display_output);
                  display_output[3] = 'C';
                  set_5641as_display_output(display_output);
                  HAL_Delay(1000);
              }
              else
              {
                  /* The Desired Internal Ambient Temperature has not been reached. Therefore, turn Off the IIART LED. */
                  HAL_GPIO_WritePin(IIATR_LED_GPIO_Output_GPIO_Port, IIATR_LED_GPIO_Output_Pin, GPIO_PIN_RESET);

                  /* Inform the user if Cooler Water is needed and, if it is cooled enough, then start cooling inside the MTKATR0001 System. */
                  while (current_cold_water_temperature > ((float) desired_cold_water_max_temperature))
                  {
                      /* Inform the user via the 7-segment Display that the Cold Water is currently being cooled. */
                      display_output[0] = 'n';
                      display_output[1] = 'E';
                      display_output[2] = 'E';
                      display_output[3] = 'd';
                      set_5641as_display_output(display_output);
                      HAL_Delay(500);
                      display_output[0] = 'C';
                      display_output[1] = 'o';
                      display_output[2] = 'l';
                      display_output[3] = 'd';
                      set_5641as_display_output(display_output);
                      HAL_Delay(500);
                      display_output[0] = 'A';
                      display_output[1] = 't';
                      display_output[2] = 'E';
                      display_output[3] = 'r';
                      set_5641as_display_output(display_output);
                      HAL_Delay(500);
                      display_output[0] = 0;
                      display_output[1] = '.';
                      display_output[2] = '.';
                      display_output[3] = '.';
                      set_5641as_display_output(display_output);
                      HAL_Delay(500);

                      /* Read and get the Cold Water Temperature. */
                      update_current_cold_water_temperature();
                  }

                  /* Turn On the Cold Fan and Cold Water Pump to throw Cold Air inside the MTKATR001 System. */
                  __HAL_TIM_SET_COMPARE(&htim3, COLD_FAN_TIMER_CHANNEL, get_compare_value_for_fan_pwm(desired_cold_fan_duty_cycle, COLD_FAN_MAX_COMPARE_VALUE));
                  HAL_GPIO_WritePin(Cold_Water_Pump_GPIO_Output_GPIO_Port, Cold_Water_Pump_GPIO_Output_Pin, GPIO_PIN_SET);

                  /* Show the value of the Current Internal Ambient Temperature on the 7-segment Display Device. */
                  convert_number_to_ASCII(current_internal_ambient_temperature, display_output);
                  display_output[3] = 'C';
                  set_5641as_display_output(display_output);
                  HAL_Delay(1000);
              }
          }
          else
          {
              /* The Desired Internal Ambient Temperature has not been reached. Therefore, turn Off the IIART LED. */
              HAL_GPIO_WritePin(IIATR_LED_GPIO_Output_GPIO_Port, IIATR_LED_GPIO_Output_Pin, GPIO_PIN_RESET);

              /* Throw Heat inside the MTKATR001 System if the Hot Water is hot enough. Otherwise, heat the Hot Water more. */
              if (current_hot_water_temperature >= ((float) desired_hot_water_min_temperature))
              {
                  /* Turn On the Hot Fan and Hot Water Pump to throw heat inside the MTKATR001 System. */
                  __HAL_TIM_SET_COMPARE(&htim3, HOT_FAN_TIMER_CHANNEL, get_compare_value_for_fan_pwm(desired_hot_fan_duty_cycle, HOT_FAN_MAX_COMPARE_VALUE));
                  HAL_GPIO_WritePin(Hot_Water_Pump_GPIO_Output_GPIO_Port, Hot_Water_Pump_GPIO_Output_Pin, GPIO_PIN_SET);

                  /* Show the value of the Current Internal Ambient Temperature on the 7-segment Display Device. */
                  convert_number_to_ASCII(current_internal_ambient_temperature, display_output);
                  display_output[3] = 'C';
                  set_5641as_display_output(display_output);
                  HAL_Delay(1000);
              }
              else
              {
                  /* Turn On the Water Heating Resistor in order to heat the Hot Water more. */
                  HAL_GPIO_WritePin(Water_Heating_Resistor_GPIO_Output_GPIO_Port, Water_Heating_Resistor_GPIO_Output_Pin, GPIO_PIN_SET);

                  /* Continue Heating the Hot Water more until it is heated to the desired temperature. */
                  while (current_hot_water_temperature < ((float) desired_hot_water_temperature))
                  {
                      /* Inform the user via the 7-segment Display that the Hot Water is currently being heated. */
                      display_output[0] = 'H';
                      display_output[1] = 'E';
                      display_output[2] = 'A';
                      display_output[3] = 't';
                      set_5641as_display_output(display_output);
                      HAL_Delay(500);
                      display_output[0] = 0;
                      display_output[1] = 'H';
                      display_output[2] = 'o';
                      display_output[3] = 't';
                      set_5641as_display_output(display_output);
                      HAL_Delay(500);
                      display_output[0] = 'A';
                      display_output[1] = 't';
                      display_output[2] = 'E';
                      display_output[3] = 'r';
                      set_5641as_display_output(display_output);
                      HAL_Delay(500);
                      display_output[0] = 0;
                      display_output[1] = '.';
                      display_output[2] = '.';
                      display_output[3] = '.';
                      set_5641as_display_output(display_output);
                      HAL_Delay(500);

                      /* Read and get the Hot Water Temperature. */
                      update_current_hot_water_temperature();
                  }

                  /* Turn Off the Water Heating Resistor. */
                  HAL_GPIO_WritePin(Water_Heating_Resistor_GPIO_Output_GPIO_Port, Water_Heating_Resistor_GPIO_Output_Pin, GPIO_PIN_RESET);

                  /* Show the value of the Current Internal Ambient Temperature on the 7-segment Display Device. */
                  convert_number_to_ASCII(current_internal_ambient_temperature, display_output);
                  display_output[3] = 'C';
                  set_5641as_display_output(display_output);
                  HAL_Delay(1000);
              }
          }
      }
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSE;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV4;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
  PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV8;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 1;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_0;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_239CYCLES_5;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 416-1;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}

/**
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 0;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 1818-1;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */
  HAL_TIM_MspPostInit(&htim3);

}

/**
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 9600;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(IIATR_LED_GPIO_Output_GPIO_Port, IIATR_LED_GPIO_Output_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, Display_C_terminal_GPIO_Output_Pin|Display_D_terminal_GPIO_Output_Pin|Water_Heating_Resistor_GPIO_Output_Pin|Cold_Water_Pump_GPIO_Output_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, Display_A_terminal_GPIO_Output_Pin|Display_B_terminal_GPIO_Output_Pin|Hot_Water_Pump_GPIO_Output_Pin|Display_E_terminal_GPIO_Output_Pin
                          |Display_F_terminal_GPIO_Output_Pin|Display_G_terminal_GPIO_Output_Pin|Display_Dp_terminal_GPIO_Output_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, Display_K2_terminal_GPIO_Output_Pin|Display_K3_terminal_GPIO_Output_Pin|Display_K4_terminal_GPIO_Output_Pin|Display_K1_terminal_GPIO_Output_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin : IIATR_LED_GPIO_Output_Pin */
  GPIO_InitStruct.Pin = IIATR_LED_GPIO_Output_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(IIATR_LED_GPIO_Output_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : HM10_is_default_settings_GPIO_Input_Pin Show_cold_fan_duty_cycle_GPIO_Input_Pin */
  GPIO_InitStruct.Pin = HM10_is_default_settings_GPIO_Input_Pin|Show_cold_fan_duty_cycle_GPIO_Input_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : Display_C_terminal_GPIO_Output_Pin Display_D_terminal_GPIO_Output_Pin Water_Heating_Resistor_GPIO_Output_Pin Cold_Water_Pump_GPIO_Output_Pin */
  GPIO_InitStruct.Pin = Display_C_terminal_GPIO_Output_Pin|Display_D_terminal_GPIO_Output_Pin|Water_Heating_Resistor_GPIO_Output_Pin|Cold_Water_Pump_GPIO_Output_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pins : Display_A_terminal_GPIO_Output_Pin Display_B_terminal_GPIO_Output_Pin Display_K2_terminal_GPIO_Output_Pin Display_K3_terminal_GPIO_Output_Pin
                           Display_K4_terminal_GPIO_Output_Pin Hot_Water_Pump_GPIO_Output_Pin Display_E_terminal_GPIO_Output_Pin Display_F_terminal_GPIO_Output_Pin
                           Display_G_terminal_GPIO_Output_Pin Display_Dp_terminal_GPIO_Output_Pin Display_K1_terminal_GPIO_Output_Pin */
  GPIO_InitStruct.Pin = Display_A_terminal_GPIO_Output_Pin|Display_B_terminal_GPIO_Output_Pin|Display_K2_terminal_GPIO_Output_Pin|Display_K3_terminal_GPIO_Output_Pin
                          |Display_K4_terminal_GPIO_Output_Pin|Hot_Water_Pump_GPIO_Output_Pin|Display_E_terminal_GPIO_Output_Pin|Display_F_terminal_GPIO_Output_Pin
                          |Display_G_terminal_GPIO_Output_Pin|Display_Dp_terminal_GPIO_Output_Pin|Display_K1_terminal_GPIO_Output_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pins : Hot_Water_Shortcircuit_Indicator_GPIO_Input_Pin Cold_Water_Shortcircuit_Indicator_GPIO_Input_Pin Show_desired_internal_ambient_temperature_GPIO_Input_Pin Show_hot_fan_duty_cycle_GPIO_Input_Pin */
  GPIO_InitStruct.Pin = Hot_Water_Shortcircuit_Indicator_GPIO_Input_Pin|Cold_Water_Shortcircuit_Indicator_GPIO_Input_Pin|Show_desired_internal_ambient_temperature_GPIO_Input_Pin|Show_hot_fan_duty_cycle_GPIO_Input_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : Show_current_firmware_version_GPIO_Input_Pin */
  GPIO_InitStruct.Pin = Show_current_firmware_version_GPIO_Input_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(Show_current_firmware_version_GPIO_Input_GPIO_Port, &GPIO_InitStruct);

}

/* USER CODE BEGIN 4 */

#if ETX_OTA_VERBOSE
    /**@brief	Compiler definition to be able to use the @ref printf function from stdio.h library in order to print
     *          characters via the UART1 Peripheral but by using that @ref printf function.
     *
     * @return	The \p ch param.
     *
     * author	César Miranda Meza
     * @date	July 07, 2023
     */
    #ifdef __GNUC__
        /* With GCC, small printf (option LD Linker->Libraries->Small printf set to 'Yes') calls __io_putchar(). */
        int __io_putchar(int ch)
    #else
        int fputc(int ch, FILE *f)
    #endif /* __GNUC__ */
    {
        /* Place your implementation of fputc here. */
        /* NOTE: The characters written into the UART1 Protocol will be looped until the end of transmission. */
        HAL_UART_Transmit(&huart1, (uint8_t *) &ch, 1, HAL_MAX_DELAY);
        return ch;
    }
#endif

static HAL_StatusTypeDef get_adc_output(ADC_HandleTypeDef *hadc, uint32_t adc_channel, float *dst)
{
    /** <b>Local variable adc_config:</b> @ref ADC_ChannelConfTypeDef Struct Type used to define the Configurations required for the requested ADC so that the desired Channel is chosen in that particular ADC. */
    ADC_ChannelConfTypeDef sConfig = {0};
    /** <b>Local variable ret:</b> Local variable used to hold the return value of a @ref HAL_StatusTypeDef function type. */
    HAL_StatusTypeDef ret;

    /* Change the current ADC Configuration Settings so that the desired ADC and Channel are selected. */
    sConfig.Channel = adc_channel;
    sConfig.Rank = ADC_REGULAR_RANK_1;
    sConfig.SamplingTime = ADC_SAMPLETIME_239CYCLES_5;
    ret = HAL_ADC_ConfigChannel(hadc, &sConfig);
    if (ret != HAL_OK)
    {
    	return ret;
    }

    /* Start the selected ADC and Channel. */
    ret = HAL_ADC_Start(hadc);
    if (ret != HAL_OK)
    {
        return ret;
    }

    /* Get the output value of the selected ADC and Channel. */
    ret = HAL_ADC_PollForConversion(hadc, ADC_POLL_TIMEOUT); // Polling a single conversion from the selected ADC and Channel.
    if (ret != HAL_OK)
    {
        return ret;
    }
    *dst = HAL_ADC_GetValue(hadc); // Retrieve the polled value from the selected ADC Channel.

    /* Stop the selected ADC and Channel. */
    return HAL_ADC_Stop(hadc);
}

// Place PWM Function here.

static void custom_initialize_5641as_display_driver(void)
{
    /* Populate the 5641AS 7-segment Display Device's Peripherals Definition parameters structure. */
    display_peripherals.A.GPIO_Port = GPIOB;
    display_peripherals.A.GPIO_Pin = GPIO_PIN_0;
    display_peripherals.B.GPIO_Port = GPIOB;
    display_peripherals.B.GPIO_Pin = GPIO_PIN_1;
    display_peripherals.C.GPIO_Port = GPIOA;
    display_peripherals.C.GPIO_Pin = GPIO_PIN_2;
    display_peripherals.D.GPIO_Port = GPIOA;
    display_peripherals.D.GPIO_Pin = GPIO_PIN_3;
    display_peripherals.E.GPIO_Port = GPIOB;
    display_peripherals.E.GPIO_Pin = GPIO_PIN_5;
    display_peripherals.F.GPIO_Port = GPIOB;
    display_peripherals.F.GPIO_Pin = GPIO_PIN_6;
    display_peripherals.G.GPIO_Port = GPIOB;
    display_peripherals.G.GPIO_Pin = GPIO_PIN_7;
    display_peripherals.Dp.GPIO_Port = GPIOB;
    display_peripherals.Dp.GPIO_Pin = GPIO_PIN_8;
    display_peripherals.K1.GPIO_Port = GPIOB;
    display_peripherals.K1.GPIO_Pin = GPIO_PIN_9;
    display_peripherals.K2.GPIO_Port = GPIOB;
    display_peripherals.K2.GPIO_Pin = GPIO_PIN_12;
    display_peripherals.K3.GPIO_Port = GPIOB;
    display_peripherals.K3.GPIO_Pin = GPIO_PIN_13;
    display_peripherals.K4.GPIO_Port = GPIOB;
    display_peripherals.K4.GPIO_Pin = GPIO_PIN_14;

    /* Define the desired On-Time and Off-Time steps. */
    // NOTE:  For this particular case, I will consider a PWM Period of 10 Time steps, where the On-Time will be of 6 Time
    //        steps and, therefore, the Off-Time will be of 4 Time steps.
    // NOTE:  In consideration that the Timer to be used in non-interrupt mode by the 5641AS 7-segment Display Driver
    //        module will be triggered by this example each 4'807Hz approximately (meaning that each 7-segment display of
    //        that device will be refreshed at each 120Hz approximately), this will allow this module to output a
    //        sufficiently fast refresh rate at the 5641AS Device so that the human eye is able to see as if all the
    //        7-segment displays of that device are being simultaneously activated.
    /** <b>Local variable on_time_steps:</b> uint32_t Variable Type used to hold the desired On-Time-Steps for the Simulated PWM that we want the @ref display_5641as to generate whenever turning On the LEDs in the 5641AS 7-segment Display Device. */
    uint32_t on_time_steps = 6;
    /** <b>Local variable off_time_steps:</b> uint32_t Variable Type used to hold the desired Off-Time-Steps for the Simulated PWM that we want the @ref display_5641as to generate whenever turning On the LEDs in the 5641AS 7-segment Display Device. */
    uint32_t off_time_steps = 4;

    /* Initialize the 5641AS 7-segment Display Driver module. */
    init_5641as_display_module(&htim2, &display_peripherals, on_time_steps, off_time_steps);
}

static int convert_number_to_ASCII(float src, uint16_t *dst)
{
    if ((src>=100) || (src<=-10))
    {
        return -1;
    }

    if (src > 0)
    {
        uint8_t first_character = src/10;
        switch (first_character)
        {
            case 0:
                dst[0] = Command_NULL_in_ASCII;
                break;
            case 1:
                dst[0] = Number_1_in_ASCII;
                break;
            case 2:
                dst[0] = Number_2_in_ASCII;
                break;
            case 3:
                dst[0] = Number_3_in_ASCII;
                break;
            case 4:
                dst[0] = Number_4_in_ASCII;
                break;
            case 5:
                dst[0] = Number_5_in_ASCII;
                break;
            case 6:
                dst[0] = Number_6_in_ASCII;
                break;
            case 7:
                dst[0] = Number_7_in_ASCII;
                break;
            case 8:
                dst[0] = Number_8_in_ASCII;
                break;
            case 9:
                dst[0] = Number_9_in_ASCII;
                break;
            default:
                // This case should not give place ever.
        }

        uint8_t second_character = src - (first_character*10);
        switch (second_character)
        {
            case 0:
                dst[1] = Number_0Dp_in_ASCII;
                break;
            case 1:
                dst[1] = Number_1Dp_in_ASCII;
                break;
            case 2:
                dst[1] = Number_2Dp_in_ASCII;
                break;
            case 3:
                dst[1] = Number_3Dp_in_ASCII;
                break;
            case 4:
                dst[1] = Number_4Dp_in_ASCII;
                break;
            case 5:
                dst[1] = Number_5Dp_in_ASCII;
                break;
            case 6:
                dst[1] = Number_6Dp_in_ASCII;
                break;
            case 7:
                dst[1] = Number_7Dp_in_ASCII;
                break;
            case 8:
                dst[1] = Number_8Dp_in_ASCII;
                break;
            case 9:
                dst[1] = Number_9Dp_in_ASCII;
                break;
            default:
                // This case should not give place ever.
        }

        uint8_t third_character = (src - (first_character*10) - (second_character)) * 10;
        switch (third_character)
        {
            case 0:
                dst[2] = Number_0_in_ASCII;
                break;
            case 1:
                dst[2] = Number_1_in_ASCII;
                break;
            case 2:
                dst[2] = Number_2_in_ASCII;
                break;
            case 3:
                dst[2] = Number_3_in_ASCII;
                break;
            case 4:
                dst[2] = Number_4_in_ASCII;
                break;
            case 5:
                dst[2] = Number_5_in_ASCII;
                break;
            case 6:
                dst[2] = Number_6_in_ASCII;
                break;
            case 7:
                dst[2] = Number_7_in_ASCII;
                break;
            case 8:
                dst[2] = Number_8_in_ASCII;
                break;
            case 9:
                dst[2] = Number_9_in_ASCII;
                break;
            default:
                // This case should not give place ever.
        }
    }
    else if (src == 0)
    {
        dst[0] = Command_NULL_in_ASCII;
        dst[1] = Number_0Dp_in_ASCII;
        dst[2] = Number_0_in_ASCII;
    }
    else
    {
        dst[0] = Letter_minus_sign_in_ASCII;

        uint8_t second_character = (-1)*src;
        switch (second_character)
        {
            case 0:
                dst[1] = Number_0Dp_in_ASCII;
                break;
            case 1:
                dst[1] = Number_1Dp_in_ASCII;
                break;
            case 2:
                dst[1] = Number_2Dp_in_ASCII;
                break;
            case 3:
                dst[1] = Number_3Dp_in_ASCII;
                break;
            case 4:
                dst[1] = Number_4Dp_in_ASCII;
                break;
            case 5:
                dst[1] = Number_5Dp_in_ASCII;
                break;
            case 6:
                dst[1] = Number_6Dp_in_ASCII;
                break;
            case 7:
                dst[1] = Number_7Dp_in_ASCII;
                break;
            case 8:
                dst[1] = Number_8Dp_in_ASCII;
                break;
            case 9:
                dst[1] = Number_9Dp_in_ASCII;
                break;
            default:
                // This case should not give place ever.
        }

        uint8_t third_character = ((src*-1) - second_character) * 10;
        switch (third_character)
        {
            case 0:
                dst[2] = Number_0_in_ASCII;
                break;
            case 1:
                dst[2] = Number_1_in_ASCII;
                break;
            case 2:
                dst[2] = Number_2_in_ASCII;
                break;
            case 3:
                dst[2] = Number_3_in_ASCII;
                break;
            case 4:
                dst[2] = Number_4_in_ASCII;
                break;
            case 5:
                dst[2] = Number_5_in_ASCII;
                break;
            case 6:
                dst[2] = Number_6_in_ASCII;
                break;
            case 7:
                dst[2] = Number_7_in_ASCII;
                break;
            case 8:
                dst[2] = Number_8_in_ASCII;
                break;
            case 9:
                dst[2] = Number_9_in_ASCII;
                break;
            default:
                // This case should not give place ever.
        }
    }

    return 0;
}

static void custom_firmware_update_config_init()
{
    /** <b>Local variable ret:</b> Return value of a @ref FirmUpdConf_Status function type. */
    int16_t ret;
    /** <b>Local variable attempts:</b> Counter for the number of attempts to initialize the Firmware Update Configurations sub-module. */
    uint8_t attempts = 0;
    /** <b>Local variable end_tick:</b> Defines the HAL Tick that our MCU/MPU needs to reach so that 0.5 seconds have passed with respect to each attempt to initialize the @ref firmware_update_config . */
    uint32_t end_tick;
    /** <b>Local variable current_tick:</b> Current HAL Tick in our MCU/MPU. */
    uint32_t current_tick;

    #if ETX_OTA_VERBOSE
        printf("Initializing the Firmware Update Configurations sub-module...\r\n");
    #endif
    do
    {
        /* Delay of 500 milliseconds. */
        end_tick = HAL_GetTick() + 500;
        current_tick = 0;
        while (current_tick < end_tick)
        {
            current_tick = HAL_GetTick();
        }

        /* We attempt to initialize the Firmware Update Configurations sub-module. */
        ret = firmware_update_configurations_init();
        attempts++;
        if (ret == FIRM_UPDT_CONF_EC_OK)
        {
            /* We read the latest data that has been written into the Firmware Update Configurations sub-module. */
            firmware_update_configurations_read(&fw_config);
            #if ETX_OTA_VERBOSE
                printf("DONE: Firmware Update Configurations sub-module has been successfully initialized.\r\n");
            #endif
            return;
        }
        #if ETX_OTA_VERBOSE
            printf("WARNING: The Firmware Update Configurations sub-module could not be initialized at attempt %d...\r\n", attempts);
        #endif
    }
    while(attempts < 3);

    #if ETX_OTA_VERBOSE
        printf("ERROR: The Firmware Update Configurations sub-module could not be initialized. Our MCU/MPU will halt!.\r\n");
    #endif
    while (1)
    {
    	convert_number_to_ASCII(MTKATR001_EC_INIT_FW_UPDT_CONF_MODULE_ERR, ascii_error_code);
		ascii_error_code[3] = 0;
		display_output[0] = 'E';
		display_output[1] = 'r';
		display_output[2] = 'r';
		display_output[3] = '=';
        set_5641as_display_output(display_output);
        HAL_Delay(2000);
        set_5641as_display_output(ascii_error_code);
        HAL_Delay(2000);
    }
}

static void custom_init_etx_ota_protocol_module(ETX_OTA_hw_Protocol hw_protocol, UART_HandleTypeDef *p_huart)
{
    /** <b>Local variable ret:</b> Used to hold the exception code value returned by a @ref ETX_OTA_Status function type. */
    ETX_OTA_Status ret;

    #if ETX_OTA_VERBOSE
        printf("Initializing the ETX OTA Firmware Update Module.\r\n");
    #endif
    GPIO_is_hm10_default_settings.GPIO_Port = HM10_is_default_settings_GPIO_Input_GPIO_Port;
    GPIO_is_hm10_default_settings.GPIO_Pin = HM10_is_default_settings_GPIO_Input_Pin;

    ret = init_firmware_update_module(hw_protocol, p_huart, &fw_config, &GPIO_is_hm10_default_settings, &etx_ota_custom_data);
    if (ret != ETX_OTA_EC_OK)
    {
        #if ETX_OTA_VERBOSE
            printf("ERROR: The ETX OTA Firmware Update Module could not be initialized. Our MCU/MPU will halt!.\r\n");
        #endif
        while (1)
        {
        	convert_number_to_ASCII(MTKATR001_EC_INIT_ETX_OTA_MODULE_ERR, ascii_error_code);
			ascii_error_code[3] = 0;
			display_output[0] = 'E';
			display_output[1] = 'r';
			display_output[2] = 'r';
			display_output[3] = '=';
            set_5641as_display_output(display_output);
            HAL_Delay(2000);
            set_5641as_display_output(ascii_error_code);
            HAL_Delay(2000);
        }
    }
    #if ETX_OTA_VERBOSE
        printf("DONE: The ETX OTA Firmware Update Module has been successfully initialized.\r\n");
    #endif
}

static void validate_application_firmware()
{
    #if ETX_OTA_VERBOSE
        printf("Validating currently installed Application Firmware in our MCU/MPU...\r\n");
    #endif
    if ((fw_config.App_fw_size==DATA_BLOCK_32BIT_ERASED_VALUE) || (fw_config.App_fw_size==0x00000000))
	{
        #if ETX_OTA_VERBOSE
            printf("ERROR: No Application Firmware has been identified to be installed in our MCU/MPU.\r\n");
        #endif
        while (1)
        {
        	convert_number_to_ASCII(MTKATR001_APPLICATION_FIRMWARE_VALIDATION_ERR, ascii_error_code);
			ascii_error_code[3] = 0;
			display_output[0] = 'E';
			display_output[1] = 'r';
			display_output[2] = 'r';
			display_output[3] = '=';
            set_5641as_display_output(display_output);
            HAL_Delay(2000);
            set_5641as_display_output(ascii_error_code);
            HAL_Delay(2000);
        }
	}

    if (fw_config.App_fw_rec_crc == DATA_BLOCK_32BIT_ERASED_VALUE)
    {
        #if ETX_OTA_VERBOSE
            printf("ERROR: The recorded 32-bit CRC of the installed Application Firmware has no value in it.\r\n");
        #endif
        while (1)
        {
        	convert_number_to_ASCII(MTKATR001_APPLICATION_FIRMWARE_VALIDATION_ERR, ascii_error_code);
			ascii_error_code[3] = 0;
			display_output[0] = 'E';
			display_output[1] = 'r';
			display_output[2] = 'r';
			display_output[3] = '=';
            set_5641as_display_output(display_output);
            HAL_Delay(2000);
            set_5641as_display_output(ascii_error_code);
            HAL_Delay(2000);
        }
    }

    /** <b>Local variable cal_crc:</b> Value holder for the calculated 32-bit CRC of our MCU/MPU's current Application Firmware. */
	uint32_t cal_crc = crc32_mpeg2((uint8_t *) APLICATION_FIRMWARE_ADDRESS, fw_config.App_fw_size);

    if (cal_crc != fw_config.App_fw_rec_crc)
    {
        #if ETX_OTA_VERBOSE
            printf("ERROR: The recorded 32-bit CRC of the installed Application Firmware Image mismatches with the calculated one: [Calculated CRC = 0x%08X] [Recorded CRC = 0x%08X]\r\n",
                    (unsigned int) cal_crc, (unsigned int) fw_config.App_fw_rec_crc);
        #endif
        while (1)
        {
        	convert_number_to_ASCII(MTKATR001_APPLICATION_FIRMWARE_VALIDATION_ERR, ascii_error_code);
			ascii_error_code[3] = 0;
			display_output[0] = 'E';
			display_output[1] = 'r';
			display_output[2] = 'r';
			display_output[3] = '=';
            set_5641as_display_output(display_output);
            HAL_Delay(2000);
            set_5641as_display_output(ascii_error_code);
            HAL_Delay(2000);
        }
    }
    #if ETX_OTA_VERBOSE
        printf("DONE: The currently installed Application Firmware in our MCU/MPU has been successfully validated.\r\n");
    #endif
}

static uint16_t get_compare_value_for_fan_pwm(uint16_t desired_duty_cycle, uint16_t max_compare_value)
{
    /* Validate the given Duty Cycle, and change it to the nearest valid value with respect to the one given in case that it has an invalid value. */
    if (desired_duty_cycle < 0)
    {
        desired_duty_cycle = 0;
    }
    else if (desired_duty_cycle > 100)
    {
        desired_duty_cycle = 100;
    }

    /* Return the PWM Compare value required to set the requested PWM Duty Cycle. */
    return (desired_duty_cycle*max_compare_value)/100;
}

static void update_current_cold_water_temperature(void)
{
	/** <b>Local variable ret:</b> Used to hold the exception code value returned by a @ref HAL_StatusTypeDef function type. */
	HAL_StatusTypeDef ret;

	/* Read the corresponding ADC and update the Cold Water Temperature. */
	ret = get_adc_output(&hadc1, ADC_CHANNEL_0, &current_cold_water_temperature);
	if (ret != HAL_OK)
	{
		while (1)
		{
			convert_number_to_ASCII(MTKATR001_COLD_WATER_TEMP_ADC_ERR, ascii_error_code);
			ascii_error_code[3] = 0;
			display_output[0] = 'E';
			display_output[1] = 'r';
			display_output[2] = 'r';
			display_output[3] = '=';
			set_5641as_display_output(display_output);
			HAL_Delay(2000);
			set_5641as_display_output(ascii_error_code);
			HAL_Delay(2000);
		}
	}
	current_cold_water_temperature = ((current_cold_water_temperature)*(LM35_VOLTAGE_TO_CELSIUS_CONSTANT)*(MCU_POWER_SUPPLY_VOLTAGE))/(ADC_BITS_IN_DECIMAL_VALUE); // Converting the Polled value to the Temperature that it stands for.
}

static void update_current_hot_water_temperature(void)
{
	/** <b>Local variable ret:</b> Used to hold the exception code value returned by a @ref HAL_StatusTypeDef function type. */
	HAL_StatusTypeDef ret;

	/* Read the corresponding ADC and update the Hot Water Temperature. */
	ret = get_adc_output(&hadc1, ADC_CHANNEL_1, &current_hot_water_temperature);
	if (ret != HAL_OK)
	{
		while (1)
		{
			convert_number_to_ASCII(MTKATR001_HOT_WATER_TEMP_ADC_ERR, ascii_error_code);
			ascii_error_code[3] = 0;
			display_output[0] = 'E';
			display_output[1] = 'r';
			display_output[2] = 'r';
			display_output[3] = '=';
			set_5641as_display_output(display_output);
			HAL_Delay(2000);
			set_5641as_display_output(ascii_error_code);
			HAL_Delay(2000);
		}
	}
	current_hot_water_temperature = ((current_hot_water_temperature)*(LM35_VOLTAGE_TO_CELSIUS_CONSTANT)*(MCU_POWER_SUPPLY_VOLTAGE))/(ADC_BITS_IN_DECIMAL_VALUE); // Converting the Polled value to the Temperature that it stands for.
}

static void update_current_internal_ambient_temperature(void)
{
	/** <b>Local variable ret:</b> Used to hold the exception code value returned by a @ref HAL_StatusTypeDef function type. */
	HAL_StatusTypeDef ret;

	/* Read the corresponding ADC and update the Current Internal Ambient temperature. */
	ret = get_adc_output(&hadc1, ADC_CHANNEL_4, &current_internal_ambient_temperature);
	if (ret != HAL_OK)
	{
		while (1)
		{
			convert_number_to_ASCII(MTKATR001_INTERNAL_AMBIENT_TEMP_ADC_ERR, ascii_error_code);
			ascii_error_code[3] = 0;
			display_output[0] = 'E';
			display_output[1] = 'r';
			display_output[2] = 'r';
			display_output[3] = '=';
			set_5641as_display_output(display_output);
			HAL_Delay(2000);
			set_5641as_display_output(ascii_error_code);
			HAL_Delay(2000);
		}
	}
	current_internal_ambient_temperature = ((current_internal_ambient_temperature)*(LM35_VOLTAGE_TO_CELSIUS_CONSTANT)*(MCU_POWER_SUPPLY_VOLTAGE))/(ADC_BITS_IN_DECIMAL_VALUE); // Converting the Polled value to the Temperature that it stands for.
}

/**@brief	Callback function before an ETX OTA Transaction with the host machine is about to give place.
 *
 * @note    For more details on how this function works with respect to the ETX OTA Protocol, see the Doxygen
 *          Documentation available for it at the @ref app_side_etx_ota .
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date    February 10, 2024.
 */
void etx_ota_pre_transaction_handler()
{
	/* Stopping the non-blocking Interrupts of the MCU. */
    // NOTE:    This must be done in order to guarantee a successful ETX OTA Transaction (the non-blocking interrupts
    //          can be enabled back again after the ETX OTA Transaction has been completed).
    stop_5641as_display_module();
}

/**@brief	ETX OTA Status Response Callback.
 *
 * @details	This function is called by the @ref app_side_etx_ota each time an ETX OTA Transaction has been completed, so
 *          that the implementer of @ref app_side_etx_ota can customize handling the resulting ETX OTA Status Exception
 *          Code.
 *
 * @note    For more details on how this function works with respect to the ETX OTA Protocol, see the Doxygen
 *          Documentation available for it at the @ref app_side_etx_ota .
 *
 * @details As a summary, this function will handle any ETX OTA Firmware Update Requests and, with respect to the
 *          MTKATR001 System, this function will handle any ETX OTA Custom Data Transactions, which are expected to
 *          contain the data to update some Global Variables of the @ref main in the following way:<br>
 *          <ol>
 *              <li>@ref desired_internal_ambient_temperature = 1st byte of data from the @ref etx_ota_custom_data_t::data field of @ref etx_ota_custom_data - 42 </li>
 *              <li>@ref desired_hot_fan_duty_cycle = (2nd byte of data from the @ref etx_ota_custom_data_t::data field of @ref etx_ota_custom_data) + (3rd byte of data from the @ref etx_ota_custom_data_t::data field of @ref etx_ota_custom_data) </li>
 *              <li>@ref desired_cold_fan_duty_cycle = (4th byte of data from the @ref etx_ota_custom_data_t::data field of @ref etx_ota_custom_data) + (5th byte of data from the @ref etx_ota_custom_data_t::data field of @ref etx_ota_custom_data) </li>
 *              <li>@ref desired_hot_water_temperature = 6th byte of data from the @ref etx_ota_custom_data_t::data field of @ref etx_ota_custom_data </li>
 *              <li>@ref desired_hot_water_min_temperature = 7th byte of data from the @ref etx_ota_custom_data_t::data field of @ref etx_ota_custom_data </li>
 *              <li>@ref desired_cold_water_max_temperature = 8th byte of data from the @ref etx_ota_custom_data_t::data field of @ref etx_ota_custom_data - 42 </li>
 *          </ol>
 *			where @ref desired_hot_fan_duty_cycle and @ref desired_cold_fan_duty_cycle will be always set to a value of
 *			100 whenever their retrieved values from the ETX OTA Custom Data Transaction are equal or greater than 100
 *			respectively.
 *
 * @note    The valid value range for each byte contained inside the @ref etx_ota_custom_data_t::data field of
 *          @ref etx_ota_custom_data is the following:<br>
 *          \f$32 \leq\f$ valid value of each byte in the @ref etx_ota_custom_data_t::data field \f$\leq 126\f$<br>
 *          where it is obviously expected that the values to be given to each byte in the
 *          @ref etx_ota_custom_data_t::data field are expected to be whole numbers.
 *
 * @param  resp  Resulting ETX OTA Status Exception Code of the ETX OTA Transaction that has just been completed, where
 *               the only possible values that can be given are the following:<br>
 *               - @ref ETX_OTA_Status::ETX_OTA_EC_OK    (ETX OTA Transactions continues in this case right before this callback function) In this case, some ETX OTA Custom Data has been received from the host.
 *               - @ref ETX_OTA_Status::ETX_OTA_EC_STOP  (ETX OTA Transactions are stopped in this case right before this callback function) In this case, the host has requested to stop a currently on-going ETX OTA Transaction.
 *               - @ref ETX_OTA_Status::ETX_OTA_EC_NR    (ETX OTA Transactions continues in this case right before this callback function) In this case, the host stopped responding to our MCU/MPU during an ETX OTA Transaction.
 *               - @ref ETX_OTA_Status::ETX_OTA_EC_NA    (ETX OTA Transactions are stopped in this case right before this callback function) In this case, an ETX OTA Firmware Update has been requested by the host (remember that this @ref app_side_etx_ota cannot install Firmware Images and, therefore, a reboot is suggested to make the Bootloader Firmware of our MCU/MPU to install that Image).
 *               - @ref ETX_OTA_Status::ETX_OTA_EC_ERR   (ETX OTA Transactions are stopped in this case right before this callback function) In this case, an Error has happened during an on-going ETX OTA Transaction.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date    February 10, 2024.
 */
void etx_ota_status_resp_handler(ETX_OTA_Status resp)
{
	start_5641as_display_module(); // We start back again the 5641AS Driver Timer's Base generation in Interrupt Mode.
    switch (resp)
    {
        case ETX_OTA_EC_OK:
        	/* Validate having received the right amount of bytes from the current ETX OTA Custom Data Transaction. */
        	if (etx_ota_custom_data.size != 8)
        	{
        		/* Show via the 7-segment Display Device that a ETX OTA Custom Data Transaction has been completed, but a different number of bytes was expected. */
				display_output[0] = 'E';
				display_output[1] = 'O';
				display_output[2] = ' ';
				display_output[3] = 'I';
				set_5641as_display_output(display_output);
        	}
        	else
        	{
        		/* Show via the 7-segment Display Device that a ETX OTA Custom Data Transaction has been successfully completed. */
				display_output[0] = 'E';
				display_output[1] = 'O';
				display_output[2] = ' ';
				display_output[3] = 'D';
				set_5641as_display_output(display_output);

				/* Update the parameters of the MTKATR001 System with the Custom Data that has just been recieved via the ETX OTA Protocol. */
				// NOTE:    With the purpose of recycling the Java Host App for sending ETX OTA Custom Data (i.e., to not
				//          modify its code) for simplicity purposes, the valid range of values that will be send from that
				//          App to our MCU/MPU will be from
				desired_internal_ambient_temperature = etx_ota_custom_data.data[0] - 42;
				desired_hot_fan_duty_cycle = (etx_ota_custom_data.data[1]) + (etx_ota_custom_data.data[2]);
				if (desired_hot_fan_duty_cycle > 100)
				{
					desired_hot_fan_duty_cycle = 100;
				}
				desired_cold_fan_duty_cycle = (etx_ota_custom_data.data[3]) + (etx_ota_custom_data.data[4]);
				if (desired_cold_fan_duty_cycle > 100)
				{
					desired_cold_fan_duty_cycle = 100;
				}
				desired_hot_water_temperature = etx_ota_custom_data.data[5];
				desired_hot_water_min_temperature = etx_ota_custom_data.data[6];
				desired_cold_water_max_temperature = etx_ota_custom_data.data[7] - 42;
        	}
	    	break;
        case ETX_OTA_EC_STOP:
            #if ETX_OTA_VERBOSE
                printf("DONE: ETX OTA process has been aborted. Try again...\r\n");
            #endif
            display_output[0] = 'E';
            display_output[1] = 'O';
            display_output[2] = ' ';
            display_output[3] = 'Q';
            set_5641as_display_output(display_output);
			start_etx_ota();
	    	break;
        case ETX_OTA_EC_NR:
            // No response was received from host. Therefore, try hearing for a response from the host again in case our MCU/MPU is still in DFU mode.
            break;
        case ETX_OTA_EC_NA:
            #if ETX_OTA_VERBOSE
                printf("WARNING: A Firmware Image Update has been request.\r\n");
                printf("Resetting our MCU/MPU to jump into its Bootloader Firmware to receive the desired Firmware Image there and then try again...\r\n");
            #endif
			HAL_NVIC_SystemReset(); // We reset our MCU/MPU to try installing a Firmware Image there.
	    	break;
        case ETX_OTA_EC_ERR:
            #if ETX_OTA_VERBOSE
                printf("ERROR: ETX OTA process has failed. Try again...\r\n");
            #endif
        	start_etx_ota();
	    	break;
        default:
        	/* This should never be called. */
            #if ETX_OTA_VERBOSE
                printf("ERROR: Exception Code received %d is not recognized. Our MCU/MPU will halt!.\r\n", resp);
            #endif
            while (1)
            {
            	convert_number_to_ASCII(MTKATR001_EC_ERR, ascii_error_code);
				ascii_error_code[3] = 0;
				display_output[0] = 'E';
				display_output[1] = 'r';
				display_output[2] = 'r';
				display_output[3] = '=';
                set_5641as_display_output(display_output);
                HAL_Delay(2000);
                set_5641as_display_output(ascii_error_code);
                HAL_Delay(2000);
            }
    }
}

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/** @} */
