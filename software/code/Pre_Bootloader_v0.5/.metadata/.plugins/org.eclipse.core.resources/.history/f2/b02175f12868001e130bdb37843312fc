/** @addtogroup firmware_update
 * @{
 */

#include "firmware_update.h"
#include "main.h" // We call this library since it holds the CRC32 calculator and the UART2 handler.
#include <stdio.h>	// Library from which "printf()" is located at.
#include <string.h>	// Library from which "memset()" is located at.
#include <stdbool.h> // Library from which the "bool" type is located at.

#define ETX_OTA_SOF  				(0xAA)    		/**< @brief Designated Start Of Frame (SOF) byte to indicate the start of an ETX OTA Packet. */
#define ETX_OTA_EOF  				(0xBB)    		/**< @brief Designated End Of Frame (EOF) byte to indicate the end of an ETX OTA Packet. */
#define ETX_OTA_SOF_SIZE			(1U)			/**< @brief	Designated SOF field size in bytes in a ETX OTA Packet. */
#define ETX_OTA_PACKET_TYPE_SIZE	(1U)			/**< @brief	Designated Packet Type field size in bytes in a ETX OTA Packet. */
#define ETX_OTA_DATA_LENGTH_SIZE	(2U)			/**< @brief	Designated Data Length field size in bytes in a ETX OTA Packet. */
#define ETX_OTA_DATA_MAX_SIZE 		(1024U)  		/**< @brief Designated maximum expected "Data" field's size in the General Data Format of an ETX OTA Packet. @note This definition's value does not stand for the size of the entire ETX OTA Packet. Instead, it represents the size of the "Data" field that is inside the General Data Format of an ETX OTA Packet. */
#define ETX_OTA_CRC32_SIZE			(4U)			/**< @brief	Designated 32-bit CRC field size in bytes in a ETX OTA Packet. */
#define ETX_OTA_EOF_SIZE			(1U)			/**< @brief	Designated EOF field size in bytes in a ETX OTA Packet. */
#define ETX_OTA_DATA_OVERHEAD 		(ETX_OTA_SOF_SIZE + ETX_OTA_PACKET_TYPE_SIZE + ETX_OTA_DATA_LENGTH_SIZE + ETX_OTA_CRC32_SIZE + ETX_OTA_EOF_SIZE)  	/**< @brief Data overhead in bytes of an ETX OTA Packet, which represents the bytes of an ETX OTA Packet except for the ones that it has at the Data field. */
#define ETX_OTA_PACKET_MAX_SIZE 	(ETX_OTA_DATA_MAX_SIZE + ETX_OTA_DATA_OVERHEAD)																		/**< @brief Total bytes in an ETX OTA Packet. */
#define ETX_OTA_DATA_FIELD_INDEX	(ETX_OTA_SOF_SIZE + ETX_OTA_PACKET_TYPE_SIZE + ETX_OTA_DATA_LENGTH_SIZE) 											/**< @brief Index position of where the Data field bytes of a ETX OTA Packet starts at. */
#define ETX_OTA_BL_FW_SIZE          (FLASH_PAGE_SIZE_IN_BYTES * ETX_BL_FLASH_PAGES_SIZE)   	/**< @brief Maximum size allowable for a Bootloader Firmware Image to have. */
#define ETX_OTA_APP_FW_SIZE         (FLASH_PAGE_SIZE_IN_BYTES * ETX_APP_FLASH_PAGES_SIZE)   /**< @brief Maximum size allowable for an Application Firmware Image to have. */
#define ETX_OTA_MAX_FW_SIZE         (ETX_OTA_APP_FW_SIZE)                           		/**< @brief Maximum size allowable for a Firmware Image to have. */

/**@brief	ETX OTA process states.
 *
 * @details	The ETX OTA process states are used in the functions of the @ref firmware_update module to either indicate
 *          or identify in what part of the whole ETX OTA process is our MCU/MPU currently at.
 * @details	The ETX OTA process consists of several sub-processes or states that must be given place in the following
 *          orderly fashion:
 *			<ol>
 *				<li>Idle State</li>
 *				<li>Start State</li>
 *				<li>Header State</li>
 *				<li>Data State</li>
 *				<li>End State</li>
 *			</ol>
 *
 * @note	If the ETX OTA process gives place in a different order as shown above (e.g., Idle State --> Start State -->
 *          Data State ..., where instead, the order of the states expected were Idle State --> Start State --> Header
 *          State ...), then the ETX OTA process will be terminated with the corresponding @ref ETX_OTA_Status Exception
 *          code.
 */
typedef enum
{
	ETX_OTA_STATE_IDLE    = 0U,   	//!< ETX OTA Idle State. @details This state stands for when our MCU/MPU is not in a ETX OTA Firmware Update.
	ETX_OTA_STATE_START   = 1U,   	//!< ETX OTA Start State. @details This state gives place when our MCU/MPU receives a Command Type Packet from the host right after leaving the ETX OTA Idle State. Our MCU/MPU will expect that Packet to contain the Start Command so that our MCU/MPU starts an ETX OTA Firmware Update.
	ETX_OTA_STATE_HEADER  = 2U,   	//!< ETX OTA Header State. @details This state starts right after the Command Type Packet of the ETX OTA Start State is processed. In the ETX OTA Header State, our MCU/MPU will expect to receive a Header Type Packet in which our MCU/MPU will obtain the size in bytes of the Firmware Image to be received, its recorded 32-bits CRC and the sub-type of the ETX OTA Data Type Packets to be received (i.e., @ref ETX_OTA_Payload_t ).
	ETX_OTA_STATE_DATA    = 3U,   	//!< ETX OTA Data State. @details This state starts right after the Header Type Packet of the ETX OTA Header State is processed. In the ETX OTA Data State, our MCU/MPU will expect to receive one or more Data Type Packets from which our MCU/MPU will receive a Firmware Image from the host. It is also in this State where our MCU/MPU will apply that Firmware Image to itself.
	ETX_OTA_STATE_END     = 4U		//!< ETX OTA End State. @details This state starts right after the Data Type Packet(s) of the ETX OTA Data State is/are processed. In the ETX OTA End State, our MCU/MPU will expect to receive a Command Type Packet containing the End Command so that our MCU/MPU confirms the conclusion of the ETX OTA Firmware Update.
} ETX_OTA_State;

/**@brief	Packet Type definitions available in the ETX OTA Firmware Update process.
 */
typedef enum
{
	ETX_OTA_PACKET_TYPE_CMD       = 0U,   	//!< ETX OTA Command Type Packet. @details This Packet Type is expected to be send by the host to our MCU/MPU to request a certain ETX OTA Command to our MCU/MPU (see @ref ETX_OTA_Command ).
	ETX_OTA_PACKET_TYPE_DATA      = 1U,   	//!< ETX OTA Data Type Packet. @details This Packet Type will contain either the full or a part/chunk of a Firmware Image being send from the host to our MCU/MPU.
	ETX_OTA_PACKET_TYPE_HEADER    = 2U,   	//!< ETX OTA Header Type Packet. @details This Packet Type will provide the size in bytes of the Firmware Image that our MCU/MPU will receive, its recorded 32-bits CRC and the sub-type of the ETX OTA Data Type Packets to be received (i.e., @ref ETX_OTA_Payload_t ).
	ETX_OTA_PACKET_TYPE_RESPONSE  = 3U		//!< ETX OTA Response Type Packet. @details This Packet Type contains a response from our MCU/MPU that is given to the host to indicate to it whether or not our MCU/MPU was able to successfully process the latest request or Packet from the host.
} ETX_OTA_Packet_t;

/**@brief	ETX OTA Commands definitions.
 *
 * @details	These are the different Commands that the host can request to our MCU/MPU whenever the host sends an ETX OTA
 *          Command Type Packet to that external device.
 */
typedef enum
{
	ETX_OTA_CMD_START = 0U,		    //!< ETX OTA Firmware Update Start Command. @details This command indicates to the MCU/MPU that the host is connected to (via @ref COMPORT_NUMBER ) to start an ETX OTA Process.
	ETX_OTA_CMD_END   = 1U,    		//!< ETX OTA Firmware Update End command. @details This command indicates to the MCU/MPU that the host is connected to (via @ref COMPORT_NUMBER ) to end the current ETX OTA Process.
	ETX_OTA_CMD_ABORT = 2U    		//!< ETX OTA Abort Command. @details This command is used by the host to request to our MCU/MPU to abort whatever ETX OTA Process that our MCU/MPU is working on. @note Unlike the other Commands, this one can be legally requested to our MCU/MPU at any time and as many times as the host wants to.
} ETX_OTA_Command;

/**@brief	Payload Type definitions available in the ETX OTA Firmware Update process.
 *
 * @details	Whenever the host sends to our MCU/MPU a @ref ETX_OTA_PACKET_TYPE_DATA Packet Type (i.e., a Data Type
 * 			Packet), there are several possible sub-types for this and any other Data Type Packet that indicate
 * 			the type of data that our MCU/MPU should expect to receive from the whole Data Type Packets that it
 * 			will receive. These sub-types are given by @ref ETX_OTA_Payload_t .
 */
typedef enum
{
    ETX_OTA_Application_Firmware_Image  = 0U,   	//!< ETX OTA Application Firmware Image Data Packet Type.
    ETX_OTA_Bootloader_Firmware_Image   = 1U   		//!< ETX OTA Bootloader Firmware Image Data Packet Type.
} ETX_OTA_Payload_t;

/**@brief	Response Status definitions available in the ETX OTA Firmware Update process.
 *
 * @details	Whenever the host sends to our MCU/MPU a Packet, depending on whether our MCU/MPU was able to successfully
 * 			process the data of that Packet of not, our MCU/MPU will respond back to the host with a Response Type
 * 			Packet containing the value of a Response Status correspondingly.
 */
typedef enum
{
	ETX_OTA_ACK  = 0U,   		//!< Acknowledge (ACK) data byte used in an ETX OTA Response Type Packet to indicate to the host that the latest ETX OTA Packet has been processed successfully by our MCU/MPU.
	ETX_OTA_NACK   = 1U   		//!< Not Acknowledge (NACK) data byte used in an ETX OTA Response Type Packet to indicate to the host that the latest ETX OTA Packet has not been processed successfully by our MCU/MPU.
} ETX_OTA_Response_Status;

static uint8_t Rx_Buffer[ETX_OTA_PACKET_MAX_SIZE];			/**< @brief Global buffer that will be used by our MCU/MPU to hold the whole data of a received ETX OTA Packet from the host. */
static ETX_OTA_State etx_ota_state = ETX_OTA_STATE_IDLE;	/**< @brief Global variable used to hold the ETX OTA Process State at which our MCU/MPU is currently at. */
static uint32_t etx_ota_fw_received_size=0;					/**< @brief Global variable used to indicate the Total Size in bytes that our MCU/MPU has received from a certain Firmware Update Image. */
static firmware_update_config_data_t *p_fw_config;			/**< @brief Global pointer to the latest data of the @ref firmware_update_config sub-module. */
extern UART_HandleTypeDef huart2;							/**< @brief MCU/MPU's Hardware UART2 Handle. */

/**@brief	ETX OTA Command Type Packet's parameters structure.
 *
 * @details	This structure contains all the fields of an ETX OTA Packet of @ref ETX_OTA_PACKET_TYPE_CMD Type.
 * @details	The following illustrates the ETX OTA format of this Type of Packets:
 *
 * <table style="border-collapse:collapse;border-spacing:0;background-color:#ffffff;text-align:center;vertical-align:top;">
 * <thead>
 *   <tr>
 *     <th style="border-color:black;border-style:solid;border-width:1px">SOF</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Packet<br>Type</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Len</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Command</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">CRC</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">EOF</th>
 *   </tr>
 * </thead>
 * <tbody>
 *   <tr>
 *     <td style="border-color:#ffffff">1B</td>
 *     <td style="border-color:#ffffff">1B</td>
 *     <td style="border-color:#ffffff">2B</td>
 *     <td style="border-color:#ffffff">1B</td>
 *     <td style="border-color:#ffffff">4B</td>
 *     <td style="border-color:#ffffff">1B</td>
 *   </tr>
 * </tbody>
 * </table>
 *
 * where B = byte(s).
 */
typedef struct __attribute__ ((__packed__)) {
	uint8_t   sof;				//!< Start of Frame (SOF). @details All ETX OTA Packets must start with a SOF byte, whose value is @ref ETX_OTA_SOF .
	uint8_t   packet_type;		//!< Packet Type. @details The value of this parameter has to be @ref ETX_OTA_PACKET_TYPE_CMD because this is meant to be used for Command Type Packets.
	uint16_t  data_len;			//!< Length of the Command value in bytes. @note The length of any @ref ETX_OTA_Command value is 1 byte.
	uint8_t   cmd;				//!< Command value. @note See @ref ETX_OTA_Command for more details.
	uint32_t  crc;				//!< 32-bit CRC of the \c cmd parameter of this structure.
	uint8_t   eof;				//!< Start of Frame (EOF). @details All ETX OTA Packets must end with an EOF byte, whose value is given by @ref ETX_OTA_EOF .
} ETX_OTA_Command_Packet_t;

/**@brief	Header Data parameters structure.
 *
 * @details	This structure contains all the fields of the Header data that is expected to be received by our MCU/MPU
 * 			in a @ref ETX_OTA_PACKET_TYPE_HEADER Type Packet (i.e., in a Header Type Packet).
 */
typedef struct __attribute__ ((__packed__)) {
	uint32_t 	package_size;		//!< Total length/size in bytes of the data expected to be received by our MCU/MPU from the host via all the @ref ETX_OTA_PACKET_TYPE_DATA Type Packet(s) (i.e., in a Data Type Packet or Packets) to be received.
	uint32_t 	package_crc;		//!< 32-bit CRC of the whole data to be obtained from all the @ref ETX_OTA_PACKET_TYPE_DATA Type Packets (i.e., in a Data Type Packets).
	uint32_t 	reserved1;			//!< 32-bits reserved for future changes on this firmware.
	uint16_t 	reserved2;			//!< 16-bits reserved for future changes on this firmware.
	uint8_t 	reserved3;			//!< 8-bits reserved for future changes on this firmware.
	uint8_t		payload_type;	    //!< Expected payload type to be received from the @ref ETX_OTA_PACKET_TYPE_DATA Type Packets (i.e., in a Data Type Packets). @note see @ref ETX_OTA_Payload_t to learn about the available Payload Types.
} header_data_t;

/**@brief	ETX OTA Header Type Packet's parameters structure.
 *
 * @details	This structure contains all the fields of an ETX OTA Packet of @ref ETX_OTA_STATE_HEADER Type.
 * @details	The following illustrates the ETX OTA format of this Type of Packets:
 *
 * <table style="border-collapse:collapse;border-spacing:0;background-color:#ffffff;text-align:center;vertical-align:top;">
 * <thead>
 *   <tr>
 *     <th style="border-color:black;border-style:solid;border-width:1px">SOF</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Packet<br>Type</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Len</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Header<br>Data</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">CRC</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">EOF</th>
 *   </tr>
 * </thead>
 * <tbody>
 *   <tr>
 *     <td style="border-color:#ffffff">1B</td>
 *     <td style="border-color:#ffffff">1B</td>
 *     <td style="border-color:#ffffff">2B</td>
 *     <td style="border-color:#ffffff">16B</td>
 *     <td style="border-color:#ffffff">4B</td>
 *     <td style="border-color:#ffffff">1B</td>
 *   </tr>
 * </tbody>
 * </table>
 *
 * where B = byte(s).
 */
typedef struct __attribute__ ((__packed__)) {
	uint8_t     	sof;			//!< Start of Frame (SOF). @details All ETX OTA Packets must start with a SOF byte, whose value is @ref ETX_OTA_SOF .
	uint8_t     	packet_type;	//!< Packet Type. @details The value of this parameter has to be @ref ETX_OTA_PACKET_TYPE_HEADER because this is meant to be used for Header Type Packets.
	uint16_t    	data_len;		//!< Length of the \c meta_data parameter in bytes. @note The length of the \c meta_data parameter value must be 16 bytes.
	header_data_t	meta_data;		//!< Header data. @note See @ref header_data_t for more details.
	uint32_t    	crc;			//!< 32-bit CRC of the \c meta_data parameter of this structure.
	uint8_t     	eof;			//!< Start of Frame (EOF). @details All ETX OTA Packets must end with an EOF byte, whose value is given by @ref ETX_OTA_EOF .
} ETX_OTA_Header_Packet_t;

/**@brief	ETX OTA Data Type Packet's parameters structure.
 *
 * @details	This structure contains all the fields of an ETX OTA Packet of @ref ETX_OTA_STATE_DATA Type.
 * @details	The following illustrates the ETX OTA format of this Type of Packets:
 *
 * <table style="border-collapse:collapse;border-spacing:0;background-color:#ffffff;text-align:center;vertical-align:top;">
 * <thead>
 *   <tr>
 *     <th style="border-color:black;border-style:solid;border-width:1px">SOF</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Packet<br>Type</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Len</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Payload Data</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">CRC</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">EOF</th>
 *   </tr>
 * </thead>
 * <tbody>
 *   <tr>
 *     <td style="border-color:#ffffff">1B</td>
 *     <td style="border-color:#ffffff">1B</td>
 *     <td style="border-color:#ffffff">2B</td>
 *     <td style="border-color:#ffffff">@ref data_len B</td>
 *     <td style="border-color:#ffffff">4B</td>
 *     <td style="border-color:#ffffff">1B</td>
 *   </tr>
 * </tbody>
 * </table>
 *
 * where B = byte(s).
 *
 * @note	The CRC is not within the fields of this structure because this structure was formulated in such a way that
 *          it could represent any possible ETX OTA Data Type Packet in consideration that they may vary in size and
 *          because it is desired to make it compatible with the General Data Format explained in @ref firmware_update .
 *          Therefore, the strategy that has been applied in the @ref firmware_update module is to append all the data
 *          contained in the @ref data field from all the received ETX OTA Data Type Packets within a single ETX OTA
 *          Process to then calculate the CRC of that whole data and validate it with the one received for that whole
 *          data via the @ref header_data_t::package_crc field.
 * @note	Another consequence of what was just explained is that the EOF is also not within the fields of this
 *          structure but it is always validated at the end of each ETX OTA Data Type Packet received.
 */
typedef struct __attribute__ ((__packed__)) {
	uint8_t     sof;			//!< Start of Frame (SOF). @details All ETX OTA Packets must start with a SOF byte, whose value is @ref ETX_OTA_SOF .
	uint8_t     packet_type;	//!< Packet Type. @details The value of this parameter must be @ref ETX_OTA_PACKET_TYPE_DATA because this is meant to be used for Data Type Packets.
	uint16_t    data_len;		//!< Length of the actual "Data" field contained inside the \c data parameter in bytes (i.e., This does not take into account the "CRC32" and "EOF" fields length). @note This length is defined by the host, but its maximum value can be @ref ETX_OTA_DATA_MAX_SIZE (i.e., 1024 bytes).
	uint8_t     *data;			//!< Paylaod data, 32-bit CRC and EOF. @details the Data bytes may have a length of 1 byte up to a maximum of @ref ETX_OTA_DATA_MAX_SIZE (i.e., 1024 bytes). Next to them, the 32-bit CRC will be appended and then the EOF byte will be appended subsequently. @details The appended 32-bit CRC is calculated with respect to the Data bytes received in for this single/particular ETX OTA Data Type Packet (i.e., Not for the whole data previously explained).
} ETX_OTA_Data_Packet_t;

/**@brief	ETX OTA Response Type Packet's parameters structure.
 *
 * @details	This structure contains all the fields of an ETX OTA Packet of @ref ETX_OTA_PACKET_TYPE_RESPONSE Type.
 * @details	The following illustrates the ETX OTA format of this Type of Packets:
 *
 * <table style="border-collapse:collapse;border-spacing:0;background-color:#ffffff;text-align:center;vertical-align:top;">
 * <thead>
 *   <tr>
 *     <th style="border-color:black;border-style:solid;border-width:1px">SOF</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Packet<br>Type</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Len</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">Status</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">CRC</th>
 *     <th style="border-color:black;border-style:solid;border-width:1px">EOF</th>
 *   </tr>
 * </thead>
 * <tbody>
 *   <tr>
 *     <td style="border-color:#ffffff">1B</td>
 *     <td style="border-color:#ffffff">1B</td>
 *     <td style="border-color:#ffffff">2B</td>
 *     <td style="border-color:#ffffff">1B</td>
 *     <td style="border-color:#ffffff">4B</td>
 *     <td style="border-color:#ffffff">1B</td>
 *   </tr>
 * </tbody>
 * </table>
 *
 * where B = byte(s).
 */
typedef struct __attribute__ ((__packed__)) {
	uint8_t   sof;				//!< Start of Frame (SOF). @details All ETX OTA Packets must start with a SOF byte, whose value is @ref ETX_OTA_SOF .
	uint8_t   packet_type;		//!< Packet Type. @details The value of this parameter must be @ref ETX_OTA_PACKET_TYPE_RESPONSE because this is meant to be used for Response Type Packets.
	uint16_t  data_len;			//!< Length of the \c status parameter in bytes. @note The length of any valid value for the \c status parameter is 1 byte.
	uint8_t   status;			//!< Response Status value. @note See @ref ETX_OTA_Response_Status for more details.
	uint32_t  crc;				//!< 32-bit CRC of the \c status parameter of this structure.
	uint8_t   eof;				//!< Start of Frame (EOF). @details All ETX OTA Packets must end with an EOF byte, whose value is given by @ref ETX_OTA_EOF .
} ETX_OTA_Response_Packet_t;

/**
 * @brief   Gets one Packet from the ETX OTA process, if any is given.
 *
 * @details The General Data Format that is expected to be received is as explained in the Doxygen documentation of the
 *          @ref ETX_OTA_Data_Packet_t parameters structure, which starts with a SOF byte that is followed up with the
 *          Packet Type field, the Data Length field, the Data field, the CRC32 field and ends up with an EOF byte.
 *
 * @note	The HAL Timeout for each UART2 reception of data is given by @ref CUSTOM_HAL_TIMEOUT .
 *
 * @param[in, out] buf 		Buffer pointer into which the bytes of the received packet from the host, will be stored.
 * @param max_len 			Maximum length of bytes that are expected to be received from the "Data"field of the next ETX OTA packet.
 * @param[in, out] index	Pointer to the current index against which the bytes of the current ETX OTA Packet have been fetched.
 *
 * @retval					ETX_OTA_EC_OK
 * @retval					ETX_OTA_EC_NR
 * @retval					ETX_OTA_EC_ERR
 *
 * @author 	EmbeTronicX (<a href=https://github.com/Embetronicx/STM32-Bootloader/tree/ETX_Bootloader_3.0>STM32-Bootloader GitHub Repository under ETX_Bootloader_3.0 branch</a>)
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date October 01, 2023.
 */
static ETX_OTA_Status etx_ota_receive_packet(uint8_t *buf, uint16_t max_len, uint16_t *index);

/**@brief	Processes and validates the latest received ETX OTA Packet.
 *
 * @details	This function will read the current value of the @ref etx_ota_state global variable to determine at which
 *          ETX OTA State the process is currently at in order to process the latest ETX OTA Packet correspondingly. In
 *          addition, this function will modify the value of that variable to the next ETX OTA State whenever it
 *          corresponds.
 *
 * @details In addition, this function will do the following depending on the current ETX OTA State:
 *          <ul>
 *              <li><b>ETX OTA Idle State:</b> Do nothing.</li>
 *              <li><b>ETX OTA Start State:</b> Validate the latest ETX OTA Packet to be that of an ETX OTA Command Type
 *                                              Packet containing the Start Command in it and, if successful, then
 *                                              change current ETX OTA State to ETX OTA Header State.</li>
 *              <li><b>ETX OTA Header State:</b> Validate the latest ETX OTA Packet to be that of an ETX OTA Header
 *                                               Type Packet and, if successful, then validate the incoming Firmware
 *                                               Image to be that of a Bootlaoder Firmware Image. If successful, then
 *                                               write that data into the @ref firmware_update_config sub-module. If
 *                                               everything goes well up to this point, then change the current ETX OTA
 *                                               State to ETX OTA Data State.</li>
 *              <li><b>ETX OTA Data State:</b> Validate the latest ETX OTA Packet to be that of an ETX OTA Data Type
 *                                             Packet and, if successful, then write the contents of the "Data" field
 *                                             of that Packet into the corresponding Flash Memory location address of
 *                                             our MCU/MPU's Bootloader Firmware. Repeat this explained process for all
 *                                             the ETX OTA Data Type Packets to be received by our MCU/MPU. After the
 *                                             last ETX OTA Data Packet has been successfully, change the current ETX
 *                                             OTA State to ETX OTA End State.</li>
 *              <li><b>ETX OTA End State:</b> Validate the latest ETX OTA Packet to be that of an ETX OTA Command Type
 *                                            Packet containing the End Command in it and, if successful, then validate
 *                                            the CRC of the Bootloader Firmware Image that has just been installed. If
 *                                            this is successful, then change the current ETX OTA State to ETX OTA Idle
 *                                            State.</li>
 *          </ul>
 *
 * @note	Each time the implementer/programmer calls this function, the @ref etx_ota_receive_packet function must to
 * 			be called once before this @ref etx_ota_process_data function.
 *
 * @param[in] buf	Buffer pointer to the data of the latest ETX OTA Packet.
 *
 * @retval						ETX_OTA_EC_OK
 * @retval						ETX_OTA_EC_STOP
 * @retval						ETX_OTA_EC_NR
 * @retval						ETX_OTA_EC_NA
 * @retval						ETX_OTA_EC_ERR
 *
 * @author 	EmbeTronicX (<a href=https://github.com/Embetronicx/STM32-Bootloader/tree/ETX_Bootloader_3.0>STM32-Bootloader GitHub Repository under ETX_Bootloader_3.0 branch</a>)
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date October 09, 2023.
 */
static ETX_OTA_Status etx_ota_process_data(uint8_t *buf);

/**@brief	Sends an ETX OTA Response Type Packet with a desired Response Status (i.e., ACK or NACK) to the host via
 *          UART2.
 *
 * @param response_status	\c ETX_OTA_ACK or \c ETX_OTA_NACK .
 *
 * @retval 					ETX_OTA_EC_OK
 * @retval 					ETX_OTA_EC_NR
 * @retval 					ETX_OTA_EC_ERR
 *
 * @author 	EmbeTronicX (<a href=https://github.com/Embetronicx/STM32-Bootloader/tree/ETX_Bootloader_3.0>STM32-Bootloader GitHub Repository under ETX_Bootloader_3.0 branch</a>)
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date October 02, 2023.
 */
static ETX_OTA_Status etx_ota_send_resp(ETX_OTA_Response_Status response_status);

/**@brief	Write the contents of the "Data" field contained in a given ETX OTA Data Type Packet into the Flash Memory
 *          of our MCU/MPU's Bootloader Firmware.
 *
 * @param[in] data			Pointer to the "Data" field of a given ETX OTA Data Type Packet, whose data wants to be
 *                          written into the Flash Memory of our MCU/MPU's Bootloader Firmware.
 * @param data_len			Length in bytes of the "Data" field of the ETX Data Type Packet that is being pointed
 *                          towards to, via the \p data param.
 * @param is_first_block	Flag used to indicate whether the current ETX OTA Data Type Packet contains the first Flash
 *                          Memory block with a \c true or otherwise with a \c false .
 *
 * @retval 					ETX_OTA_EC_OK
 * @retval 					ETX_OTA_EC_NR
 * @retval 					ETX_OTA_EC_ERR
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @author 	EmbeTronicX (<a href=https://github.com/Embetronicx/STM32-Bootloader/tree/ETX_Bootloader_3.0>STM32-Bootloader GitHub Repository under ETX_Bootloader_3.0 branch</a>)
 * @date October 11, 2023.
 */
static ETX_OTA_Status write_data_to_flash_bl(uint8_t *data, uint16_t data_len, bool is_full_image);

/**@brief	Gets the corresponding @ref ETX_OTA_Status value depending on the given @ref HAL_StatusTypeDef value.
 *
 * @param HAL_status	HAL Status value (see @ref HAL_StatusTypeDef ) that wants to be converted into its equivalent
 * 						of a @ref ETX_OTA_Status value.
 *
 * @retval				ETX_OTA_EC_NR if \p HAL_status param equals \c HAL_BUSY or \c CUSTOM_HAL_TIMEOUT .
 * @retval				ETX_OTA_EC_ERR if \p HAL_status param equals \c HAL_ERROR .
 * @retval				HAL_status param otherwise.
 *
 * @note	For more details on the returned values listed, see @ref ETX_OTA_Status and @ref HAL_StatusTypeDef .
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date September 26, 2023.
 */
static ETX_OTA_Status HAL_ret_handler(HAL_StatusTypeDef HAL_status);

ETX_OTA_Status app_firmware_image_download_and_install(firmware_update_config_data_t *p_data)
{
	/** <b>Local variable ret:</b> Used to hold the exception code value returned by a @ref FirmUpdConf_Status or a @ref ETX_OTA_Status function type. */
	ETX_OTA_Status ret;
	/** <b>Local variable len:</b> Current index against which the bytes of the current ETX OTA Packet have been fetched. */
	uint16_t len;

	/* Persist the pointer to the latest data of the Firmware Update Configurations sub-module. */
	p_fw_config = p_data;

	/* Reset the global variables related to: 1) The Header data of a received Firmware Image and 2) The ETX OTA Process State. */
	etx_ota_fw_received_size = 0U;
	etx_ota_state            = ETX_OTA_STATE_START;

	/* Attempt to receive a Firmware Image from the host and, if applicable, install it. */
	printf("Waiting for a Bootloader Firmware Image from the host...\r\n");
	do
	{
		len = 0; // Reset the index of the new ETX OTA Packet to be fetched.
		memset(Rx_Buffer, 0, ETX_OTA_PACKET_MAX_SIZE); // Reset the Global buffer \c Rx_Buffer .
		printf("Waiting for an ETX OTA Packet from the host...\r\n");
		ret = etx_ota_receive_packet(Rx_Buffer, ETX_OTA_PACKET_MAX_SIZE, &len);
		switch (ret)
		{
		  case ETX_OTA_EC_OK:
			/* Since the ETX OTA Packet was received successfully, proceed into processing that data correspondingly. */
			ret = etx_ota_process_data(Rx_Buffer);
			switch (ret)
			{
			  case ETX_OTA_EC_OK:
				  printf("DONE: The current ETX OTA Packet was processed successfully. Therefore, sending ACK...\r\n");
				  etx_ota_send_resp(ETX_OTA_ACK);
				  break;
			  case ETX_OTA_EC_STOP:
				  printf("DONE: The ETX OTA process has been requested to be stopped by the host. Therefore, sending ACK...\r\n");
				  etx_ota_send_resp(ETX_OTA_ACK);
				  return ETX_OTA_EC_STOP;
			  case ETX_OTA_EC_NR:
				  printf("ERROR: Our MCU/MPU's HAL responded with a No Response ETX OTA Exception code during a part of the process where this was not expected.\r\n");
				  return ETX_OTA_EC_ERR;
			  case ETX_OTA_EC_NA:
				  printf("WARNING: The host has requested to start an Application Firmware Update. Therefore, sending NACK...\r\n");
				  etx_ota_send_resp(ETX_OTA_NACK);
				  return ETX_OTA_EC_NA;
			  case ETX_OTA_EC_ERR:
				  printf("ERROR: An Error Exception Code has been generated during the ETX OTA process. Therefore, sending NACK...\r\n");
				  etx_ota_send_resp(ETX_OTA_NACK);
				  return ETX_OTA_EC_ERR;
			  default:
				  /* This should not happen. */
				  printf("ERROR: The ETX OTA Exception code %d that has been generated is unrecognized by our MCU/MPU. Therefore, sending NACK...\r\n", ret);
				  return ret;
			}
			break;

		  case ETX_OTA_EC_NR:
			  printf("DONE: No response from host.\r\n");
			  return ETX_OTA_EC_NR;

		  case ETX_OTA_EC_ERR:
			  printf("ERROR: An Error Exception Code has been generated during the ETX OTA process. Therefore, sending NACK...\r\n");
			  etx_ota_send_resp(ETX_OTA_NACK);
			  return ETX_OTA_EC_ERR;

		  default:
			  /* The "default" case should not be called. */
			  printf("ERROR: The ETX OTA Exception code %d that has been generated either should not have been generated or is unrecognized by our MCU/MPU. Therefore, sending NACK...\r\n", ret);
			  etx_ota_send_resp(ETX_OTA_NACK);
			  return ret;
		}
	}
	while (etx_ota_state != ETX_OTA_STATE_IDLE);

	return ETX_OTA_EC_OK;
}

static ETX_OTA_Status etx_ota_receive_packet(uint8_t *buf, uint16_t max_len, uint16_t *index)
{
	/** <b>Local variable ret:</b> Return value of either a HAL function or a @ref ETX_OTA_Status function type. */
	int16_t  ret;
	/** <b>Local variable data_len:</b> "Data Length" field value of the ETX OTA Packet that is currently being received via UART. @details	The value of this field should stand for the length in bytes of the current ETX OTA Packet's "Data" field. */
	uint16_t data_len;
	/** <b>Local variable cal_data_crc:</b> Our MCU/MPU's calculated CRC of the ETX OTA Packet received via UART. */
	uint32_t cal_data_crc;
	/** <b>Local variable rec_data_crc:</b> Value holder of the "Recorded CRC" contained in the ETX OTA Packet received via UART. */
	uint32_t rec_data_crc;

	/* Wait to receive the first byte of data from the host and validate it to be the SOF byte of an ETX OTA Packet. */
	printf("Waiting to receive an ETX OTA Packet from the host...\r\n");
	ret = HAL_UART_Receive(&huart2, &buf[(*index)], ETX_OTA_SOF_SIZE, CUSTOM_HAL_TIMEOUT);
	ret = HAL_ret_handler(ret);
	if (ret != HAL_OK)
	{
		*index = 0U; // Clear the index if error.
		return ret;
	}
	if (buf[(*index)++] != ETX_OTA_SOF)
	{
		printf("ERROR: Expected to receive the SOF field value from the current ETX OTA Packet.\r\n");
		*index = 0U; // Clear the index if error.
		return ETX_OTA_EC_ERR;
	}

	/* Wait to receive the next 1-byte of data from the host and validate it to be a "Packet Type" field value of an ETX OTA Packet. */
	ret = HAL_UART_Receive(&huart2, &buf[(*index)], ETX_OTA_PACKET_TYPE_SIZE, CUSTOM_HAL_TIMEOUT);
	ret = HAL_ret_handler(ret);
	if (ret != HAL_OK)
	{
		*index = 0U; // Clear the index if error.
		return ret;
	}
	switch (buf[(*index)++])
	{
		case ETX_OTA_PACKET_TYPE_CMD:
		case ETX_OTA_PACKET_TYPE_DATA:
		case ETX_OTA_PACKET_TYPE_HEADER:
		case ETX_OTA_PACKET_TYPE_RESPONSE:
			break;
		default:
			printf("ERROR: The data received from the Packet Type field of the currently received ETX OTA Packet contains a value not recognized by our MCU/MPU.\r\n");
			*index = 0U; // Clear the index if error.
			return ETX_OTA_EC_ERR;
	}

	/* Wait to receive the next 2-bytes of data from the host, which our MCU/MPU will interpret as the "Data Length" field value of an ETX OTA Packet. */
	ret = HAL_UART_Receive(&huart2, &buf[*index], ETX_OTA_DATA_LENGTH_SIZE, CUSTOM_HAL_TIMEOUT);
	ret = HAL_ret_handler(ret);
	if (ret != HAL_OK)
	{
		*index = 0U; // Clear the index if error.
		return ret;
	}
	data_len = *(uint16_t *)&buf[*index];
	(*index) += ETX_OTA_DATA_LENGTH_SIZE;

	/* Wait to receive the next \c data_len bytes of data from the host, which our MCU/MPU will interpret as the "Data" field value of an ETX OTA Packet. */
	for (uint16_t i=0; i<data_len; i++)
	{
		ret = HAL_UART_Receive(&huart2, &buf[(*index)++], 1, CUSTOM_HAL_TIMEOUT);
		ret = HAL_ret_handler(ret);
		if (ret != HAL_OK)
		{
			*index = 0U; // Clear the index if error.
			return ret;
		}
	}

	/* Wait to receive the next 4-bytes of data from the host, which our MCU/MPU will interpret as the "CRC32" field value of an ETX OTA Packet. */
	ret = HAL_UART_Receive(&huart2, &buf[*index], ETX_OTA_CRC32_SIZE, CUSTOM_HAL_TIMEOUT);
	ret = HAL_ret_handler(ret);
	if (ret != HAL_OK)
	{
		*index = 0U; // Clear the index if error.
		return ret;
	}
	rec_data_crc = *(uint32_t *)&buf[*index];
	(*index) += ETX_OTA_CRC32_SIZE;

	/* Wait to receive the next 1-byte of data from the host and validate it to be a "EOF" field value of an ETX OTA Packet. */
	ret = HAL_UART_Receive(&huart2, &buf[*index], ETX_OTA_EOF_SIZE, CUSTOM_HAL_TIMEOUT);
	ret = HAL_ret_handler(ret);
	if (ret != HAL_OK)
	{
		*index = 0U; // Clear the index if error.
		return ret;
	}
	if (buf[(*index)++] != ETX_OTA_EOF)
	{
		printf("ERROR: Expected to receive the EOF field value from the current ETX OTA Packet.\r\n");
		*index = 0U; // Clear the index if error.
		return ETX_OTA_EC_ERR;
	}

	/* Calculate the 32-bit CRC only with respect to the contents of the "Data" field from the current ETX OTA Packet that has just been received. */
	cal_data_crc = CRC32((uint8_t *) &buf[ETX_OTA_DATA_FIELD_INDEX], data_len);

	/* Validate that the Calculated CRC matches the Recorded CRC. */
	if (cal_data_crc != rec_data_crc)
	{
		printf("ERROR: CRC mismatch with current ETX OTA Packet [Calculated CRC = 0x%08lX] [Recorded CRC = 0x%08lX]\r\n",
												   cal_data_crc, rec_data_crc);
		*index = 0U; // Clear the index if error.
		return ETX_OTA_EC_ERR;
	}

	if (max_len < *index)
	{
		printf("ERROR: Received more data than expected (Expected = %d, Received = %d)\r\n", max_len, *index);
		*index = 0U;  // Clear the index if error.
		return ETX_OTA_EC_ERR;
	}

	printf("ETX OTA Packet has been successfully received.\r\n");
	return ETX_OTA_EC_OK;
}

static ETX_OTA_Status etx_ota_process_data(uint8_t *buf)
{
	/** <b>Local pointer cmd:</b> Points to the data of the latest ETX OTA Packet but in @ref ETX_OTA_Command_Packet_t type. */
	ETX_OTA_Command_Packet_t *cmd = (ETX_OTA_Command_Packet_t *) buf;

	/* Check if we received the ETX OTA Abort Command and, if true, stop the ETX OTA process. */
	printf("Processing data of the latest ETX OTA Packet...\r\n");
	if (cmd->packet_type == ETX_OTA_PACKET_TYPE_CMD)
	{
		if (cmd->cmd == ETX_OTA_CMD_ABORT)
		{
			printf("DONE: ETX OTA Abort command received. Stopping the process...\r\n");
			return ETX_OTA_EC_STOP;
		}
	}

	switch (etx_ota_state)
	{
		case ETX_OTA_STATE_IDLE:
			printf("DONE: ETX OTA Process is in Idle State.\r\n");
			return ETX_OTA_EC_OK;

		case ETX_OTA_STATE_START:
			if ((cmd->packet_type==ETX_OTA_PACKET_TYPE_CMD) && (cmd->cmd == ETX_OTA_CMD_START))
			{
				printf("DONE: Received ETX OTA Start Command.\r\n");
				etx_ota_state = ETX_OTA_STATE_HEADER;
				return ETX_OTA_EC_OK;
			}
			printf("ERROR: Expected ETX OTA Command Type Packet containing an ETX OTA Start Command, but something else was received instead.\r\n");
			return ETX_OTA_EC_ERR;

		case ETX_OTA_STATE_HEADER:
			/** <b>Local pointer header:</b> Points to the data of the latest ETX OTA Packet but in @ref ETX_OTA_Header_Packet_t type. */
			ETX_OTA_Header_Packet_t *header = (ETX_OTA_Header_Packet_t *) buf;

			if (header->packet_type == ETX_OTA_PACKET_TYPE_HEADER)
			{
				/** <b>Local variable header_ret:</b> Return value of a @ref FirmUpdConf_Status function function type. */
				int16_t  header_ret;

				/* We validate that the Firmware Image to be received is a Bootloader Firmware Image. */
				if (header->meta_data.payload_type != ETX_OTA_Bootloader_Firmware_Image)
				{
					printf("WARNING: The host wants to send an Application Firmware Image, but a Bootloader Firmware Image was being expected instead.\r\n");
					return ETX_OTA_EC_NA;
				}

				/* We validate the size of the Firmware Update Image to be received. */
				p_fw_config->BL_fw_size = header->meta_data.package_size;
				p_fw_config->BL_fw_rec_crc = header->meta_data.package_crc;
				if (header->meta_data.package_size > (ETX_OTA_BL_FW_SIZE))
				{
					printf("ERROR: The given Firmware Update Image (of size %ld) exceeds the maximum bytes designated to the Bootloader Firmware (which is %d).\r\n", header->meta_data.package_size, ETX_OTA_BL_FW_SIZE);
					return ETX_OTA_EC_NA;
				}

				/* We write the newly received Firmware Image Header data into a new data block of the Flash Memory designated to the @ref firmware_update_config sub-module. */
				header_ret = firmware_update_configurations_write(p_fw_config);
				if (header_ret != FIRM_UPDT_CONF_EC_OK)
				{
					printf("EXCEPTION CODE %d: The data was not written into the Firmware Update Configurations sub-module.\r\n", header_ret);
					return header_ret;
				}

				printf("Received ETX OTA Header with a Firmware Size of %ld bytes.\r\n", p_fw_config->BL_fw_size);
				etx_ota_state = ETX_OTA_STATE_DATA;
				return ETX_OTA_EC_OK;
			}
			printf("ERROR: Expected ETX OTA Header Type Packet, but something else was received instead.\r\n");
			return ETX_OTA_EC_ERR;

		case ETX_OTA_STATE_DATA:
			/** <b>Local pointer data:</b> Points to the data of the latest ETX OTA Packet but in @ref ETX_OTA_Data_Packet_t type. */
			ETX_OTA_Data_Packet_t *data = (ETX_OTA_Data_Packet_t *) buf;
			/** <b>Local variable data_ret:</b> Return value of a @ref ETX_OTA_Status function. */
			uint16_t data_ret;

			if (data->packet_type == ETX_OTA_PACKET_TYPE_DATA)
			{
				/* Validate that the Payload received from the current ETX OTA Packet is perfectly divisible by 4 bytes (i.e., one word). */
				if ((data->data_len)%4 != 0)
				{
					printf("ERROR: The size of the currently received Payload is not perfectly divisible by 4 bytes (i.e., one word).\r\n");
					return ETX_OTA_EC_ERR;
				}

				/* Write the ETX OTA Data Type Packet to the Flash Memory location of the Application Firmware. */
				data_ret = write_data_to_flash_bl(buf+ETX_OTA_DATA_FIELD_INDEX, data->data_len, etx_ota_fw_received_size==0);
				data_ret = HAL_ret_handler(data_ret);
				if (data_ret != HAL_OK)
				{
					return data_ret;
				}
				printf("[%ld/%ld] parts of the Bootloader Firmware Image are now installed into the Flash Memory...\r\n", etx_ota_fw_received_size/ETX_OTA_DATA_MAX_SIZE, p_fw_config->BL_fw_size/ETX_OTA_DATA_MAX_SIZE);
				if (etx_ota_fw_received_size >= p_fw_config->BL_fw_size)
				{
					/* received the full data. Therefore, move to the End State of the ETX OTA Process. */
					etx_ota_state = ETX_OTA_STATE_END;
				}
				return ETX_OTA_EC_OK;
			}
			printf("ERROR: Expected ETX OTA Data Type Packet, but something else was received instead.\r\n");
			return ETX_OTA_EC_ERR;

		case ETX_OTA_STATE_END:
			if ((cmd->packet_type==ETX_OTA_PACKET_TYPE_CMD) && (cmd->cmd==ETX_OTA_CMD_END))
			{
				/** <b>Local variable cal_crc:</b> Value holder for the calculated 32-bit CRC of the Bootloader Firmware Image that has just been installed into our MCU/MPU. */
				uint32_t cal_crc = CRC32((uint8_t *) ETX_BL_FLASH_ADDR, p_fw_config->BL_fw_size);

				/* Validate the 32-bit CRC of the whole Bootloader Firmware Image. */
				printf("Received ETX OTA END Command.\r\n");
				printf("Validating the received Bootloader Firmware Image...\r\n");
				if (cal_crc != p_fw_config->BL_fw_rec_crc)
				{
					printf("The 32-bit CRC of the received Bootloader Firmware Image mismatches with the calculated one: [Calculated CRC = 0x%08lX] [Recorded CRC = 0x%08lX]\r\n",
							cal_crc, p_fw_config->BL_fw_rec_crc);
					return ETX_OTA_EC_ERR;
				}
				printf("DONE: 32-bit CRC of the installed Bootloader Firmware Image has been successfully validated.\r\n");
				etx_ota_state = ETX_OTA_STATE_IDLE;
				return ETX_OTA_EC_OK;
			}
			printf("ERROR: Expected ETX OTA Command Type Packet containing an ETX OTA End Command, but something else was received instead.\r\n");
			return ETX_OTA_EC_ERR;

		default:
			/* Should not come here */
			printf("ERROR: The current ETX OTA State %d is unrecognized by our MCU/MPU.\r\n", etx_ota_state);
			return ETX_OTA_EC_ERR;
			break;
	}
}

//#pragma GCC diagnostic ignored "-Wstringop-overflow=" // This pragma definition will tell the compiler to ignore an expected Compilation Warning (due to a code functionality that it is strictly needed to work that way) that gives using the HAL_CRC_Calculate() function inside the etx_ota_send_resp() function,. which states the following: 'HAL_CRC_Calculate' accessing 4 bytes in a region of size 1.
static ETX_OTA_Status etx_ota_send_resp(ETX_OTA_Response_Status response_status)
{
	/** <b>Local variable ret:</b> Return value of a @ref ETX_OTA_Status function function type. */
	ETX_OTA_Status  ret;

	ETX_OTA_Response_Packet_t response =
	{
		.sof         	= ETX_OTA_SOF,
		.packet_type 	= ETX_OTA_PACKET_TYPE_RESPONSE,
		.data_len    	= 1U,
		.status      	= response_status,
		.crc			= 0U,
		.eof         	= ETX_OTA_EOF
	};
	response.crc = CRC32((uint8_t *) &response.status, 1);

	ret = HAL_UART_Transmit(&huart2, (uint8_t *)&response, sizeof(ETX_OTA_Response_Packet_t), CUSTOM_HAL_TIMEOUT);
	ret = HAL_ret_handler(ret);

	return ret;
}

static ETX_OTA_Status write_data_to_flash_bl(uint8_t *data, uint16_t data_len, bool is_first_block)
{
	/** <b>Local variable ret:</b> Return value of a @ref ETX_OTA_Status function function type. */
	uint8_t  ret;
	/**	<b>Local variable p_data:</b> Pointer to the data at which the \p data param points to but in \c uint32_t Type. */
	uint32_t *p_data = (uint32_t *) data;

	/* Unlock the Flash Memory of our MCU/MPU. */
	ret = HAL_FLASH_Unlock();
	ret = HAL_ret_handler(ret);
	if(ret != HAL_OK)
	{
		printf("ERROR: HAL Flash could not be unlocked; ETX OTA Exception code %d.\r\n", ret);
		return ret;
	}

	/* Erase Flash Memory dedicated to our MCU/MPU's Bootloader Firmware but only if the current ETX OTA Data Type Packet being processed is the first one. */
	if (is_first_block)
	{
		printf("Erasing the Flash Memory pages designated to the Bootloader Firmware of our MCU/MPU...\r\n");
		FLASH_EraseInitTypeDef EraseInitStruct;
		uint32_t page_error;

		EraseInitStruct.TypeErase    = FLASH_TYPEERASE_PAGES;
		EraseInitStruct.Banks        = FLASH_BANK_1;
		EraseInitStruct.PageAddress  = ETX_BL_FLASH_ADDR;
		EraseInitStruct.NbPages      = ETX_BL_FLASH_PAGES_SIZE;

		ret = HAL_FLASHEx_Erase(&EraseInitStruct, &page_error);
		ret = HAL_ret_handler(ret);
		if (ret != HAL_OK)
		{
			printf("ERROR: Flash Memory pages of the Bootloader Firmware of our MCU/MPU could not be erased; ETX OTA Exception code %d.\r\n", ret);
			return ret;
		}
		FLASH_WaitForLastOperation(CUSTOM_HAL_TIMEOUT); // Wait for the latest FLASH operation to complete.
		printf("DONE: Flash Memory pages designated to the Bootloader Firmware of our MCU/MPU have been successfully erased.\r\n");
	}

	/**	<b>Local variable word_data:</b> Array of 4 bytes (i.e., 1 word) initialized with the zeros (i.e., 0x00 in each byte) to then overwrite them if needed with the remaining bytes of the last word from the Bootloader Firmware Image. */
	uint8_t word_data[4] = {0x00, 0x00, 0x00, 0x00};
	/** <b>Local variable data_len_minus_one_word:</b> Holds the length in bytes of the "Data" field from the current ETX OTA Data Type Packet, except for the last four bytes. */
	uint16_t data_len_minus_one_word = data_len - 4;
	/** <b>Local variable remaining_data_len_of_last_word:</b> Should contain the remaining bytes of the last word from the Bootloader Firmware Image that are pending to be written into our MCU/MPU's Flash Memory. */
	uint8_t remaining_data_len_of_last_word;
	/**	<b>Local variable bytes_flashed:</b> Indicator of how many bytes of the current ETX OTA Packet's Payload have been written into the designated Flash Memory of the Bootloader Firmware. */
	uint16_t bytes_flashed=0;

	if (data_len > 4)
	{
		/* Write the entire Bootloader Firmware Image into our MCU/MPU's Flash Memory, except for the last word (i.e., the last four bytes). */
		for ( ; bytes_flashed<data_len_minus_one_word; bytes_flashed+=4)
		{
			ret = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
									(ETX_BL_FLASH_ADDR + etx_ota_fw_received_size),
									p_data[bytes_flashed/4]);
			ret = HAL_ret_handler(ret);
			if (ret == HAL_OK)
			{
				etx_ota_fw_received_size += 4;
			}
			else
			{
				printf("EXCEPTION CODE %d: The Bootloader Firmware Image data was not successfully written into our MCU/MPU.\r\n", ret);
				return ret;
			}
			FLASH_WaitForLastOperation(CUSTOM_HAL_TIMEOUT); // Wait for the latest FLASH operation to complete.
		}

		/* Populate the remaining bytes of the Bootloader Firmware Image that is currently being written into our MCU/MPU's Flash Memory via the \c word_data variable. */
		// NOTE: This way, if there are unused bytes in the \c word _data variable after filling it with the remaining bytes of the Bootloader Firmware Image, these will be left with the values that the Flash Memory recognizes as Reset Values.
		remaining_data_len_of_last_word = data_len - bytes_flashed;
		for (uint8_t i=0; i<remaining_data_len_of_last_word; i++)
		{
			word_data[i] = data[bytes_flashed + i];
		}
	}
	else
	{
		/* Populate the remaining bytes of the Bootloader Firmware Image that is currently being written into our MCU/MPU's Flash Memory via the \c word_data variable. */
		// NOTE: This way, if there are unused bytes in the \c word _data variable after filling it with the remaining bytes of the Bootloader Firmware Image, these will be left with the values that the Flash Memory recognizes as Reset Values.
		remaining_data_len_of_last_word = data_len;
		for (uint8_t i=0; i<remaining_data_len_of_last_word; i++)
		{
			word_data[i] = data[i];
		}
	}

	/* Write the remaining bytes of the Bootloader Firmware Image into the Flash Memory designated pages to our MCU/MPU's Bootloader Firmware. */
	ret = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
								(ETX_BL_FLASH_ADDR + etx_ota_fw_received_size),
								*((uint32_t *) word_data));
	ret = HAL_ret_handler(ret);
	if (ret == HAL_OK)
	{
		bytes_flashed += remaining_data_len_of_last_word;
		etx_ota_fw_received_size += remaining_data_len_of_last_word;
		FLASH_WaitForLastOperation(CUSTOM_HAL_TIMEOUT); // Wait for the latest FLASH operation to complete.
	}
	else
	{
		printf("EXCEPTION CODE %d: The Bootloader Firmware Image data was not successfully written into our MCU/MPU.\r\n", ret);
		return ret;
	}

	/* Lock the Flash Memory, just like it originally like before calling this @ref write_data_to_flash_bl function. */
	ret = HAL_FLASH_Lock();
	ret = HAL_ret_handler(ret);
	if(ret != HAL_OK)
	{
		printf("ERROR: HAL Flash could not be locked; ETX OTA Exception code %d.\r\n", ret);
	}

	return ret;
}

static ETX_OTA_Status HAL_ret_handler(HAL_StatusTypeDef HAL_status)
{
  switch (HAL_status)
    {
  	  case HAL_BUSY:
	  case HAL_TIMEOUT:
		return ETX_OTA_EC_NR;
	  case HAL_ERROR:
		return ETX_OTA_EC_ERR;
	  default:
		return HAL_status;
    }
}

/** @} */
