
Custom_Bootloader_Firmware.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08001800  08001800  00001800  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00003b58  0800190c  0800190c  0000190c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000440  08005464  08005464  00005464  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080058a4  080058a4  00010014  2**0
                  CONTENTS
  4 .ARM          00000000  080058a4  080058a4  00010014  2**0
                  CONTENTS
  5 .preinit_array 00000000  080058a4  080058a4  00010014  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080058a4  080058a4  000058a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080058a8  080058a8  000058a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000014  20000000  080058ac  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000600  20000018  080058c0  00010018  2**3
                  ALLOC
 10 ._user_heap_stack 00000600  20000618  080058c0  00010618  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00010014  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  0001003d  2**0
                  CONTENTS, READONLY
 13 .debug_info   00017ad3  00000000  00000000  00010080  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000034ac  00000000  00000000  00027b53  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loclists 0000c89d  00000000  00000000  0002afff  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00000b18  00000000  00000000  000378a0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00001567  00000000  00000000  000383b8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00018a38  00000000  00000000  0003991f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   0001a49b  00000000  00000000  00052357  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    0008d553  00000000  00000000  0006c7f2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_frame  000025c8  00000000  00000000  000f9d48  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 000000c0  00000000  00000000  000fc310  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0800190c <__do_global_dtors_aux>:
 800190c:	b510      	push	{r4, lr}
 800190e:	4c05      	ldr	r4, [pc, #20]	; (8001924 <__do_global_dtors_aux+0x18>)
 8001910:	7823      	ldrb	r3, [r4, #0]
 8001912:	b933      	cbnz	r3, 8001922 <__do_global_dtors_aux+0x16>
 8001914:	4b04      	ldr	r3, [pc, #16]	; (8001928 <__do_global_dtors_aux+0x1c>)
 8001916:	b113      	cbz	r3, 800191e <__do_global_dtors_aux+0x12>
 8001918:	4804      	ldr	r0, [pc, #16]	; (800192c <__do_global_dtors_aux+0x20>)
 800191a:	f3af 8000 	nop.w
 800191e:	2301      	movs	r3, #1
 8001920:	7023      	strb	r3, [r4, #0]
 8001922:	bd10      	pop	{r4, pc}
 8001924:	20000018 	.word	0x20000018
 8001928:	00000000 	.word	0x00000000
 800192c:	0800544c 	.word	0x0800544c

08001930 <frame_dummy>:
 8001930:	b508      	push	{r3, lr}
 8001932:	4b03      	ldr	r3, [pc, #12]	; (8001940 <frame_dummy+0x10>)
 8001934:	b11b      	cbz	r3, 800193e <frame_dummy+0xe>
 8001936:	4903      	ldr	r1, [pc, #12]	; (8001944 <frame_dummy+0x14>)
 8001938:	4803      	ldr	r0, [pc, #12]	; (8001948 <frame_dummy+0x18>)
 800193a:	f3af 8000 	nop.w
 800193e:	bd08      	pop	{r3, pc}
 8001940:	00000000 	.word	0x00000000
 8001944:	2000001c 	.word	0x2000001c
 8001948:	0800544c 	.word	0x0800544c

0800194c <turn_off_all_5641as_display_terminals>:
    /* Turn Off all the terminals of the 5641AS 7-segment Display Device. */
    turn_off_all_5641as_display_terminals();
}

static void turn_off_all_5641as_display_terminals()
{
 800194c:	b510      	push	{r4, lr}
    /* Turn Off all the terminals connected to the 5641AS 7-segment Display Device. */
    HAL_GPIO_WritePin(p_display_peripherals->K1.GPIO_Port, p_display_peripherals->K1.GPIO_Pin, GPIO_PIN_SET);
 800194e:	4c29      	ldr	r4, [pc, #164]	; (80019f4 <turn_off_all_5641as_display_terminals+0xa8>)
 8001950:	2201      	movs	r2, #1
 8001952:	6823      	ldr	r3, [r4, #0]
 8001954:	8e99      	ldrh	r1, [r3, #52]	; 0x34
 8001956:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8001958:	f002 fd14 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->K2.GPIO_Port, p_display_peripherals->K2.GPIO_Pin, GPIO_PIN_SET);
 800195c:	6823      	ldr	r3, [r4, #0]
 800195e:	2201      	movs	r2, #1
 8001960:	8f59      	ldrh	r1, [r3, #58]	; 0x3a
 8001962:	f8d3 0036 	ldr.w	r0, [r3, #54]	; 0x36
 8001966:	f002 fd0d 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->K3.GPIO_Port, p_display_peripherals->K3.GPIO_Pin, GPIO_PIN_SET);
 800196a:	6823      	ldr	r3, [r4, #0]
 800196c:	2201      	movs	r2, #1
 800196e:	f8b3 1040 	ldrh.w	r1, [r3, #64]	; 0x40
 8001972:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8001974:	f002 fd06 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->K4.GPIO_Port, p_display_peripherals->K4.GPIO_Pin, GPIO_PIN_SET);
 8001978:	6823      	ldr	r3, [r4, #0]
 800197a:	2201      	movs	r2, #1
 800197c:	f8b3 1046 	ldrh.w	r1, [r3, #70]	; 0x46
 8001980:	f8d3 0042 	ldr.w	r0, [r3, #66]	; 0x42
 8001984:	f002 fcfe 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->A.GPIO_Port, p_display_peripherals->A.GPIO_Pin, GPIO_PIN_RESET);
 8001988:	6823      	ldr	r3, [r4, #0]
 800198a:	2200      	movs	r2, #0
 800198c:	8899      	ldrh	r1, [r3, #4]
 800198e:	6818      	ldr	r0, [r3, #0]
 8001990:	f002 fcf8 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->B.GPIO_Port, p_display_peripherals->B.GPIO_Pin, GPIO_PIN_RESET);
 8001994:	6823      	ldr	r3, [r4, #0]
 8001996:	2200      	movs	r2, #0
 8001998:	8959      	ldrh	r1, [r3, #10]
 800199a:	f8d3 0006 	ldr.w	r0, [r3, #6]
 800199e:	f002 fcf1 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->C.GPIO_Port, p_display_peripherals->C.GPIO_Pin, GPIO_PIN_RESET);
 80019a2:	6823      	ldr	r3, [r4, #0]
 80019a4:	2200      	movs	r2, #0
 80019a6:	8a19      	ldrh	r1, [r3, #16]
 80019a8:	68d8      	ldr	r0, [r3, #12]
 80019aa:	f002 fceb 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->D.GPIO_Port, p_display_peripherals->D.GPIO_Pin, GPIO_PIN_RESET);
 80019ae:	6823      	ldr	r3, [r4, #0]
 80019b0:	2200      	movs	r2, #0
 80019b2:	8ad9      	ldrh	r1, [r3, #22]
 80019b4:	f8d3 0012 	ldr.w	r0, [r3, #18]
 80019b8:	f002 fce4 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->E.GPIO_Port, p_display_peripherals->E.GPIO_Pin, GPIO_PIN_RESET);
 80019bc:	6823      	ldr	r3, [r4, #0]
 80019be:	2200      	movs	r2, #0
 80019c0:	8b99      	ldrh	r1, [r3, #28]
 80019c2:	6998      	ldr	r0, [r3, #24]
 80019c4:	f002 fcde 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->F.GPIO_Port, p_display_peripherals->F.GPIO_Pin, GPIO_PIN_RESET);
 80019c8:	6823      	ldr	r3, [r4, #0]
 80019ca:	2200      	movs	r2, #0
 80019cc:	8c59      	ldrh	r1, [r3, #34]	; 0x22
 80019ce:	f8d3 001e 	ldr.w	r0, [r3, #30]
 80019d2:	f002 fcd7 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->G.GPIO_Port, p_display_peripherals->G.GPIO_Pin, GPIO_PIN_RESET);
 80019d6:	6823      	ldr	r3, [r4, #0]
 80019d8:	2200      	movs	r2, #0
 80019da:	8d19      	ldrh	r1, [r3, #40]	; 0x28
 80019dc:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80019de:	f002 fcd1 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->Dp.GPIO_Port, p_display_peripherals->Dp.GPIO_Pin, GPIO_PIN_RESET);
 80019e2:	6823      	ldr	r3, [r4, #0]
 80019e4:	2200      	movs	r2, #0
}
 80019e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_GPIO_WritePin(p_display_peripherals->Dp.GPIO_Port, p_display_peripherals->Dp.GPIO_Pin, GPIO_PIN_RESET);
 80019ea:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
 80019ec:	f8d3 002a 	ldr.w	r0, [r3, #42]	; 0x2a
 80019f0:	f002 bcc8 	b.w	8004384 <HAL_GPIO_WritePin>
 80019f4:	20000050 	.word	0x20000050

080019f8 <show_custom_display_output>:
{
 80019f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80019fc:	4680      	mov	r8, r0
 80019fe:	460f      	mov	r7, r1
 8001a00:	4616      	mov	r6, r2
 8001a02:	461d      	mov	r5, r3
 8001a04:	b083      	sub	sp, #12
    HAL_GPIO_WritePin(p_display_peripherals->A.GPIO_Port, p_display_peripherals->A.GPIO_Pin, A_pin_state);
 8001a06:	4c36      	ldr	r4, [pc, #216]	; (8001ae0 <show_custom_display_output+0xe8>)
{
 8001a08:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 8001a0c:	f89d b034 	ldrb.w	fp, [sp, #52]	; 0x34
 8001a10:	9301      	str	r3, [sp, #4]
 8001a12:	f89d a038 	ldrb.w	sl, [sp, #56]	; 0x38
 8001a16:	f89d 903c 	ldrb.w	r9, [sp, #60]	; 0x3c
    turn_off_all_5641as_display_terminals();
 8001a1a:	f7ff ff97 	bl	800194c <turn_off_all_5641as_display_terminals>
    HAL_GPIO_WritePin(p_display_peripherals->A.GPIO_Port, p_display_peripherals->A.GPIO_Pin, A_pin_state);
 8001a1e:	6822      	ldr	r2, [r4, #0]
 8001a20:	8891      	ldrh	r1, [r2, #4]
 8001a22:	6810      	ldr	r0, [r2, #0]
 8001a24:	4642      	mov	r2, r8
 8001a26:	f002 fcad 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->B.GPIO_Port, p_display_peripherals->B.GPIO_Pin, B_pin_state);
 8001a2a:	6820      	ldr	r0, [r4, #0]
 8001a2c:	463a      	mov	r2, r7
 8001a2e:	8941      	ldrh	r1, [r0, #10]
 8001a30:	f8d0 0006 	ldr.w	r0, [r0, #6]
 8001a34:	f002 fca6 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->C.GPIO_Port, p_display_peripherals->C.GPIO_Pin, C_pin_state);
 8001a38:	6820      	ldr	r0, [r4, #0]
 8001a3a:	4632      	mov	r2, r6
 8001a3c:	8a01      	ldrh	r1, [r0, #16]
 8001a3e:	68c0      	ldr	r0, [r0, #12]
 8001a40:	f002 fca0 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->D.GPIO_Port, p_display_peripherals->D.GPIO_Pin, D_pin_state);
 8001a44:	6820      	ldr	r0, [r4, #0]
 8001a46:	462a      	mov	r2, r5
 8001a48:	8ac1      	ldrh	r1, [r0, #22]
 8001a4a:	f8d0 0012 	ldr.w	r0, [r0, #18]
 8001a4e:	f002 fc99 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->E.GPIO_Port, p_display_peripherals->E.GPIO_Pin, E_pin_state);
 8001a52:	9b01      	ldr	r3, [sp, #4]
 8001a54:	461a      	mov	r2, r3
 8001a56:	6823      	ldr	r3, [r4, #0]
 8001a58:	8b99      	ldrh	r1, [r3, #28]
 8001a5a:	6998      	ldr	r0, [r3, #24]
 8001a5c:	f002 fc92 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->F.GPIO_Port, p_display_peripherals->F.GPIO_Pin, F_pin_state);
 8001a60:	6823      	ldr	r3, [r4, #0]
 8001a62:	465a      	mov	r2, fp
 8001a64:	8c59      	ldrh	r1, [r3, #34]	; 0x22
 8001a66:	f8d3 001e 	ldr.w	r0, [r3, #30]
 8001a6a:	f002 fc8b 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->G.GPIO_Port, p_display_peripherals->G.GPIO_Pin, G_pin_state);
 8001a6e:	6823      	ldr	r3, [r4, #0]
 8001a70:	4652      	mov	r2, sl
 8001a72:	8d19      	ldrh	r1, [r3, #40]	; 0x28
 8001a74:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001a76:	f002 fc85 	bl	8004384 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(p_display_peripherals->Dp.GPIO_Port, p_display_peripherals->Dp.GPIO_Pin, Dp_pin_state);
 8001a7a:	6823      	ldr	r3, [r4, #0]
 8001a7c:	464a      	mov	r2, r9
 8001a7e:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
 8001a80:	f8d3 002a 	ldr.w	r0, [r3, #42]	; 0x2a
 8001a84:	f002 fc7e 	bl	8004384 <HAL_GPIO_WritePin>
    switch (currently_enabled_5641as_7segment_display)
 8001a88:	4b16      	ldr	r3, [pc, #88]	; (8001ae4 <show_custom_display_output+0xec>)
 8001a8a:	781a      	ldrb	r2, [r3, #0]
            HAL_GPIO_WritePin(p_display_peripherals->K4.GPIO_Port, p_display_peripherals->K4.GPIO_Pin, GPIO_PIN_RESET);
 8001a8c:	6823      	ldr	r3, [r4, #0]
    switch (currently_enabled_5641as_7segment_display)
 8001a8e:	2a01      	cmp	r2, #1
 8001a90:	d00c      	beq.n	8001aac <show_custom_display_output+0xb4>
 8001a92:	2a02      	cmp	r2, #2
 8001a94:	d01a      	beq.n	8001acc <show_custom_display_output+0xd4>
 8001a96:	b192      	cbz	r2, 8001abe <show_custom_display_output+0xc6>
            HAL_GPIO_WritePin(p_display_peripherals->K4.GPIO_Port, p_display_peripherals->K4.GPIO_Pin, GPIO_PIN_RESET);
 8001a98:	2200      	movs	r2, #0
 8001a9a:	f8b3 1046 	ldrh.w	r1, [r3, #70]	; 0x46
 8001a9e:	f8d3 0042 	ldr.w	r0, [r3, #66]	; 0x42
}
 8001aa2:	b003      	add	sp, #12
 8001aa4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            HAL_GPIO_WritePin(p_display_peripherals->K4.GPIO_Port, p_display_peripherals->K4.GPIO_Pin, GPIO_PIN_RESET);
 8001aa8:	f002 bc6c 	b.w	8004384 <HAL_GPIO_WritePin>
            HAL_GPIO_WritePin(p_display_peripherals->K2.GPIO_Port, p_display_peripherals->K2.GPIO_Pin, GPIO_PIN_RESET);
 8001aac:	2200      	movs	r2, #0
 8001aae:	8f59      	ldrh	r1, [r3, #58]	; 0x3a
 8001ab0:	f8d3 0036 	ldr.w	r0, [r3, #54]	; 0x36
}
 8001ab4:	b003      	add	sp, #12
 8001ab6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            HAL_GPIO_WritePin(p_display_peripherals->K4.GPIO_Port, p_display_peripherals->K4.GPIO_Pin, GPIO_PIN_RESET);
 8001aba:	f002 bc63 	b.w	8004384 <HAL_GPIO_WritePin>
            HAL_GPIO_WritePin(p_display_peripherals->K1.GPIO_Port, p_display_peripherals->K1.GPIO_Pin, GPIO_PIN_RESET);
 8001abe:	8e99      	ldrh	r1, [r3, #52]	; 0x34
 8001ac0:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
 8001ac2:	b003      	add	sp, #12
 8001ac4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            HAL_GPIO_WritePin(p_display_peripherals->K4.GPIO_Port, p_display_peripherals->K4.GPIO_Pin, GPIO_PIN_RESET);
 8001ac8:	f002 bc5c 	b.w	8004384 <HAL_GPIO_WritePin>
            HAL_GPIO_WritePin(p_display_peripherals->K3.GPIO_Port, p_display_peripherals->K3.GPIO_Pin, GPIO_PIN_RESET);
 8001acc:	2200      	movs	r2, #0
 8001ace:	f8b3 1040 	ldrh.w	r1, [r3, #64]	; 0x40
 8001ad2:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
}
 8001ad4:	b003      	add	sp, #12
 8001ad6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            HAL_GPIO_WritePin(p_display_peripherals->K4.GPIO_Port, p_display_peripherals->K4.GPIO_Pin, GPIO_PIN_RESET);
 8001ada:	f002 bc53 	b.w	8004384 <HAL_GPIO_WritePin>
 8001ade:	bf00      	nop
 8001ae0:	20000050 	.word	0x20000050
 8001ae4:	2000003c 	.word	0x2000003c

08001ae8 <init_5641as_display_module>:
{
 8001ae8:	b410      	push	{r4}
    p_htim = htim;
 8001aea:	4c05      	ldr	r4, [pc, #20]	; (8001b00 <init_5641as_display_module+0x18>)
 8001aec:	6020      	str	r0, [r4, #0]
    p_display_peripherals = peripherals;
 8001aee:	4c05      	ldr	r4, [pc, #20]	; (8001b04 <init_5641as_display_module+0x1c>)
 8001af0:	6021      	str	r1, [r4, #0]
    display_on_time_steps = on_time_steps;
 8001af2:	4c05      	ldr	r4, [pc, #20]	; (8001b08 <init_5641as_display_module+0x20>)
    display_off_time_steps = off_time_steps;
 8001af4:	4905      	ldr	r1, [pc, #20]	; (8001b0c <init_5641as_display_module+0x24>)
    display_on_time_steps = on_time_steps;
 8001af6:	6022      	str	r2, [r4, #0]
}
 8001af8:	bc10      	pop	{r4}
    display_off_time_steps = off_time_steps;
 8001afa:	600b      	str	r3, [r1, #0]
    HAL_TIM_Base_Start_IT(p_htim);
 8001afc:	f002 bf86 	b.w	8004a0c <HAL_TIM_Base_Start_IT>
 8001b00:	20000054 	.word	0x20000054
 8001b04:	20000050 	.word	0x20000050
 8001b08:	2000004c 	.word	0x2000004c
 8001b0c:	20000048 	.word	0x20000048

08001b10 <start_5641as_display_module>:
 8001b10:	4b01      	ldr	r3, [pc, #4]	; (8001b18 <start_5641as_display_module+0x8>)
 8001b12:	6818      	ldr	r0, [r3, #0]
 8001b14:	f002 bf7a 	b.w	8004a0c <HAL_TIM_Base_Start_IT>
 8001b18:	20000054 	.word	0x20000054

08001b1c <stop_5641as_display_module>:
    HAL_TIM_Base_Stop_IT(p_htim);
 8001b1c:	4b01      	ldr	r3, [pc, #4]	; (8001b24 <stop_5641as_display_module+0x8>)
 8001b1e:	6818      	ldr	r0, [r3, #0]
 8001b20:	f002 bfa0 	b.w	8004a64 <HAL_TIM_Base_Stop_IT>
 8001b24:	20000054 	.word	0x20000054

08001b28 <set_5641as_display_output>:
        switch (display_output[current_display_output])
 8001b28:	8803      	ldrh	r3, [r0, #0]
{
 8001b2a:	4602      	mov	r2, r0
        switch (display_output[current_display_output])
 8001b2c:	2b5d      	cmp	r3, #93	; 0x5d
 8001b2e:	d841      	bhi.n	8001bb4 <set_5641as_display_output+0x8c>
 8001b30:	2b40      	cmp	r3, #64	; 0x40
 8001b32:	d84d      	bhi.n	8001bd0 <set_5641as_display_output+0xa8>
 8001b34:	b143      	cbz	r3, 8001b48 <set_5641as_display_output+0x20>
 8001b36:	3b20      	subs	r3, #32
 8001b38:	b29b      	uxth	r3, r3
 8001b3a:	2b1d      	cmp	r3, #29
 8001b3c:	d845      	bhi.n	8001bca <set_5641as_display_output+0xa2>
 8001b3e:	495b      	ldr	r1, [pc, #364]	; (8001cac <set_5641as_display_output+0x184>)
 8001b40:	fa21 f303 	lsr.w	r3, r1, r3
 8001b44:	07db      	lsls	r3, r3, #31
 8001b46:	d540      	bpl.n	8001bca <set_5641as_display_output+0xa2>
 8001b48:	8853      	ldrh	r3, [r2, #2]
 8001b4a:	2b5d      	cmp	r3, #93	; 0x5d
 8001b4c:	d851      	bhi.n	8001bf2 <set_5641as_display_output+0xca>
 8001b4e:	2b40      	cmp	r3, #64	; 0x40
 8001b50:	d85d      	bhi.n	8001c0e <set_5641as_display_output+0xe6>
 8001b52:	b143      	cbz	r3, 8001b66 <set_5641as_display_output+0x3e>
 8001b54:	3b20      	subs	r3, #32
 8001b56:	b29b      	uxth	r3, r3
 8001b58:	2b1d      	cmp	r3, #29
 8001b5a:	d836      	bhi.n	8001bca <set_5641as_display_output+0xa2>
 8001b5c:	4953      	ldr	r1, [pc, #332]	; (8001cac <set_5641as_display_output+0x184>)
 8001b5e:	fa21 f303 	lsr.w	r3, r1, r3
 8001b62:	07db      	lsls	r3, r3, #31
 8001b64:	d531      	bpl.n	8001bca <set_5641as_display_output+0xa2>
 8001b66:	8893      	ldrh	r3, [r2, #4]
 8001b68:	2b5d      	cmp	r3, #93	; 0x5d
 8001b6a:	d861      	bhi.n	8001c30 <set_5641as_display_output+0x108>
 8001b6c:	2b40      	cmp	r3, #64	; 0x40
 8001b6e:	d86d      	bhi.n	8001c4c <set_5641as_display_output+0x124>
 8001b70:	b143      	cbz	r3, 8001b84 <set_5641as_display_output+0x5c>
 8001b72:	3b20      	subs	r3, #32
 8001b74:	b29b      	uxth	r3, r3
 8001b76:	2b1d      	cmp	r3, #29
 8001b78:	d827      	bhi.n	8001bca <set_5641as_display_output+0xa2>
 8001b7a:	494c      	ldr	r1, [pc, #304]	; (8001cac <set_5641as_display_output+0x184>)
 8001b7c:	fa21 f303 	lsr.w	r3, r1, r3
 8001b80:	07db      	lsls	r3, r3, #31
 8001b82:	d522      	bpl.n	8001bca <set_5641as_display_output+0xa2>
 8001b84:	88d3      	ldrh	r3, [r2, #6]
 8001b86:	2b5d      	cmp	r3, #93	; 0x5d
 8001b88:	d871      	bhi.n	8001c6e <set_5641as_display_output+0x146>
 8001b8a:	2b40      	cmp	r3, #64	; 0x40
 8001b8c:	d87d      	bhi.n	8001c8a <set_5641as_display_output+0x162>
 8001b8e:	b143      	cbz	r3, 8001ba2 <set_5641as_display_output+0x7a>
 8001b90:	3b20      	subs	r3, #32
 8001b92:	b29b      	uxth	r3, r3
 8001b94:	2b1d      	cmp	r3, #29
 8001b96:	d818      	bhi.n	8001bca <set_5641as_display_output+0xa2>
 8001b98:	4944      	ldr	r1, [pc, #272]	; (8001cac <set_5641as_display_output+0x184>)
 8001b9a:	fa21 f303 	lsr.w	r3, r1, r3
 8001b9e:	07db      	lsls	r3, r3, #31
 8001ba0:	d513      	bpl.n	8001bca <set_5641as_display_output+0xa2>
    return Display_5641AS_EC_OK;
 8001ba2:	2300      	movs	r3, #0
{
 8001ba4:	b410      	push	{r4}
        display_5641as_output[current_display_output] = display_output[current_display_output];
 8001ba6:	4c42      	ldr	r4, [pc, #264]	; (8001cb0 <set_5641as_display_output+0x188>)
 8001ba8:	6810      	ldr	r0, [r2, #0]
 8001baa:	6851      	ldr	r1, [r2, #4]
 8001bac:	c403      	stmia	r4!, {r0, r1}
}
 8001bae:	4618      	mov	r0, r3
 8001bb0:	bc10      	pop	{r4}
 8001bb2:	4770      	bx	lr
        switch (display_output[current_display_output])
 8001bb4:	2b7c      	cmp	r3, #124	; 0x7c
 8001bb6:	d815      	bhi.n	8001be4 <set_5641as_display_output+0xbc>
 8001bb8:	2b5e      	cmp	r3, #94	; 0x5e
 8001bba:	d006      	beq.n	8001bca <set_5641as_display_output+0xa2>
 8001bbc:	493d      	ldr	r1, [pc, #244]	; (8001cb4 <set_5641as_display_output+0x18c>)
 8001bbe:	3b5f      	subs	r3, #95	; 0x5f
 8001bc0:	b29b      	uxth	r3, r3
 8001bc2:	fa21 f303 	lsr.w	r3, r1, r3
 8001bc6:	07d8      	lsls	r0, r3, #31
 8001bc8:	d4be      	bmi.n	8001b48 <set_5641as_display_output+0x20>
 8001bca:	2304      	movs	r3, #4
}
 8001bcc:	4618      	mov	r0, r3
 8001bce:	4770      	bx	lr
        switch (display_output[current_display_output])
 8001bd0:	4939      	ldr	r1, [pc, #228]	; (8001cb8 <set_5641as_display_output+0x190>)
 8001bd2:	3b41      	subs	r3, #65	; 0x41
 8001bd4:	b29b      	uxth	r3, r3
 8001bd6:	fa21 f303 	lsr.w	r3, r1, r3
 8001bda:	07d9      	lsls	r1, r3, #31
 8001bdc:	d4b4      	bmi.n	8001b48 <set_5641as_display_output+0x20>
 8001bde:	2304      	movs	r3, #4
}
 8001be0:	4618      	mov	r0, r3
 8001be2:	4770      	bx	lr
        switch (display_output[current_display_output])
 8001be4:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8001be8:	2b09      	cmp	r3, #9
 8001bea:	d8ee      	bhi.n	8001bca <set_5641as_display_output+0xa2>
 8001bec:	8853      	ldrh	r3, [r2, #2]
 8001bee:	2b5d      	cmp	r3, #93	; 0x5d
 8001bf0:	d9ad      	bls.n	8001b4e <set_5641as_display_output+0x26>
 8001bf2:	2b7c      	cmp	r3, #124	; 0x7c
 8001bf4:	d815      	bhi.n	8001c22 <set_5641as_display_output+0xfa>
 8001bf6:	2b5e      	cmp	r3, #94	; 0x5e
 8001bf8:	d0e7      	beq.n	8001bca <set_5641as_display_output+0xa2>
 8001bfa:	492e      	ldr	r1, [pc, #184]	; (8001cb4 <set_5641as_display_output+0x18c>)
 8001bfc:	3b5f      	subs	r3, #95	; 0x5f
 8001bfe:	b29b      	uxth	r3, r3
 8001c00:	fa21 f303 	lsr.w	r3, r1, r3
 8001c04:	07d8      	lsls	r0, r3, #31
 8001c06:	d4ae      	bmi.n	8001b66 <set_5641as_display_output+0x3e>
 8001c08:	2304      	movs	r3, #4
}
 8001c0a:	4618      	mov	r0, r3
 8001c0c:	4770      	bx	lr
        switch (display_output[current_display_output])
 8001c0e:	492a      	ldr	r1, [pc, #168]	; (8001cb8 <set_5641as_display_output+0x190>)
 8001c10:	3b41      	subs	r3, #65	; 0x41
 8001c12:	b29b      	uxth	r3, r3
 8001c14:	fa21 f303 	lsr.w	r3, r1, r3
 8001c18:	07d9      	lsls	r1, r3, #31
 8001c1a:	d4a4      	bmi.n	8001b66 <set_5641as_display_output+0x3e>
 8001c1c:	2304      	movs	r3, #4
}
 8001c1e:	4618      	mov	r0, r3
 8001c20:	4770      	bx	lr
        switch (display_output[current_display_output])
 8001c22:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8001c26:	2b09      	cmp	r3, #9
 8001c28:	d8cf      	bhi.n	8001bca <set_5641as_display_output+0xa2>
 8001c2a:	8893      	ldrh	r3, [r2, #4]
 8001c2c:	2b5d      	cmp	r3, #93	; 0x5d
 8001c2e:	d99d      	bls.n	8001b6c <set_5641as_display_output+0x44>
 8001c30:	2b7c      	cmp	r3, #124	; 0x7c
 8001c32:	d815      	bhi.n	8001c60 <set_5641as_display_output+0x138>
 8001c34:	2b5e      	cmp	r3, #94	; 0x5e
 8001c36:	d0c8      	beq.n	8001bca <set_5641as_display_output+0xa2>
 8001c38:	491e      	ldr	r1, [pc, #120]	; (8001cb4 <set_5641as_display_output+0x18c>)
 8001c3a:	3b5f      	subs	r3, #95	; 0x5f
 8001c3c:	b29b      	uxth	r3, r3
 8001c3e:	fa21 f303 	lsr.w	r3, r1, r3
 8001c42:	07d8      	lsls	r0, r3, #31
 8001c44:	d49e      	bmi.n	8001b84 <set_5641as_display_output+0x5c>
 8001c46:	2304      	movs	r3, #4
}
 8001c48:	4618      	mov	r0, r3
 8001c4a:	4770      	bx	lr
        switch (display_output[current_display_output])
 8001c4c:	491a      	ldr	r1, [pc, #104]	; (8001cb8 <set_5641as_display_output+0x190>)
 8001c4e:	3b41      	subs	r3, #65	; 0x41
 8001c50:	b29b      	uxth	r3, r3
 8001c52:	fa21 f303 	lsr.w	r3, r1, r3
 8001c56:	07d9      	lsls	r1, r3, #31
 8001c58:	d494      	bmi.n	8001b84 <set_5641as_display_output+0x5c>
 8001c5a:	2304      	movs	r3, #4
}
 8001c5c:	4618      	mov	r0, r3
 8001c5e:	4770      	bx	lr
        switch (display_output[current_display_output])
 8001c60:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8001c64:	2b09      	cmp	r3, #9
 8001c66:	d8b0      	bhi.n	8001bca <set_5641as_display_output+0xa2>
 8001c68:	88d3      	ldrh	r3, [r2, #6]
 8001c6a:	2b5d      	cmp	r3, #93	; 0x5d
 8001c6c:	d98d      	bls.n	8001b8a <set_5641as_display_output+0x62>
 8001c6e:	2b7c      	cmp	r3, #124	; 0x7c
 8001c70:	d815      	bhi.n	8001c9e <set_5641as_display_output+0x176>
 8001c72:	2b5e      	cmp	r3, #94	; 0x5e
 8001c74:	d0a9      	beq.n	8001bca <set_5641as_display_output+0xa2>
 8001c76:	490f      	ldr	r1, [pc, #60]	; (8001cb4 <set_5641as_display_output+0x18c>)
 8001c78:	3b5f      	subs	r3, #95	; 0x5f
 8001c7a:	b29b      	uxth	r3, r3
 8001c7c:	fa21 f303 	lsr.w	r3, r1, r3
 8001c80:	07d8      	lsls	r0, r3, #31
 8001c82:	d48e      	bmi.n	8001ba2 <set_5641as_display_output+0x7a>
 8001c84:	2304      	movs	r3, #4
}
 8001c86:	4618      	mov	r0, r3
 8001c88:	4770      	bx	lr
        switch (display_output[current_display_output])
 8001c8a:	490b      	ldr	r1, [pc, #44]	; (8001cb8 <set_5641as_display_output+0x190>)
 8001c8c:	3b41      	subs	r3, #65	; 0x41
 8001c8e:	b29b      	uxth	r3, r3
 8001c90:	fa21 f303 	lsr.w	r3, r1, r3
 8001c94:	07d9      	lsls	r1, r3, #31
 8001c96:	d484      	bmi.n	8001ba2 <set_5641as_display_output+0x7a>
 8001c98:	2304      	movs	r3, #4
}
 8001c9a:	4618      	mov	r0, r3
 8001c9c:	4770      	bx	lr
        switch (display_output[current_display_output])
 8001c9e:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8001ca2:	2b09      	cmp	r3, #9
 8001ca4:	f67f af7d 	bls.w	8001ba2 <set_5641as_display_output+0x7a>
 8001ca8:	e78f      	b.n	8001bca <set_5641as_display_output+0xa2>
 8001caa:	bf00      	nop
 8001cac:	23ff6085 	.word	0x23ff6085
 8001cb0:	20000040 	.word	0x20000040
 8001cb4:	2069a6b9 	.word	0x2069a6b9
 8001cb8:	1414c8bf 	.word	0x1414c8bf

08001cbc <HAL_TIM_PeriodElapsedCallback>:
    if (htim->Instance == p_htim->Instance)
 8001cbc:	4b03      	ldr	r3, [pc, #12]	; (8001ccc <HAL_TIM_PeriodElapsedCallback+0x10>)
 8001cbe:	6802      	ldr	r2, [r0, #0]
 8001cc0:	681b      	ldr	r3, [r3, #0]
 8001cc2:	681b      	ldr	r3, [r3, #0]
 8001cc4:	429a      	cmp	r2, r3
 8001cc6:	d003      	beq.n	8001cd0 <HAL_TIM_PeriodElapsedCallback+0x14>
 8001cc8:	4770      	bx	lr
 8001cca:	bf00      	nop
 8001ccc:	20000054 	.word	0x20000054
{
 8001cd0:	b530      	push	{r4, r5, lr}
        if (current_display_on_time_step != display_on_time_steps) // If true, then the current time step of the @ref display_5641as is at the On time of the currently simulated PWM output at the 5641AS Device.
 8001cd2:	4c7f      	ldr	r4, [pc, #508]	; (8001ed0 <HAL_TIM_PeriodElapsedCallback+0x214>)
 8001cd4:	4d7f      	ldr	r5, [pc, #508]	; (8001ed4 <HAL_TIM_PeriodElapsedCallback+0x218>)
 8001cd6:	6823      	ldr	r3, [r4, #0]
 8001cd8:	682a      	ldr	r2, [r5, #0]
{
 8001cda:	b085      	sub	sp, #20
        if (current_display_on_time_step != display_on_time_steps) // If true, then the current time step of the @ref display_5641as is at the On time of the currently simulated PWM output at the 5641AS Device.
 8001cdc:	4293      	cmp	r3, r2
 8001cde:	f000 80ff 	beq.w	8001ee0 <HAL_TIM_PeriodElapsedCallback+0x224>
            if (current_display_on_time_step == 0)
 8001ce2:	2b00      	cmp	r3, #0
 8001ce4:	f040 8120 	bne.w	8001f28 <HAL_TIM_PeriodElapsedCallback+0x26c>
                switch (display_5641as_output[currently_enabled_5641as_7segment_display])
 8001ce8:	4a7b      	ldr	r2, [pc, #492]	; (8001ed8 <HAL_TIM_PeriodElapsedCallback+0x21c>)
 8001cea:	4b7c      	ldr	r3, [pc, #496]	; (8001edc <HAL_TIM_PeriodElapsedCallback+0x220>)
 8001cec:	7812      	ldrb	r2, [r2, #0]
 8001cee:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8001cf2:	3b22      	subs	r3, #34	; 0x22
 8001cf4:	2be7      	cmp	r3, #231	; 0xe7
 8001cf6:	f200 812a 	bhi.w	8001f4e <HAL_TIM_PeriodElapsedCallback+0x292>
 8001cfa:	e8df f013 	tbh	[pc, r3, lsl #1]
 8001cfe:	0261      	.short	0x0261
 8001d00:	01280128 	.word	0x01280128
 8001d04:	01280128 	.word	0x01280128
 8001d08:	0128025b 	.word	0x0128025b
 8001d0c:	01280128 	.word	0x01280128
 8001d10:	01280128 	.word	0x01280128
 8001d14:	02520257 	.word	0x02520257
 8001d18:	01080128 	.word	0x01080128
 8001d1c:	024b012d 	.word	0x024b012d
 8001d20:	021b0244 	.word	0x021b0244
 8001d24:	0225013f 	.word	0x0225013f
 8001d28:	013a021f 	.word	0x013a021f
 8001d2c:	01280216 	.word	0x01280216
 8001d30:	01280128 	.word	0x01280128
 8001d34:	012801ba 	.word	0x012801ba
 8001d38:	01280128 	.word	0x01280128
 8001d3c:	013a01b3 	.word	0x013a01b3
 8001d40:	01080159 	.word	0x01080159
 8001d44:	014c01ad 	.word	0x014c01ad
 8001d48:	01a00128 	.word	0x01a00128
 8001d4c:	01280128 	.word	0x01280128
 8001d50:	01dd0128 	.word	0x01dd0128
 8001d54:	01280128 	.word	0x01280128
 8001d58:	01d00108 	.word	0x01d00108
 8001d5c:	01280128 	.word	0x01280128
 8001d60:	0128013f 	.word	0x0128013f
 8001d64:	012801c9 	.word	0x012801c9
 8001d68:	01280128 	.word	0x01280128
 8001d6c:	01280128 	.word	0x01280128
 8001d70:	01280159 	.word	0x01280159
 8001d74:	012801c1 	.word	0x012801c1
 8001d78:	0128020f 	.word	0x0128020f
 8001d7c:	02090128 	.word	0x02090128
 8001d80:	01fd0203 	.word	0x01fd0203
 8001d84:	014c0128 	.word	0x014c0128
 8001d88:	01f60128 	.word	0x01f60128
 8001d8c:	012801ef 	.word	0x012801ef
 8001d90:	012d0128 	.word	0x012d0128
 8001d94:	01e80128 	.word	0x01e80128
 8001d98:	012801e3 	.word	0x012801e3
 8001d9c:	019a0128 	.word	0x019a0128
 8001da0:	018d0128 	.word	0x018d0128
 8001da4:	01280180 	.word	0x01280180
 8001da8:	01280128 	.word	0x01280128
 8001dac:	01280128 	.word	0x01280128
 8001db0:	012d0128 	.word	0x012d0128
 8001db4:	01280128 	.word	0x01280128
 8001db8:	01280128 	.word	0x01280128
 8001dbc:	01280128 	.word	0x01280128
 8001dc0:	01280128 	.word	0x01280128
 8001dc4:	01280128 	.word	0x01280128
 8001dc8:	01280128 	.word	0x01280128
 8001dcc:	01280128 	.word	0x01280128
 8001dd0:	01280128 	.word	0x01280128
 8001dd4:	01280128 	.word	0x01280128
 8001dd8:	01280128 	.word	0x01280128
 8001ddc:	01280128 	.word	0x01280128
 8001de0:	01280128 	.word	0x01280128
 8001de4:	01280128 	.word	0x01280128
 8001de8:	01280128 	.word	0x01280128
 8001dec:	01280128 	.word	0x01280128
 8001df0:	01280128 	.word	0x01280128
 8001df4:	01280128 	.word	0x01280128
 8001df8:	01280128 	.word	0x01280128
 8001dfc:	01280128 	.word	0x01280128
 8001e00:	01280128 	.word	0x01280128
 8001e04:	01280128 	.word	0x01280128
 8001e08:	01280128 	.word	0x01280128
 8001e0c:	01280128 	.word	0x01280128
 8001e10:	01280128 	.word	0x01280128
 8001e14:	01280128 	.word	0x01280128
 8001e18:	01280128 	.word	0x01280128
 8001e1c:	01280128 	.word	0x01280128
 8001e20:	01280128 	.word	0x01280128
 8001e24:	01280128 	.word	0x01280128
 8001e28:	01280128 	.word	0x01280128
 8001e2c:	01280128 	.word	0x01280128
 8001e30:	01280128 	.word	0x01280128
 8001e34:	01280128 	.word	0x01280128
 8001e38:	01280128 	.word	0x01280128
 8001e3c:	01280128 	.word	0x01280128
 8001e40:	01280128 	.word	0x01280128
 8001e44:	01280128 	.word	0x01280128
 8001e48:	01280128 	.word	0x01280128
 8001e4c:	01280128 	.word	0x01280128
 8001e50:	01280128 	.word	0x01280128
 8001e54:	01280128 	.word	0x01280128
 8001e58:	01280128 	.word	0x01280128
 8001e5c:	01280128 	.word	0x01280128
 8001e60:	01280128 	.word	0x01280128
 8001e64:	01280128 	.word	0x01280128
 8001e68:	01280128 	.word	0x01280128
 8001e6c:	01280128 	.word	0x01280128
 8001e70:	01280128 	.word	0x01280128
 8001e74:	01280128 	.word	0x01280128
 8001e78:	01280128 	.word	0x01280128
 8001e7c:	01280128 	.word	0x01280128
 8001e80:	01280128 	.word	0x01280128
 8001e84:	01280128 	.word	0x01280128
 8001e88:	01280128 	.word	0x01280128
 8001e8c:	01280128 	.word	0x01280128
 8001e90:	01280128 	.word	0x01280128
 8001e94:	01280128 	.word	0x01280128
 8001e98:	01280128 	.word	0x01280128
 8001e9c:	01280128 	.word	0x01280128
 8001ea0:	01280128 	.word	0x01280128
 8001ea4:	01280128 	.word	0x01280128
 8001ea8:	01280128 	.word	0x01280128
 8001eac:	01280128 	.word	0x01280128
 8001eb0:	01280128 	.word	0x01280128
 8001eb4:	01280128 	.word	0x01280128
 8001eb8:	01790128 	.word	0x01790128
 8001ebc:	016c0173 	.word	0x016c0173
 8001ec0:	015f0165 	.word	0x015f0165
 8001ec4:	0234023b 	.word	0x0234023b
 8001ec8:	022c022e 	.word	0x022c022e
 8001ecc:	023f      	.short	0x023f
 8001ece:	bf00      	nop
 8001ed0:	20000038 	.word	0x20000038
 8001ed4:	2000004c 	.word	0x2000004c
 8001ed8:	2000003c 	.word	0x2000003c
 8001edc:	20000040 	.word	0x20000040
            if (current_display_off_time_step == 0)
 8001ee0:	4dbd      	ldr	r5, [pc, #756]	; (80021d8 <HAL_TIM_PeriodElapsedCallback+0x51c>)
 8001ee2:	682b      	ldr	r3, [r5, #0]
 8001ee4:	2b00      	cmp	r3, #0
 8001ee6:	f000 8172 	beq.w	80021ce <HAL_TIM_PeriodElapsedCallback+0x512>
            if (current_display_off_time_step >= display_off_time_steps)
 8001eea:	4abc      	ldr	r2, [pc, #752]	; (80021dc <HAL_TIM_PeriodElapsedCallback+0x520>)
            current_display_off_time_step++;
 8001eec:	3301      	adds	r3, #1
            if (current_display_off_time_step >= display_off_time_steps)
 8001eee:	6812      	ldr	r2, [r2, #0]
            current_display_off_time_step++;
 8001ef0:	602b      	str	r3, [r5, #0]
            if (current_display_off_time_step >= display_off_time_steps)
 8001ef2:	4293      	cmp	r3, r2
 8001ef4:	d309      	bcc.n	8001f0a <HAL_TIM_PeriodElapsedCallback+0x24e>
                current_display_on_time_step = 0;
 8001ef6:	2100      	movs	r1, #0
                currently_enabled_5641as_7segment_display++;
 8001ef8:	4ab9      	ldr	r2, [pc, #740]	; (80021e0 <HAL_TIM_PeriodElapsedCallback+0x524>)
                current_display_on_time_step = 0;
 8001efa:	6021      	str	r1, [r4, #0]
                currently_enabled_5641as_7segment_display++;
 8001efc:	7813      	ldrb	r3, [r2, #0]
                current_display_off_time_step = 0;
 8001efe:	6029      	str	r1, [r5, #0]
                currently_enabled_5641as_7segment_display++;
 8001f00:	3301      	adds	r3, #1
 8001f02:	b2db      	uxtb	r3, r3
                if (currently_enabled_5641as_7segment_display == 4)
 8001f04:	2b04      	cmp	r3, #4
                currently_enabled_5641as_7segment_display++;
 8001f06:	7013      	strb	r3, [r2, #0]
                if (currently_enabled_5641as_7segment_display == 4)
 8001f08:	d01e      	beq.n	8001f48 <HAL_TIM_PeriodElapsedCallback+0x28c>
}
 8001f0a:	b005      	add	sp, #20
 8001f0c:	bd30      	pop	{r4, r5, pc}
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 8001f0e:	2200      	movs	r2, #0
 8001f10:	2301      	movs	r3, #1
 8001f12:	9203      	str	r2, [sp, #12]
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8001f14:	9202      	str	r2, [sp, #8]
 8001f16:	9301      	str	r3, [sp, #4]
 8001f18:	9300      	str	r3, [sp, #0]
 8001f1a:	461a      	mov	r2, r3
 8001f1c:	4619      	mov	r1, r3
 8001f1e:	4618      	mov	r0, r3
 8001f20:	f7ff fd6a 	bl	80019f8 <show_custom_display_output>
            current_display_on_time_step++;
 8001f24:	6823      	ldr	r3, [r4, #0]
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 8001f26:	682a      	ldr	r2, [r5, #0]
            current_display_on_time_step++;
 8001f28:	3301      	adds	r3, #1
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 8001f2a:	4293      	cmp	r3, r2
            current_display_on_time_step++;
 8001f2c:	6023      	str	r3, [r4, #0]
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 8001f2e:	d3ec      	bcc.n	8001f0a <HAL_TIM_PeriodElapsedCallback+0x24e>
 8001f30:	4baa      	ldr	r3, [pc, #680]	; (80021dc <HAL_TIM_PeriodElapsedCallback+0x520>)
 8001f32:	681b      	ldr	r3, [r3, #0]
 8001f34:	2b00      	cmp	r3, #0
 8001f36:	d1e8      	bne.n	8001f0a <HAL_TIM_PeriodElapsedCallback+0x24e>
                currently_enabled_5641as_7segment_display++;
 8001f38:	4aa9      	ldr	r2, [pc, #676]	; (80021e0 <HAL_TIM_PeriodElapsedCallback+0x524>)
                current_display_on_time_step = 0;
 8001f3a:	6023      	str	r3, [r4, #0]
                currently_enabled_5641as_7segment_display++;
 8001f3c:	7813      	ldrb	r3, [r2, #0]
 8001f3e:	3301      	adds	r3, #1
 8001f40:	b2db      	uxtb	r3, r3
                if (currently_enabled_5641as_7segment_display == 4)
 8001f42:	2b04      	cmp	r3, #4
                currently_enabled_5641as_7segment_display++;
 8001f44:	7013      	strb	r3, [r2, #0]
                if (currently_enabled_5641as_7segment_display == 4)
 8001f46:	d1e0      	bne.n	8001f0a <HAL_TIM_PeriodElapsedCallback+0x24e>
                    currently_enabled_5641as_7segment_display = 0;
 8001f48:	2300      	movs	r3, #0
 8001f4a:	7013      	strb	r3, [r2, #0]
 8001f4c:	e7dd      	b.n	8001f0a <HAL_TIM_PeriodElapsedCallback+0x24e>
    turn_off_all_5641as_display_terminals();
 8001f4e:	f7ff fcfd 	bl	800194c <turn_off_all_5641as_display_terminals>
            current_display_on_time_step++;
 8001f52:	6823      	ldr	r3, [r4, #0]
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 8001f54:	682a      	ldr	r2, [r5, #0]
}
 8001f56:	e7e7      	b.n	8001f28 <HAL_TIM_PeriodElapsedCallback+0x26c>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 8001f58:	2300      	movs	r3, #0
 8001f5a:	2201      	movs	r2, #1
 8001f5c:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8001f60:	9301      	str	r3, [sp, #4]
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET);
 8001f62:	4618      	mov	r0, r3
 8001f64:	4611      	mov	r1, r2
 8001f66:	9300      	str	r3, [sp, #0]
 8001f68:	f7ff fd46 	bl	80019f8 <show_custom_display_output>
            current_display_on_time_step++;
 8001f6c:	6823      	ldr	r3, [r4, #0]
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 8001f6e:	682a      	ldr	r2, [r5, #0]
                        break;
 8001f70:	e7da      	b.n	8001f28 <HAL_TIM_PeriodElapsedCallback+0x26c>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8001f72:	2301      	movs	r3, #1
 8001f74:	2200      	movs	r2, #0
 8001f76:	e9cd 3202 	strd	r3, r2, [sp, #8]
 8001f7a:	e7cc      	b.n	8001f16 <HAL_TIM_PeriodElapsedCallback+0x25a>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8001f7c:	2100      	movs	r1, #0
 8001f7e:	2301      	movs	r3, #1
 8001f80:	9103      	str	r1, [sp, #12]
 8001f82:	e9cd 3301 	strd	r3, r3, [sp, #4]
 8001f86:	9100      	str	r1, [sp, #0]
 8001f88:	461a      	mov	r2, r3
 8001f8a:	4618      	mov	r0, r3
 8001f8c:	f7ff fd34 	bl	80019f8 <show_custom_display_output>
            current_display_on_time_step++;
 8001f90:	6823      	ldr	r3, [r4, #0]
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 8001f92:	682a      	ldr	r2, [r5, #0]
                        break;
 8001f94:	e7c8      	b.n	8001f28 <HAL_TIM_PeriodElapsedCallback+0x26c>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8001f96:	2001      	movs	r0, #1
 8001f98:	2300      	movs	r3, #0
 8001f9a:	e9cd 0000 	strd	r0, r0, [sp]
 8001f9e:	e9cd 0302 	strd	r0, r3, [sp, #8]
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8001fa2:	461a      	mov	r2, r3
 8001fa4:	4619      	mov	r1, r3
 8001fa6:	f7ff fd27 	bl	80019f8 <show_custom_display_output>
            current_display_on_time_step++;
 8001faa:	6823      	ldr	r3, [r4, #0]
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 8001fac:	682a      	ldr	r2, [r5, #0]
                        break;
 8001fae:	e7bb      	b.n	8001f28 <HAL_TIM_PeriodElapsedCallback+0x26c>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 8001fb0:	2200      	movs	r2, #0
 8001fb2:	2301      	movs	r3, #1
 8001fb4:	e9cd 2202 	strd	r2, r2, [sp, #8]
 8001fb8:	9301      	str	r3, [sp, #4]
 8001fba:	e7d2      	b.n	8001f62 <HAL_TIM_PeriodElapsedCallback+0x2a6>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET);
 8001fbc:	2201      	movs	r2, #1
 8001fbe:	2300      	movs	r3, #0
 8001fc0:	9203      	str	r2, [sp, #12]
 8001fc2:	e9cd 2201 	strd	r2, r2, [sp, #4]
 8001fc6:	e7cc      	b.n	8001f62 <HAL_TIM_PeriodElapsedCallback+0x2a6>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET);
 8001fc8:	2301      	movs	r3, #1
 8001fca:	2200      	movs	r2, #0
 8001fcc:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8001fd0:	9201      	str	r2, [sp, #4]
 8001fd2:	9200      	str	r2, [sp, #0]
 8001fd4:	e7a1      	b.n	8001f1a <HAL_TIM_PeriodElapsedCallback+0x25e>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET);
 8001fd6:	2301      	movs	r3, #1
 8001fd8:	2200      	movs	r2, #0
 8001fda:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8001fde:	e9cd 3200 	strd	r3, r2, [sp]
 8001fe2:	e79b      	b.n	8001f1c <HAL_TIM_PeriodElapsedCallback+0x260>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET);
 8001fe4:	2300      	movs	r3, #0
 8001fe6:	2201      	movs	r2, #1
 8001fe8:	9301      	str	r3, [sp, #4]
 8001fea:	e9cd 3202 	strd	r3, r2, [sp, #8]
 8001fee:	e7b8      	b.n	8001f62 <HAL_TIM_PeriodElapsedCallback+0x2a6>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET);
 8001ff0:	2301      	movs	r3, #1
 8001ff2:	2200      	movs	r2, #0
 8001ff4:	e9cd 3300 	strd	r3, r3, [sp]
 8001ff8:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8001ffc:	e78d      	b.n	8001f1a <HAL_TIM_PeriodElapsedCallback+0x25e>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 8001ffe:	2100      	movs	r1, #0
 8002000:	2301      	movs	r3, #1
 8002002:	e9cd 1102 	strd	r1, r1, [sp, #8]
 8002006:	9101      	str	r1, [sp, #4]
 8002008:	461a      	mov	r2, r3
 800200a:	9300      	str	r3, [sp, #0]
 800200c:	4608      	mov	r0, r1
 800200e:	f7ff fcf3 	bl	80019f8 <show_custom_display_output>
            current_display_on_time_step++;
 8002012:	6823      	ldr	r3, [r4, #0]
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 8002014:	682a      	ldr	r2, [r5, #0]
                        break;
 8002016:	e787      	b.n	8001f28 <HAL_TIM_PeriodElapsedCallback+0x26c>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002018:	2301      	movs	r3, #1
 800201a:	2200      	movs	r2, #0
 800201c:	e9cd 3202 	strd	r3, r2, [sp, #8]
 8002020:	9301      	str	r3, [sp, #4]
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET);
 8002022:	9300      	str	r3, [sp, #0]
 8002024:	4611      	mov	r1, r2
 8002026:	4610      	mov	r0, r2
 8002028:	f7ff fce6 	bl	80019f8 <show_custom_display_output>
            current_display_on_time_step++;
 800202c:	6823      	ldr	r3, [r4, #0]
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 800202e:	682a      	ldr	r2, [r5, #0]
                        break;
 8002030:	e77a      	b.n	8001f28 <HAL_TIM_PeriodElapsedCallback+0x26c>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002032:	2300      	movs	r3, #0
 8002034:	2201      	movs	r2, #1
 8002036:	9301      	str	r3, [sp, #4]
 8002038:	e9cd 2302 	strd	r2, r3, [sp, #8]
 800203c:	e7c9      	b.n	8001fd2 <HAL_TIM_PeriodElapsedCallback+0x316>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 800203e:	2201      	movs	r2, #1
 8002040:	2300      	movs	r3, #0
 8002042:	4611      	mov	r1, r2
 8002044:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8002048:	4618      	mov	r0, r3
 800204a:	e9cd 2200 	strd	r2, r2, [sp]
 800204e:	f7ff fcd3 	bl	80019f8 <show_custom_display_output>
            current_display_on_time_step++;
 8002052:	6823      	ldr	r3, [r4, #0]
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 8002054:	682a      	ldr	r2, [r5, #0]
                        break;
 8002056:	e767      	b.n	8001f28 <HAL_TIM_PeriodElapsedCallback+0x26c>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002058:	2301      	movs	r3, #1
 800205a:	2200      	movs	r2, #0
 800205c:	9301      	str	r3, [sp, #4]
 800205e:	e9cd 3202 	strd	r3, r2, [sp, #8]
 8002062:	e77e      	b.n	8001f62 <HAL_TIM_PeriodElapsedCallback+0x2a6>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002064:	2201      	movs	r2, #1
 8002066:	2300      	movs	r3, #0
 8002068:	e9cd 2200 	strd	r2, r2, [sp]
 800206c:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8002070:	e7d8      	b.n	8002024 <HAL_TIM_PeriodElapsedCallback+0x368>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002072:	2200      	movs	r2, #0
 8002074:	2301      	movs	r3, #1
 8002076:	e9cd 2200 	strd	r2, r2, [sp]
 800207a:	e9cd 3202 	strd	r3, r2, [sp, #8]
 800207e:	e7d1      	b.n	8002024 <HAL_TIM_PeriodElapsedCallback+0x368>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 8002080:	2100      	movs	r1, #0
 8002082:	2301      	movs	r3, #1
 8002084:	e9cd 1101 	strd	r1, r1, [sp, #4]
 8002088:	461a      	mov	r2, r3
 800208a:	9103      	str	r1, [sp, #12]
 800208c:	9100      	str	r1, [sp, #0]
 800208e:	e745      	b.n	8001f1c <HAL_TIM_PeriodElapsedCallback+0x260>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 8002090:	2000      	movs	r0, #0
 8002092:	2301      	movs	r3, #1
 8002094:	e9cd 0002 	strd	r0, r0, [sp, #8]
 8002098:	9301      	str	r3, [sp, #4]
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 800209a:	9300      	str	r3, [sp, #0]
 800209c:	e781      	b.n	8001fa2 <HAL_TIM_PeriodElapsedCallback+0x2e6>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 800209e:	2101      	movs	r1, #1
 80020a0:	2300      	movs	r3, #0
 80020a2:	4608      	mov	r0, r1
 80020a4:	461a      	mov	r2, r3
 80020a6:	e9cd 1302 	strd	r1, r3, [sp, #8]
 80020aa:	e9cd 1100 	strd	r1, r1, [sp]
 80020ae:	f7ff fca3 	bl	80019f8 <show_custom_display_output>
            current_display_on_time_step++;
 80020b2:	6823      	ldr	r3, [r4, #0]
            if ((current_display_on_time_step>=display_on_time_steps) && (display_off_time_steps==0))
 80020b4:	682a      	ldr	r2, [r5, #0]
                        break;
 80020b6:	e737      	b.n	8001f28 <HAL_TIM_PeriodElapsedCallback+0x26c>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 80020b8:	2200      	movs	r2, #0
 80020ba:	2301      	movs	r3, #1
 80020bc:	e9cd 2202 	strd	r2, r2, [sp, #8]
 80020c0:	9301      	str	r3, [sp, #4]
 80020c2:	e7ae      	b.n	8002022 <HAL_TIM_PeriodElapsedCallback+0x366>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 80020c4:	2301      	movs	r3, #1
 80020c6:	2100      	movs	r1, #0
 80020c8:	e9cd 3102 	strd	r3, r1, [sp, #8]
 80020cc:	e79b      	b.n	8002006 <HAL_TIM_PeriodElapsedCallback+0x34a>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 80020ce:	2201      	movs	r2, #1
 80020d0:	2300      	movs	r3, #0
 80020d2:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80020d6:	e9cd 2300 	strd	r2, r3, [sp]
 80020da:	e71f      	b.n	8001f1c <HAL_TIM_PeriodElapsedCallback+0x260>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 80020dc:	2300      	movs	r3, #0
 80020de:	2201      	movs	r2, #1
 80020e0:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80020e4:	e9cd 3300 	strd	r3, r3, [sp]
 80020e8:	e718      	b.n	8001f1c <HAL_TIM_PeriodElapsedCallback+0x260>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 80020ea:	2201      	movs	r2, #1
 80020ec:	2300      	movs	r3, #0
 80020ee:	e9cd 2200 	strd	r2, r2, [sp]
 80020f2:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80020f6:	e711      	b.n	8001f1c <HAL_TIM_PeriodElapsedCallback+0x260>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 80020f8:	2000      	movs	r0, #0
 80020fa:	2301      	movs	r3, #1
 80020fc:	9001      	str	r0, [sp, #4]
 80020fe:	e9cd 3002 	strd	r3, r0, [sp, #8]
 8002102:	e7ca      	b.n	800209a <HAL_TIM_PeriodElapsedCallback+0x3de>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002104:	2301      	movs	r3, #1
 8002106:	2200      	movs	r2, #0
 8002108:	e9cd 3202 	strd	r3, r2, [sp, #8]
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET);
 800210c:	9201      	str	r2, [sp, #4]
 800210e:	e788      	b.n	8002022 <HAL_TIM_PeriodElapsedCallback+0x366>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002110:	2301      	movs	r3, #1
 8002112:	2100      	movs	r1, #0
 8002114:	9301      	str	r3, [sp, #4]
 8002116:	e9cd 3102 	strd	r3, r1, [sp, #8]
 800211a:	e775      	b.n	8002008 <HAL_TIM_PeriodElapsedCallback+0x34c>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 800211c:	2200      	movs	r2, #0
 800211e:	2301      	movs	r3, #1
 8002120:	e9cd 2202 	strd	r2, r2, [sp, #8]
 8002124:	e9cd 2200 	strd	r2, r2, [sp]
 8002128:	e77c      	b.n	8002024 <HAL_TIM_PeriodElapsedCallback+0x368>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 800212a:	2201      	movs	r2, #1
 800212c:	2300      	movs	r3, #0
 800212e:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8002132:	e7eb      	b.n	800210c <HAL_TIM_PeriodElapsedCallback+0x450>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002134:	2300      	movs	r3, #0
 8002136:	2201      	movs	r2, #1
 8002138:	9303      	str	r3, [sp, #12]
 800213a:	e742      	b.n	8001fc2 <HAL_TIM_PeriodElapsedCallback+0x306>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 800213c:	2300      	movs	r3, #0
 800213e:	2201      	movs	r2, #1
 8002140:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8002144:	9301      	str	r3, [sp, #4]
 8002146:	e76c      	b.n	8002022 <HAL_TIM_PeriodElapsedCallback+0x366>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002148:	2301      	movs	r3, #1
 800214a:	2100      	movs	r1, #0
 800214c:	e9cd 3300 	strd	r3, r3, [sp]
 8002150:	e9cd 3102 	strd	r3, r1, [sp, #8]
 8002154:	e718      	b.n	8001f88 <HAL_TIM_PeriodElapsedCallback+0x2cc>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET);
 8002156:	2301      	movs	r3, #1
 8002158:	e7c1      	b.n	80020de <HAL_TIM_PeriodElapsedCallback+0x422>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET);
 800215a:	2300      	movs	r3, #0
 800215c:	2201      	movs	r2, #1
 800215e:	9301      	str	r3, [sp, #4]
 8002160:	e9cd 3202 	strd	r3, r2, [sp, #8]
 8002164:	e75d      	b.n	8002022 <HAL_TIM_PeriodElapsedCallback+0x366>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET);
 8002166:	2301      	movs	r3, #1
 8002168:	2100      	movs	r1, #0
 800216a:	e9cd 3302 	strd	r3, r3, [sp, #8]
 800216e:	e9cd 3300 	strd	r3, r3, [sp]
 8002172:	e709      	b.n	8001f88 <HAL_TIM_PeriodElapsedCallback+0x2cc>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET);
 8002174:	2301      	movs	r3, #1
 8002176:	2100      	movs	r1, #0
 8002178:	9303      	str	r3, [sp, #12]
 800217a:	e702      	b.n	8001f82 <HAL_TIM_PeriodElapsedCallback+0x2c6>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET);
 800217c:	2201      	movs	r2, #1
 800217e:	2300      	movs	r3, #0
 8002180:	e9cd 2202 	strd	r2, r2, [sp, #8]
 8002184:	e7c2      	b.n	800210c <HAL_TIM_PeriodElapsedCallback+0x450>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002186:	2200      	movs	r2, #0
 8002188:	2301      	movs	r3, #1
 800218a:	e9cd 2200 	strd	r2, r2, [sp]
 800218e:	e9cd 3202 	strd	r3, r2, [sp, #8]
 8002192:	e6c2      	b.n	8001f1a <HAL_TIM_PeriodElapsedCallback+0x25e>
                        show_custom_display_output(GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 8002194:	2301      	movs	r3, #1
 8002196:	2200      	movs	r2, #0
 8002198:	e9cd 3202 	strd	r3, r2, [sp, #8]
 800219c:	e9cd 3200 	strd	r3, r2, [sp]
 80021a0:	e6bc      	b.n	8001f1c <HAL_TIM_PeriodElapsedCallback+0x260>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET);
 80021a2:	2300      	movs	r3, #0
 80021a4:	2201      	movs	r2, #1
 80021a6:	e9cd 3202 	strd	r3, r2, [sp, #8]
 80021aa:	e6b4      	b.n	8001f16 <HAL_TIM_PeriodElapsedCallback+0x25a>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);
 80021ac:	2300      	movs	r3, #0
 80021ae:	2201      	movs	r2, #1
 80021b0:	9303      	str	r3, [sp, #12]
 80021b2:	e6af      	b.n	8001f14 <HAL_TIM_PeriodElapsedCallback+0x258>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 80021b4:	2300      	movs	r3, #0
 80021b6:	2201      	movs	r2, #1
 80021b8:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80021bc:	9201      	str	r2, [sp, #4]
 80021be:	e6ab      	b.n	8001f18 <HAL_TIM_PeriodElapsedCallback+0x25c>
                        show_custom_display_output(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET);
 80021c0:	2300      	movs	r3, #0
 80021c2:	2101      	movs	r1, #1
 80021c4:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80021c8:	e9cd 3100 	strd	r3, r1, [sp]
 80021cc:	e6dc      	b.n	8001f88 <HAL_TIM_PeriodElapsedCallback+0x2cc>
    turn_off_all_5641as_display_terminals();
 80021ce:	f7ff fbbd 	bl	800194c <turn_off_all_5641as_display_terminals>
            current_display_off_time_step++;
 80021d2:	682b      	ldr	r3, [r5, #0]
}
 80021d4:	e689      	b.n	8001eea <HAL_TIM_PeriodElapsedCallback+0x22e>
 80021d6:	bf00      	nop
 80021d8:	20000034 	.word	0x20000034
 80021dc:	20000048 	.word	0x20000048
 80021e0:	2000003c 	.word	0x2000003c

080021e4 <etx_ota_send_resp.isra.0>:
static ETX_OTA_Status etx_ota_send_resp(ETX_OTA_Response_Status response_status)
{
	/** <b>Local variable ret:</b> Return value of a @ref ETX_OTA_Status function function type. */
	ETX_OTA_Status  ret;

	ETX_OTA_Response_Packet_t response =
 80021e4:	2300      	movs	r3, #0
static ETX_OTA_Status etx_ota_send_resp(ETX_OTA_Response_Status response_status)
 80021e6:	4684      	mov	ip, r0
	ETX_OTA_Response_Packet_t response =
 80021e8:	22bb      	movs	r2, #187	; 0xbb
static ETX_OTA_Status etx_ota_send_resp(ETX_OTA_Response_Status response_status)
 80021ea:	b500      	push	{lr}
	ETX_OTA_Response_Packet_t response =
 80021ec:	4816      	ldr	r0, [pc, #88]	; (8002248 <etx_ota_send_resp.isra.0+0x64>)
static ETX_OTA_Status etx_ota_send_resp(ETX_OTA_Response_Status response_status)
 80021ee:	b085      	sub	sp, #20
	ETX_OTA_Response_Packet_t response =
 80021f0:	9001      	str	r0, [sp, #4]
		.data_len    	= 1U,
		.status      	= response_status,
		.crc			= 0U,
		.eof         	= ETX_OTA_EOF
	};
	response.crc = crc32_mpeg2((uint8_t *) &response.status, 1);
 80021f2:	2101      	movs	r1, #1
 80021f4:	a802      	add	r0, sp, #8
	ETX_OTA_Response_Packet_t response =
 80021f6:	f88d 3009 	strb.w	r3, [sp, #9]
 80021fa:	f88d 300a 	strb.w	r3, [sp, #10]
 80021fe:	f88d 300b 	strb.w	r3, [sp, #11]
 8002202:	f88d 300c 	strb.w	r3, [sp, #12]
 8002206:	f88d c008 	strb.w	ip, [sp, #8]
 800220a:	f88d 200d 	strb.w	r2, [sp, #13]
	response.crc = crc32_mpeg2((uint8_t *) &response.status, 1);
 800220e:	f000 fb17 	bl	8002840 <crc32_mpeg2>

	switch (ETX_OTA_hardware_protocol)
 8002212:	4b0e      	ldr	r3, [pc, #56]	; (800224c <etx_ota_send_resp.isra.0+0x68>)
	response.crc = crc32_mpeg2((uint8_t *) &response.status, 1);
 8002214:	f8cd 0009 	str.w	r0, [sp, #9]
	switch (ETX_OTA_hardware_protocol)
 8002218:	781b      	ldrb	r3, [r3, #0]
 800221a:	b153      	cbz	r3, 8002232 <etx_ota_send_resp.isra.0+0x4e>
 800221c:	2b01      	cmp	r3, #1
 800221e:	d105      	bne.n	800222c <etx_ota_send_resp.isra.0+0x48>
		case ETX_OTA_hw_Protocol_UART:
			ret = HAL_UART_Transmit(p_huart, (uint8_t *) &response, sizeof(ETX_OTA_Response_Packet_t), ETX_CUSTOM_HAL_TIMEOUT);
			ret = HAL_ret_handler(ret);
			break;
		case ETX_OTA_hw_Protocol_BT:
			ret = send_hm10_ota_data((uint8_t *) &response, sizeof(ETX_OTA_Response_Packet_t), ETX_CUSTOM_HAL_TIMEOUT);
 8002220:	f242 3228 	movw	r2, #9000	; 0x2328
 8002224:	210a      	movs	r1, #10
 8002226:	a801      	add	r0, sp, #4
 8002228:	f001 f8c4 	bl	80033b4 <send_hm10_ota_data>
			#endif
			return ETX_OTA_EC_ERR;
	}

	return ret;
}
 800222c:	b005      	add	sp, #20
 800222e:	f85d fb04 	ldr.w	pc, [sp], #4
			ret = HAL_UART_Transmit(p_huart, (uint8_t *) &response, sizeof(ETX_OTA_Response_Packet_t), ETX_CUSTOM_HAL_TIMEOUT);
 8002232:	4807      	ldr	r0, [pc, #28]	; (8002250 <etx_ota_send_resp.isra.0+0x6c>)
 8002234:	f242 3328 	movw	r3, #9000	; 0x2328
 8002238:	220a      	movs	r2, #10
 800223a:	a901      	add	r1, sp, #4
 800223c:	6800      	ldr	r0, [r0, #0]
 800223e:	f002 ffa1 	bl	8005184 <HAL_UART_Transmit>
}
 8002242:	b005      	add	sp, #20
 8002244:	f85d fb04 	ldr.w	pc, [sp], #4
 8002248:	000103aa 	.word	0x000103aa
 800224c:	20000058 	.word	0x20000058
 8002250:	20000480 	.word	0x20000480

08002254 <init_firmware_update_module>:
{
 8002254:	b570      	push	{r4, r5, r6, lr}
    ETX_OTA_hardware_protocol = hardware_protocol;
 8002256:	4c26      	ldr	r4, [pc, #152]	; (80022f0 <init_firmware_update_module+0x9c>)
    p_huart = huart;
 8002258:	4d26      	ldr	r5, [pc, #152]	; (80022f4 <init_firmware_update_module+0xa0>)
    ETX_OTA_hardware_protocol = hardware_protocol;
 800225a:	7020      	strb	r0, [r4, #0]
    p_fw_config = fw_config;
 800225c:	4e26      	ldr	r6, [pc, #152]	; (80022f8 <init_firmware_update_module+0xa4>)
    p_GPIO_is_hm10_default_settings = GPIO_is_hm10_default_settings_Pin;
 800225e:	4c27      	ldr	r4, [pc, #156]	; (80022fc <init_firmware_update_module+0xa8>)
{
 8002260:	b086      	sub	sp, #24
    p_fw_config = fw_config;
 8002262:	6032      	str	r2, [r6, #0]
    p_huart = huart;
 8002264:	6029      	str	r1, [r5, #0]
    p_GPIO_is_hm10_default_settings = GPIO_is_hm10_default_settings_Pin;
 8002266:	6023      	str	r3, [r4, #0]
    switch (hardware_protocol)
 8002268:	b158      	cbz	r0, 8002282 <init_firmware_update_module+0x2e>
 800226a:	2801      	cmp	r0, #1
 800226c:	d10f      	bne.n	800228e <init_firmware_update_module+0x3a>
            init_hm10_module(p_huart);
 800226e:	4608      	mov	r0, r1
 8002270:	f000 fc50 	bl	8002b14 <init_hm10_module>
            if (HAL_GPIO_ReadPin(p_GPIO_is_hm10_default_settings->GPIO_Port, p_GPIO_is_hm10_default_settings->GPIO_Pin) == GPIO_PIN_SET)
 8002274:	6823      	ldr	r3, [r4, #0]
 8002276:	8899      	ldrh	r1, [r3, #4]
 8002278:	6818      	ldr	r0, [r3, #0]
 800227a:	f002 f87d 	bl	8004378 <HAL_GPIO_ReadPin>
 800227e:	2801      	cmp	r0, #1
 8002280:	d002      	beq.n	8002288 <init_firmware_update_module+0x34>
    return ETX_OTA_EC_OK;
 8002282:	2000      	movs	r0, #0
}
 8002284:	b006      	add	sp, #24
 8002286:	bd70      	pop	{r4, r5, r6, pc}
				ret = disconnect_hm10_from_bt_address();
 8002288:	f001 f834 	bl	80032f4 <disconnect_hm10_from_bt_address>
				if (ret == HM10_BT_Connection_Status_Unknown)
 800228c:	b910      	cbnz	r0, 8002294 <init_firmware_update_module+0x40>
            return ETX_OTA_EC_ERR;
 800228e:	2004      	movs	r0, #4
}
 8002290:	b006      	add	sp, #24
 8002292:	bd70      	pop	{r4, r5, r6, pc}
                ret = send_hm10_renew_cmd();
 8002294:	f000 fca0 	bl	8002bd8 <send_hm10_renew_cmd>
                if (ret != HM10_EC_OK)
 8002298:	2800      	cmp	r0, #0
 800229a:	d1f8      	bne.n	800228e <init_firmware_update_module+0x3a>
                uint8_t default_ble_name[] = {HM10_DEFAULT_BLE_NAME};
 800229c:	4a18      	ldr	r2, [pc, #96]	; (8002300 <init_firmware_update_module+0xac>)
 800229e:	ab03      	add	r3, sp, #12
 80022a0:	ca07      	ldmia	r2, {r0, r1, r2}
 80022a2:	c303      	stmia	r3!, {r0, r1}
                ret = set_hm10_name(default_ble_name, sizeof(default_ble_name));
 80022a4:	2109      	movs	r1, #9
 80022a6:	a803      	add	r0, sp, #12
                uint8_t default_ble_name[] = {HM10_DEFAULT_BLE_NAME};
 80022a8:	701a      	strb	r2, [r3, #0]
                ret = set_hm10_name(default_ble_name, sizeof(default_ble_name));
 80022aa:	f000 fcf1 	bl	8002c90 <set_hm10_name>
                if (ret != HM10_EC_OK)
 80022ae:	2800      	cmp	r0, #0
 80022b0:	d1ed      	bne.n	800228e <init_firmware_update_module+0x3a>
                ret = set_hm10_role(HM10_DEFAULT_ROLE);
 80022b2:	2030      	movs	r0, #48	; 0x30
 80022b4:	f000 fe30 	bl	8002f18 <set_hm10_role>
                if (ret != HM10_EC_OK)
 80022b8:	2800      	cmp	r0, #0
 80022ba:	d1e8      	bne.n	800228e <init_firmware_update_module+0x3a>
                uint8_t default_pin_code[HM10_PIN_VALUE_SIZE] = {HM10_DEFAULT_PIN};
 80022bc:	4b11      	ldr	r3, [pc, #68]	; (8002304 <init_firmware_update_module+0xb0>)
 80022be:	e893 0003 	ldmia.w	r3, {r0, r1}
 80022c2:	9001      	str	r0, [sp, #4]
                ret = set_hm10_pin(default_pin_code);
 80022c4:	a801      	add	r0, sp, #4
                uint8_t default_pin_code[HM10_PIN_VALUE_SIZE] = {HM10_DEFAULT_PIN};
 80022c6:	f8ad 1008 	strh.w	r1, [sp, #8]
                ret = set_hm10_pin(default_pin_code);
 80022ca:	f000 fe91 	bl	8002ff0 <set_hm10_pin>
                if (ret != HM10_EC_OK)
 80022ce:	2800      	cmp	r0, #0
 80022d0:	d1dd      	bne.n	800228e <init_firmware_update_module+0x3a>
                ret = set_hm10_pin_code_mode(HM10_DEFAULT_PIN_CODE_MODE);
 80022d2:	2030      	movs	r0, #48	; 0x30
 80022d4:	f000 ff36 	bl	8003144 <set_hm10_pin_code_mode>
                if (ret != HM10_EC_OK)
 80022d8:	2800      	cmp	r0, #0
 80022da:	d1d8      	bne.n	800228e <init_firmware_update_module+0x3a>
                ret = set_hm10_module_work_mode(HM10_DEFAULT_MODULE_WORK_MODE);
 80022dc:	2030      	movs	r0, #48	; 0x30
 80022de:	f000 ff9d 	bl	800321c <set_hm10_module_work_mode>
                if (ret != HM10_EC_OK)
 80022e2:	2800      	cmp	r0, #0
 80022e4:	d1d3      	bne.n	800228e <init_firmware_update_module+0x3a>
                ret = send_hm10_reset_cmd();
 80022e6:	f000 fc1b 	bl	8002b20 <send_hm10_reset_cmd>
                if (ret != HM10_EC_OK)
 80022ea:	2800      	cmp	r0, #0
 80022ec:	d0ca      	beq.n	8002284 <init_firmware_update_module+0x30>
 80022ee:	e7ce      	b.n	800228e <init_firmware_update_module+0x3a>
 80022f0:	20000058 	.word	0x20000058
 80022f4:	20000480 	.word	0x20000480
 80022f8:	2000047c 	.word	0x2000047c
 80022fc:	20000478 	.word	0x20000478
 8002300:	08005464 	.word	0x08005464
 8002304:	08005470 	.word	0x08005470

08002308 <firmware_image_download_and_install>:
	etx_ota_state            = ETX_OTA_STATE_START;
 8002308:	2301      	movs	r3, #1
	etx_ota_fw_received_size = 0U;
 800230a:	2200      	movs	r2, #0
{
 800230c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	etx_ota_fw_received_size = 0U;
 8002310:	4fa2      	ldr	r7, [pc, #648]	; (800259c <firmware_image_download_and_install+0x294>)
	etx_ota_state            = ETX_OTA_STATE_START;
 8002312:	4da3      	ldr	r5, [pc, #652]	; (80025a0 <firmware_image_download_and_install+0x298>)
			ret = HAL_UART_Receive(p_huart, &buf[len], ETX_OTA_SOF_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 8002314:	4ca3      	ldr	r4, [pc, #652]	; (80025a4 <firmware_image_download_and_install+0x29c>)
 8002316:	4ea4      	ldr	r6, [pc, #656]	; (80025a8 <firmware_image_download_and_install+0x2a0>)
 8002318:	f8df 8290 	ldr.w	r8, [pc, #656]	; 80025ac <firmware_image_download_and_install+0x2a4>
{
 800231c:	b089      	sub	sp, #36	; 0x24
			ret = HAL_UART_Receive(p_huart, &buf[len], ETX_OTA_PACKET_TYPE_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 800231e:	eb04 0903 	add.w	r9, r4, r3
	etx_ota_fw_received_size = 0U;
 8002322:	603a      	str	r2, [r7, #0]
	etx_ota_state            = ETX_OTA_STATE_START;
 8002324:	702b      	strb	r3, [r5, #0]
	switch (ETX_OTA_hardware_protocol)
 8002326:	f896 a000 	ldrb.w	sl, [r6]
 800232a:	f1ba 0f00 	cmp.w	sl, #0
 800232e:	d00b      	beq.n	8002348 <firmware_image_download_and_install+0x40>
 8002330:	f1ba 0f01 	cmp.w	sl, #1
 8002334:	d01c      	beq.n	8002370 <firmware_image_download_and_install+0x68>
				  etx_ota_send_resp(ETX_OTA_NACK);
 8002336:	2001      	movs	r0, #1
 8002338:	f7ff ff54 	bl	80021e4 <etx_ota_send_resp.isra.0>
				  return ETX_OTA_EC_ERR;
 800233c:	f04f 0b04 	mov.w	fp, #4
}
 8002340:	4658      	mov	r0, fp
 8002342:	b009      	add	sp, #36	; 0x24
 8002344:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ret = HAL_UART_Receive(p_huart, &buf[len], ETX_OTA_SOF_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 8002348:	f242 3328 	movw	r3, #9000	; 0x2328
 800234c:	2201      	movs	r2, #1
 800234e:	4995      	ldr	r1, [pc, #596]	; (80025a4 <firmware_image_download_and_install+0x29c>)
 8002350:	f8d8 0000 	ldr.w	r0, [r8]
 8002354:	f002 ffb8 	bl	80052c8 <HAL_UART_Receive>
	return ret;
}

static ETX_OTA_Status HAL_ret_handler(HAL_StatusTypeDef HAL_status)
{
  switch (HAL_status)
 8002358:	2801      	cmp	r0, #1
 800235a:	d0ec      	beq.n	8002336 <firmware_image_download_and_install+0x2e>
 800235c:	1e83      	subs	r3, r0, #2
 800235e:	b2db      	uxtb	r3, r3
 8002360:	2b01      	cmp	r3, #1
 8002362:	d848      	bhi.n	80023f6 <firmware_image_download_and_install+0xee>
			  return ETX_OTA_EC_NR;
 8002364:	f04f 0b02 	mov.w	fp, #2
}
 8002368:	4658      	mov	r0, fp
 800236a:	b009      	add	sp, #36	; 0x24
 800236c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ret = get_hm10_ota_data(&buf[len], ETX_OTA_SOF_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 8002370:	f242 3228 	movw	r2, #9000	; 0x2328
 8002374:	4651      	mov	r1, sl
 8002376:	488b      	ldr	r0, [pc, #556]	; (80025a4 <firmware_image_download_and_install+0x29c>)
 8002378:	f001 f832 	bl	80033e0 <get_hm10_ota_data>
			if (ret != HAL_OK)
 800237c:	bb70      	cbnz	r0, 80023dc <firmware_image_download_and_install+0xd4>
			if (buf[len++] != ETX_OTA_SOF)
 800237e:	7823      	ldrb	r3, [r4, #0]
 8002380:	2baa      	cmp	r3, #170	; 0xaa
 8002382:	d1d8      	bne.n	8002336 <firmware_image_download_and_install+0x2e>
			ret = get_hm10_ota_data(&buf[len], ETX_OTA_PACKET_TYPE_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 8002384:	4651      	mov	r1, sl
 8002386:	f242 3228 	movw	r2, #9000	; 0x2328
 800238a:	4648      	mov	r0, r9
 800238c:	f001 f828 	bl	80033e0 <get_hm10_ota_data>
			if (ret != HAL_OK)
 8002390:	bb20      	cbnz	r0, 80023dc <firmware_image_download_and_install+0xd4>
			switch (buf[len++])
 8002392:	7863      	ldrb	r3, [r4, #1]
 8002394:	2b03      	cmp	r3, #3
 8002396:	d8ce      	bhi.n	8002336 <firmware_image_download_and_install+0x2e>
			ret = get_hm10_ota_data(&buf[len], ETX_OTA_DATA_LENGTH_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 8002398:	f242 3228 	movw	r2, #9000	; 0x2328
 800239c:	2102      	movs	r1, #2
 800239e:	4884      	ldr	r0, [pc, #528]	; (80025b0 <firmware_image_download_and_install+0x2a8>)
 80023a0:	f001 f81e 	bl	80033e0 <get_hm10_ota_data>
			if (ret != HAL_OK)
 80023a4:	b9d0      	cbnz	r0, 80023dc <firmware_image_download_and_install+0xd4>
			data_len = *(uint16_t *)&buf[len];
 80023a6:	8863      	ldrh	r3, [r4, #2]
 80023a8:	9300      	str	r3, [sp, #0]
			for (uint16_t i=0; i<data_len; i++)
 80023aa:	2b00      	cmp	r3, #0
 80023ac:	f000 81e2 	beq.w	8002774 <firmware_image_download_and_install+0x46c>
			len += ETX_OTA_DATA_LENGTH_SIZE;
 80023b0:	f04f 0b04 	mov.w	fp, #4
 80023b4:	eb03 0a0b 	add.w	sl, r3, fp
 80023b8:	fa1f fa8a 	uxth.w	sl, sl
 80023bc:	e002      	b.n	80023c4 <firmware_image_download_and_install+0xbc>
			for (uint16_t i=0; i<data_len; i++)
 80023be:	45d3      	cmp	fp, sl
 80023c0:	f000 8093 	beq.w	80024ea <firmware_image_download_and_install+0x1e2>
				ret = get_hm10_ota_data(&buf[len++], 1, ETX_CUSTOM_HAL_TIMEOUT);
 80023c4:	4658      	mov	r0, fp
 80023c6:	2101      	movs	r1, #1
 80023c8:	f242 3228 	movw	r2, #9000	; 0x2328
 80023cc:	448b      	add	fp, r1
 80023ce:	4420      	add	r0, r4
 80023d0:	fa1f fb8b 	uxth.w	fp, fp
 80023d4:	f001 f804 	bl	80033e0 <get_hm10_ota_data>
				if (ret != HAL_OK)
 80023d8:	2800      	cmp	r0, #0
 80023da:	d0f0      	beq.n	80023be <firmware_image_download_and_install+0xb6>
		switch (ret)
 80023dc:	2802      	cmp	r0, #2
 80023de:	4683      	mov	fp, r0
 80023e0:	d0c0      	beq.n	8002364 <firmware_image_download_and_install+0x5c>
 80023e2:	f1bb 0f04 	cmp.w	fp, #4
 80023e6:	d0a6      	beq.n	8002336 <firmware_image_download_and_install+0x2e>
			  etx_ota_send_resp(ETX_OTA_NACK);
 80023e8:	2001      	movs	r0, #1
 80023ea:	f7ff fefb 	bl	80021e4 <etx_ota_send_resp.isra.0>
}
 80023ee:	4658      	mov	r0, fp
 80023f0:	b009      	add	sp, #36	; 0x24
 80023f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (ret != HAL_OK)
 80023f6:	2800      	cmp	r0, #0
 80023f8:	d175      	bne.n	80024e6 <firmware_image_download_and_install+0x1de>
			if (buf[len++] != ETX_OTA_SOF)
 80023fa:	7823      	ldrb	r3, [r4, #0]
 80023fc:	2baa      	cmp	r3, #170	; 0xaa
 80023fe:	d19a      	bne.n	8002336 <firmware_image_download_and_install+0x2e>
			ret = HAL_UART_Receive(p_huart, &buf[len], ETX_OTA_PACKET_TYPE_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 8002400:	f242 3328 	movw	r3, #9000	; 0x2328
 8002404:	2201      	movs	r2, #1
 8002406:	4649      	mov	r1, r9
 8002408:	f8d8 0000 	ldr.w	r0, [r8]
 800240c:	f002 ff5c 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 8002410:	2801      	cmp	r0, #1
 8002412:	d090      	beq.n	8002336 <firmware_image_download_and_install+0x2e>
 8002414:	1e83      	subs	r3, r0, #2
 8002416:	b2db      	uxtb	r3, r3
 8002418:	2b01      	cmp	r3, #1
 800241a:	d9a3      	bls.n	8002364 <firmware_image_download_and_install+0x5c>
			if (ret != HAL_OK)
 800241c:	2800      	cmp	r0, #0
 800241e:	d162      	bne.n	80024e6 <firmware_image_download_and_install+0x1de>
			switch (buf[len++])
 8002420:	7863      	ldrb	r3, [r4, #1]
 8002422:	2b03      	cmp	r3, #3
 8002424:	d887      	bhi.n	8002336 <firmware_image_download_and_install+0x2e>
			ret = HAL_UART_Receive(p_huart, &buf[len], ETX_OTA_DATA_LENGTH_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 8002426:	f242 3328 	movw	r3, #9000	; 0x2328
 800242a:	2202      	movs	r2, #2
 800242c:	4960      	ldr	r1, [pc, #384]	; (80025b0 <firmware_image_download_and_install+0x2a8>)
 800242e:	f8d8 0000 	ldr.w	r0, [r8]
 8002432:	f002 ff49 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 8002436:	2801      	cmp	r0, #1
 8002438:	f43f af7d 	beq.w	8002336 <firmware_image_download_and_install+0x2e>
 800243c:	1e83      	subs	r3, r0, #2
 800243e:	b2db      	uxtb	r3, r3
 8002440:	2b01      	cmp	r3, #1
 8002442:	d98f      	bls.n	8002364 <firmware_image_download_and_install+0x5c>
			if (ret != HAL_OK)
 8002444:	2800      	cmp	r0, #0
 8002446:	d14e      	bne.n	80024e6 <firmware_image_download_and_install+0x1de>
			data_len = *(uint16_t *)&buf[len];
 8002448:	8863      	ldrh	r3, [r4, #2]
 800244a:	9300      	str	r3, [sp, #0]
			for (uint16_t i=0; i<data_len; i++)
 800244c:	2b00      	cmp	r3, #0
 800244e:	f000 81e7 	beq.w	8002820 <firmware_image_download_and_install+0x518>
			len += ETX_OTA_DATA_LENGTH_SIZE;
 8002452:	f04f 0a04 	mov.w	sl, #4
 8002456:	4453      	add	r3, sl
 8002458:	fa1f fb83 	uxth.w	fp, r3
				ret = HAL_UART_Receive(p_huart, &buf[len++], 1, ETX_CUSTOM_HAL_TIMEOUT);
 800245c:	2201      	movs	r2, #1
 800245e:	f242 3328 	movw	r3, #9000	; 0x2328
 8002462:	f8d8 0000 	ldr.w	r0, [r8]
 8002466:	eb04 010a 	add.w	r1, r4, sl
 800246a:	f002 ff2d 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 800246e:	1e82      	subs	r2, r0, #2
 8002470:	2801      	cmp	r0, #1
 8002472:	b2d2      	uxtb	r2, r2
 8002474:	f43f af5f 	beq.w	8002336 <firmware_image_download_and_install+0x2e>
 8002478:	2a01      	cmp	r2, #1
 800247a:	f67f af73 	bls.w	8002364 <firmware_image_download_and_install+0x5c>
				ret = HAL_UART_Receive(p_huart, &buf[len++], 1, ETX_CUSTOM_HAL_TIMEOUT);
 800247e:	f10a 0a01 	add.w	sl, sl, #1
 8002482:	fa1f fa8a 	uxth.w	sl, sl
				if (ret != HAL_OK)
 8002486:	bb70      	cbnz	r0, 80024e6 <firmware_image_download_and_install+0x1de>
			for (uint16_t i=0; i<data_len; i++)
 8002488:	45da      	cmp	sl, fp
 800248a:	d1e7      	bne.n	800245c <firmware_image_download_and_install+0x154>
			ret = HAL_UART_Receive(p_huart, &buf[len], ETX_OTA_CRC32_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 800248c:	eb04 0a0b 	add.w	sl, r4, fp
 8002490:	f242 3328 	movw	r3, #9000	; 0x2328
 8002494:	2204      	movs	r2, #4
 8002496:	4651      	mov	r1, sl
 8002498:	f8d8 0000 	ldr.w	r0, [r8]
 800249c:	f002 ff14 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 80024a0:	2801      	cmp	r0, #1
 80024a2:	f43f af48 	beq.w	8002336 <firmware_image_download_and_install+0x2e>
 80024a6:	1e83      	subs	r3, r0, #2
 80024a8:	b2db      	uxtb	r3, r3
 80024aa:	2b01      	cmp	r3, #1
 80024ac:	f67f af5a 	bls.w	8002364 <firmware_image_download_and_install+0x5c>
			if (ret != HAL_OK)
 80024b0:	b9c8      	cbnz	r0, 80024e6 <firmware_image_download_and_install+0x1de>
			len += ETX_OTA_CRC32_SIZE;
 80024b2:	f10b 0304 	add.w	r3, fp, #4
			rec_data_crc = *(uint32_t *) &buf[len];
 80024b6:	f8da 2000 	ldr.w	r2, [sl]
			len += ETX_OTA_CRC32_SIZE;
 80024ba:	b29b      	uxth	r3, r3
			ret = HAL_UART_Receive(p_huart, &buf[len], ETX_OTA_EOF_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 80024bc:	eb04 0a03 	add.w	sl, r4, r3
			len += ETX_OTA_CRC32_SIZE;
 80024c0:	9301      	str	r3, [sp, #4]
			rec_data_crc = *(uint32_t *) &buf[len];
 80024c2:	4693      	mov	fp, r2
			ret = HAL_UART_Receive(p_huart, &buf[len], ETX_OTA_EOF_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 80024c4:	f242 3328 	movw	r3, #9000	; 0x2328
 80024c8:	2201      	movs	r2, #1
 80024ca:	4651      	mov	r1, sl
 80024cc:	f8d8 0000 	ldr.w	r0, [r8]
 80024d0:	f002 fefa 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 80024d4:	2801      	cmp	r0, #1
 80024d6:	f43f af2e 	beq.w	8002336 <firmware_image_download_and_install+0x2e>
 80024da:	1e83      	subs	r3, r0, #2
 80024dc:	b2db      	uxtb	r3, r3
 80024de:	2b01      	cmp	r3, #1
 80024e0:	f67f af40 	bls.w	8002364 <firmware_image_download_and_install+0x5c>
			if (ret != HAL_OK)
 80024e4:	b1f0      	cbz	r0, 8002524 <firmware_image_download_and_install+0x21c>
 80024e6:	4683      	mov	fp, r0
 80024e8:	e77b      	b.n	80023e2 <firmware_image_download_and_install+0xda>
			ret = get_hm10_ota_data(&buf[len], ETX_OTA_CRC32_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 80024ea:	46da      	mov	sl, fp
 80024ec:	f242 3228 	movw	r2, #9000	; 0x2328
 80024f0:	2104      	movs	r1, #4
 80024f2:	eb04 000a 	add.w	r0, r4, sl
 80024f6:	f000 ff73 	bl	80033e0 <get_hm10_ota_data>
			if (ret != HAL_OK)
 80024fa:	2800      	cmp	r0, #0
 80024fc:	f47f af6e 	bne.w	80023dc <firmware_image_download_and_install+0xd4>
			len += ETX_OTA_CRC32_SIZE;
 8002500:	f10b 0304 	add.w	r3, fp, #4
			rec_data_crc = *(uint32_t *) &buf[len];
 8002504:	f854 200a 	ldr.w	r2, [r4, sl]
			len += ETX_OTA_CRC32_SIZE;
 8002508:	b29b      	uxth	r3, r3
			ret = get_hm10_ota_data(&buf[len], ETX_OTA_EOF_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 800250a:	eb04 0a03 	add.w	sl, r4, r3
			rec_data_crc = *(uint32_t *) &buf[len];
 800250e:	4693      	mov	fp, r2
			ret = get_hm10_ota_data(&buf[len], ETX_OTA_EOF_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 8002510:	2101      	movs	r1, #1
 8002512:	f242 3228 	movw	r2, #9000	; 0x2328
 8002516:	4650      	mov	r0, sl
			len += ETX_OTA_CRC32_SIZE;
 8002518:	9301      	str	r3, [sp, #4]
			ret = get_hm10_ota_data(&buf[len], ETX_OTA_EOF_SIZE, ETX_CUSTOM_HAL_TIMEOUT);
 800251a:	f000 ff61 	bl	80033e0 <get_hm10_ota_data>
			if (ret != HAL_OK)
 800251e:	2800      	cmp	r0, #0
 8002520:	f47f af5c 	bne.w	80023dc <firmware_image_download_and_install+0xd4>
	if (buf[len++] != ETX_OTA_EOF)
 8002524:	f89a 3000 	ldrb.w	r3, [sl]
 8002528:	2bbb      	cmp	r3, #187	; 0xbb
 800252a:	f47f af04 	bne.w	8002336 <firmware_image_download_and_install+0x2e>
	cal_data_crc = crc32_mpeg2(&buf[ETX_OTA_DATA_FIELD_INDEX], data_len);
 800252e:	9900      	ldr	r1, [sp, #0]
 8002530:	4820      	ldr	r0, [pc, #128]	; (80025b4 <firmware_image_download_and_install+0x2ac>)
 8002532:	f000 f985 	bl	8002840 <crc32_mpeg2>
	if (cal_data_crc != rec_data_crc)
 8002536:	4558      	cmp	r0, fp
 8002538:	f47f aefd 	bne.w	8002336 <firmware_image_download_and_install+0x2e>
	if (max_len < len)
 800253c:	f240 4209 	movw	r2, #1033	; 0x409
	if (buf[len++] != ETX_OTA_EOF)
 8002540:	9b01      	ldr	r3, [sp, #4]
 8002542:	3301      	adds	r3, #1
	if (max_len < len)
 8002544:	b29b      	uxth	r3, r3
 8002546:	4293      	cmp	r3, r2
 8002548:	f63f aef5 	bhi.w	8002336 <firmware_image_download_and_install+0x2e>
	if (cmd->packet_type == ETX_OTA_PACKET_TYPE_CMD)
 800254c:	7863      	ldrb	r3, [r4, #1]
 800254e:	2b00      	cmp	r3, #0
 8002550:	f040 80b7 	bne.w	80026c2 <firmware_image_download_and_install+0x3ba>
		if (cmd->cmd == ETX_OTA_CMD_ABORT)
 8002554:	7921      	ldrb	r1, [r4, #4]
 8002556:	2902      	cmp	r1, #2
 8002558:	f000 80c4 	beq.w	80026e4 <firmware_image_download_and_install+0x3dc>
	switch (etx_ota_state)
 800255c:	782a      	ldrb	r2, [r5, #0]
 800255e:	2a04      	cmp	r2, #4
 8002560:	f63f aee9 	bhi.w	8002336 <firmware_image_download_and_install+0x2e>
 8002564:	e8df f002 	tbb	[pc, r2]
 8002568:	2c860310 	.word	0x2c860310
 800256c:	97          	.byte	0x97
 800256d:	00          	.byte	0x00
			if ((cmd->packet_type==ETX_OTA_PACKET_TYPE_CMD) && (cmd->cmd == ETX_OTA_CMD_START))
 800256e:	2900      	cmp	r1, #0
 8002570:	f47f aee1 	bne.w	8002336 <firmware_image_download_and_install+0x2e>
				etx_ota_state = ETX_OTA_STATE_HEADER;
 8002574:	2302      	movs	r3, #2
 8002576:	702b      	strb	r3, [r5, #0]
				display_output[0] = 'E';
 8002578:	f44f 03a6 	mov.w	r3, #5439488	; 0x530000
 800257c:	480e      	ldr	r0, [pc, #56]	; (80025b8 <firmware_image_download_and_install+0x2b0>)
 800257e:	6043      	str	r3, [r0, #4]
 8002580:	4b0e      	ldr	r3, [pc, #56]	; (80025bc <firmware_image_download_and_install+0x2b4>)
 8002582:	6003      	str	r3, [r0, #0]
				set_5641as_display_output(display_output);
 8002584:	f7ff fad0 	bl	8001b28 <set_5641as_display_output>
				  etx_ota_send_resp(ETX_OTA_ACK);
 8002588:	2000      	movs	r0, #0
 800258a:	f7ff fe2b 	bl	80021e4 <etx_ota_send_resp.isra.0>
	while (etx_ota_state != ETX_OTA_STATE_IDLE);
 800258e:	7828      	ldrb	r0, [r5, #0]
 8002590:	2800      	cmp	r0, #0
 8002592:	f47f aec8 	bne.w	8002326 <firmware_image_download_and_install+0x1e>
 8002596:	4683      	mov	fp, r0
 8002598:	e6d2      	b.n	8002340 <firmware_image_download_and_install+0x38>
 800259a:	bf00      	nop
 800259c:	20000470 	.word	0x20000470
 80025a0:	20000474 	.word	0x20000474
 80025a4:	2000005c 	.word	0x2000005c
 80025a8:	20000058 	.word	0x20000058
 80025ac:	20000480 	.word	0x20000480
 80025b0:	2000005e 	.word	0x2000005e
 80025b4:	20000060 	.word	0x20000060
 80025b8:	20000468 	.word	0x20000468
 80025bc:	004f0045 	.word	0x004f0045
			if (data->packet_type == ETX_OTA_PACKET_TYPE_DATA)
 80025c0:	2b01      	cmp	r3, #1
 80025c2:	f47f aeb8 	bne.w	8002336 <firmware_image_download_and_install+0x2e>
				stop_5641as_display_module();
 80025c6:	9300      	str	r3, [sp, #0]
 80025c8:	f7ff faa8 	bl	8001b1c <stop_5641as_display_module>
				if ((data->data_len)%4 != 0)
 80025cc:	f8b4 a002 	ldrh.w	sl, [r4, #2]
 80025d0:	f01a 0b03 	ands.w	fp, sl, #3
 80025d4:	f47f aeaf 	bne.w	8002336 <firmware_image_download_and_install+0x2e>
				data_ret = write_data_to_flash_app(buf+ETX_OTA_DATA_FIELD_INDEX, data->data_len, etx_ota_fw_received_size==0);
 80025d8:	683b      	ldr	r3, [r7, #0]
 80025da:	9301      	str	r3, [sp, #4]
	ret = HAL_FLASH_Unlock();
 80025dc:	f001 fbe6 	bl	8003dac <HAL_FLASH_Unlock>
  switch (HAL_status)
 80025e0:	2801      	cmp	r0, #1
 80025e2:	f43f aea8 	beq.w	8002336 <firmware_image_download_and_install+0x2e>
 80025e6:	1e82      	subs	r2, r0, #2
 80025e8:	b2d2      	uxtb	r2, r2
 80025ea:	2a01      	cmp	r2, #1
 80025ec:	9b00      	ldr	r3, [sp, #0]
 80025ee:	f67f aea5 	bls.w	800233c <firmware_image_download_and_install+0x34>
	if(ret != HAL_OK)
 80025f2:	2800      	cmp	r0, #0
 80025f4:	f040 80ac 	bne.w	8002750 <firmware_image_download_and_install+0x448>
	if (is_first_block)
 80025f8:	9a01      	ldr	r2, [sp, #4]
 80025fa:	2a00      	cmp	r2, #0
 80025fc:	f000 80be 	beq.w	800277c <firmware_image_download_and_install+0x474>
	uint8_t word_data[4] = {0xFF, 0xFF, 0xFF, 0xFF};
 8002600:	f04f 33ff 	mov.w	r3, #4294967295
	if (data_len > 4)
 8002604:	f1ba 0f04 	cmp.w	sl, #4
	uint8_t word_data[4] = {0xFF, 0xFF, 0xFF, 0xFF};
 8002608:	9304      	str	r3, [sp, #16]
	if (data_len > 4)
 800260a:	f240 80ce 	bls.w	80027aa <firmware_image_download_and_install+0x4a2>
	uint16_t data_len_minus_one_word = data_len - 4;
 800260e:	f1aa 0304 	sub.w	r3, sl, #4
 8002612:	b29b      	uxth	r3, r3
 8002614:	9300      	str	r3, [sp, #0]
			ret = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
 8002616:	6839      	ldr	r1, [r7, #0]
									p_data[bytes_flashed/4]);
 8002618:	ea4f 039b 	mov.w	r3, fp, lsr #2
 800261c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
			ret = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
 8002620:	f101 6100 	add.w	r1, r1, #134217728	; 0x8000000
 8002624:	685a      	ldr	r2, [r3, #4]
 8002626:	2002      	movs	r0, #2
 8002628:	2300      	movs	r3, #0
 800262a:	f501 4100 	add.w	r1, r1, #32768	; 0x8000
 800262e:	f001 fbe3 	bl	8003df8 <HAL_FLASH_Program>
  switch (HAL_status)
 8002632:	1e82      	subs	r2, r0, #2
 8002634:	2801      	cmp	r0, #1
 8002636:	b2d2      	uxtb	r2, r2
 8002638:	f43f ae7d 	beq.w	8002336 <firmware_image_download_and_install+0x2e>
 800263c:	2a01      	cmp	r2, #1
 800263e:	f67f ae7d 	bls.w	800233c <firmware_image_download_and_install+0x34>
		for ( ; bytes_flashed<data_len_minus_one_word; bytes_flashed+=4)
 8002642:	f10b 0b04 	add.w	fp, fp, #4
 8002646:	fa1f fb8b 	uxth.w	fp, fp
			if (ret == HAL_OK)
 800264a:	2800      	cmp	r0, #0
 800264c:	f040 8080 	bne.w	8002750 <firmware_image_download_and_install+0x448>
				etx_ota_fw_received_size += 4;
 8002650:	683b      	ldr	r3, [r7, #0]
 8002652:	3304      	adds	r3, #4
 8002654:	603b      	str	r3, [r7, #0]
		for ( ; bytes_flashed<data_len_minus_one_word; bytes_flashed+=4)
 8002656:	9b00      	ldr	r3, [sp, #0]
 8002658:	455b      	cmp	r3, fp
 800265a:	d8dc      	bhi.n	8002616 <firmware_image_download_and_install+0x30e>
		remaining_data_len_of_last_word = data_len - bytes_flashed;
 800265c:	ebaa 0a0b 	sub.w	sl, sl, fp
			word_data[i] = data[bytes_flashed + i];
 8002660:	4971      	ldr	r1, [pc, #452]	; (8002828 <firmware_image_download_and_install+0x520>)
		remaining_data_len_of_last_word = data_len - bytes_flashed;
 8002662:	fa5f f38a 	uxtb.w	r3, sl
			word_data[i] = data[bytes_flashed + i];
 8002666:	461a      	mov	r2, r3
 8002668:	4459      	add	r1, fp
 800266a:	a804      	add	r0, sp, #16
		remaining_data_len_of_last_word = data_len - bytes_flashed;
 800266c:	9300      	str	r3, [sp, #0]
			word_data[i] = data[bytes_flashed + i];
 800266e:	f002 fedf 	bl	8005430 <memcpy>
 8002672:	e0a4      	b.n	80027be <firmware_image_download_and_install+0x4b6>
			if (header->packet_type == ETX_OTA_PACKET_TYPE_HEADER)
 8002674:	2b02      	cmp	r3, #2
 8002676:	f47f ae5e 	bne.w	8002336 <firmware_image_download_and_install+0x2e>
				switch (header->meta_data.payload_type)
 800267a:	7ce2      	ldrb	r2, [r4, #19]
 800267c:	2a00      	cmp	r2, #0
 800267e:	d055      	beq.n	800272c <firmware_image_download_and_install+0x424>
 8002680:	2a01      	cmp	r2, #1
 8002682:	d035      	beq.n	80026f0 <firmware_image_download_and_install+0x3e8>
				  etx_ota_send_resp(ETX_OTA_NACK);
 8002684:	2001      	movs	r0, #1
 8002686:	f7ff fdad 	bl	80021e4 <etx_ota_send_resp.isra.0>
				  return ETX_OTA_EC_NA;
 800268a:	f04f 0b03 	mov.w	fp, #3
 800268e:	e657      	b.n	8002340 <firmware_image_download_and_install+0x38>
			if ((cmd->packet_type==ETX_OTA_PACKET_TYPE_CMD) && (cmd->cmd==ETX_OTA_CMD_END))
 8002690:	2b00      	cmp	r3, #0
 8002692:	f47f ae50 	bne.w	8002336 <firmware_image_download_and_install+0x2e>
 8002696:	7922      	ldrb	r2, [r4, #4]
 8002698:	2a01      	cmp	r2, #1
 800269a:	f47f ae4c 	bne.w	8002336 <firmware_image_download_and_install+0x2e>
				uint32_t cal_crc = crc32_mpeg2((uint8_t *) ETX_APP_FLASH_ADDR, p_fw_config->App_fw_size);
 800269e:	f8df a18c 	ldr.w	sl, [pc, #396]	; 800282c <firmware_image_download_and_install+0x524>
 80026a2:	9300      	str	r3, [sp, #0]
 80026a4:	f8da 2000 	ldr.w	r2, [sl]
 80026a8:	4861      	ldr	r0, [pc, #388]	; (8002830 <firmware_image_download_and_install+0x528>)
 80026aa:	6891      	ldr	r1, [r2, #8]
 80026ac:	f000 f8c8 	bl	8002840 <crc32_mpeg2>
				if (cal_crc != p_fw_config->App_fw_rec_crc)
 80026b0:	f8da 2000 	ldr.w	r2, [sl]
 80026b4:	68d2      	ldr	r2, [r2, #12]
 80026b6:	4290      	cmp	r0, r2
 80026b8:	f47f ae3d 	bne.w	8002336 <firmware_image_download_and_install+0x2e>
				etx_ota_state = ETX_OTA_STATE_IDLE;
 80026bc:	9b00      	ldr	r3, [sp, #0]
 80026be:	702b      	strb	r3, [r5, #0]
			switch (ret)
 80026c0:	e762      	b.n	8002588 <firmware_image_download_and_install+0x280>
	switch (etx_ota_state)
 80026c2:	782a      	ldrb	r2, [r5, #0]
 80026c4:	2a04      	cmp	r2, #4
 80026c6:	f63f ae36 	bhi.w	8002336 <firmware_image_download_and_install+0x2e>
 80026ca:	a101      	add	r1, pc, #4	; (adr r1, 80026d0 <firmware_image_download_and_install+0x3c8>)
 80026cc:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 80026d0:	08002589 	.word	0x08002589
 80026d4:	08002337 	.word	0x08002337
 80026d8:	08002675 	.word	0x08002675
 80026dc:	080025c1 	.word	0x080025c1
 80026e0:	08002691 	.word	0x08002691
				  etx_ota_send_resp(ETX_OTA_ACK);
 80026e4:	2000      	movs	r0, #0
 80026e6:	f7ff fd7d 	bl	80021e4 <etx_ota_send_resp.isra.0>
				  return ETX_OTA_EC_STOP;
 80026ea:	f04f 0b01 	mov.w	fp, #1
 80026ee:	e627      	b.n	8002340 <firmware_image_download_and_install+0x38>
						if (header->meta_data.package_size > ETX_OTA_BL_FW_SIZE)
 80026f0:	6863      	ldr	r3, [r4, #4]
 80026f2:	f5b3 4fd0 	cmp.w	r3, #26624	; 0x6800
 80026f6:	d8c5      	bhi.n	8002684 <firmware_image_download_and_install+0x37c>
						display_output[0] = 'B';
 80026f8:	2355      	movs	r3, #85	; 0x55
						p_fw_config->is_bl_fw_stored_in_app_fw = BT_FW_STORED_IN_APP_FW;
 80026fa:	f240 1201 	movw	r2, #257	; 0x101
						display_output[0] = 'B';
 80026fe:	484d      	ldr	r0, [pc, #308]	; (8002834 <firmware_image_download_and_install+0x52c>)
						p_fw_config->is_bl_fw_stored_in_app_fw = BT_FW_STORED_IN_APP_FW;
 8002700:	f8df a128 	ldr.w	sl, [pc, #296]	; 800282c <firmware_image_download_and_install+0x524>
						display_output[0] = 'B';
 8002704:	6043      	str	r3, [r0, #4]
						p_fw_config->is_bl_fw_stored_in_app_fw = BT_FW_STORED_IN_APP_FW;
 8002706:	f8da 3000 	ldr.w	r3, [sl]
 800270a:	82da      	strh	r2, [r3, #22]
						display_output[0] = 'B';
 800270c:	4b4a      	ldr	r3, [pc, #296]	; (8002838 <firmware_image_download_and_install+0x530>)
 800270e:	6003      	str	r3, [r0, #0]
						set_5641as_display_output(display_output);
 8002710:	f7ff fa0a 	bl	8001b28 <set_5641as_display_output>
				p_fw_config->App_fw_size = header->meta_data.package_size;
 8002714:	68a3      	ldr	r3, [r4, #8]
 8002716:	f8da 0000 	ldr.w	r0, [sl]
 800271a:	60c3      	str	r3, [r0, #12]
 800271c:	6863      	ldr	r3, [r4, #4]
 800271e:	6083      	str	r3, [r0, #8]
				header_ret = firmware_update_configurations_write(p_fw_config);
 8002720:	f000 f976 	bl	8002a10 <firmware_update_configurations_write>
				if (header_ret != FIRM_UPDT_CONF_EC_OK)
 8002724:	b9a0      	cbnz	r0, 8002750 <firmware_image_download_and_install+0x448>
				etx_ota_state = ETX_OTA_STATE_DATA;
 8002726:	2303      	movs	r3, #3
 8002728:	702b      	strb	r3, [r5, #0]
			switch (ret)
 800272a:	e72d      	b.n	8002588 <firmware_image_download_and_install+0x280>
						if (header->meta_data.package_size > ETX_OTA_APP_FW_SIZE)
 800272c:	6861      	ldr	r1, [r4, #4]
 800272e:	f5b1 3fb0 	cmp.w	r1, #90112	; 0x16000
 8002732:	d8a7      	bhi.n	8002684 <firmware_image_download_and_install+0x37c>
						etx_ota_state = ETX_OTA_STATE_HEADER;
 8002734:	702b      	strb	r3, [r5, #0]
						display_output[0] = 'A';
 8002736:	2355      	movs	r3, #85	; 0x55
						p_fw_config->is_bl_fw_stored_in_app_fw = BT_FW_NOT_STORED_IN_APP_FW;
 8002738:	f8df a0f0 	ldr.w	sl, [pc, #240]	; 800282c <firmware_image_download_and_install+0x524>
						display_output[0] = 'A';
 800273c:	483d      	ldr	r0, [pc, #244]	; (8002834 <firmware_image_download_and_install+0x52c>)
 800273e:	6043      	str	r3, [r0, #4]
						p_fw_config->is_bl_fw_stored_in_app_fw = BT_FW_NOT_STORED_IN_APP_FW;
 8002740:	f8da 3000 	ldr.w	r3, [sl]
 8002744:	82da      	strh	r2, [r3, #22]
						display_output[0] = 'A';
 8002746:	4b3d      	ldr	r3, [pc, #244]	; (800283c <firmware_image_download_and_install+0x534>)
 8002748:	6003      	str	r3, [r0, #0]
						set_5641as_display_output(display_output);
 800274a:	f7ff f9ed 	bl	8001b28 <set_5641as_display_output>
						break;
 800274e:	e7e1      	b.n	8002714 <firmware_image_download_and_install+0x40c>
 8002750:	4683      	mov	fp, r0
			switch (ret)
 8002752:	f10b 33ff 	add.w	r3, fp, #4294967295
 8002756:	2b03      	cmp	r3, #3
 8002758:	f63f adf2 	bhi.w	8002340 <firmware_image_download_and_install+0x38>
 800275c:	a101      	add	r1, pc, #4	; (adr r1, 8002764 <firmware_image_download_and_install+0x45c>)
 800275e:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8002762:	bf00      	nop
 8002764:	080026e5 	.word	0x080026e5
 8002768:	0800233d 	.word	0x0800233d
 800276c:	08002685 	.word	0x08002685
 8002770:	08002337 	.word	0x08002337
			for (uint16_t i=0; i<data_len; i++)
 8002774:	f04f 0a04 	mov.w	sl, #4
			len += ETX_OTA_DATA_LENGTH_SIZE;
 8002778:	46d3      	mov	fp, sl
 800277a:	e6b7      	b.n	80024ec <firmware_image_download_and_install+0x1e4>
		EraseInitStruct.PageAddress  = ETX_APP_FLASH_ADDR;
 800277c:	2258      	movs	r2, #88	; 0x58
		EraseInitStruct.Banks        = FLASH_BANK_1;
 800277e:	e9cd 0304 	strd	r0, r3, [sp, #16]
		EraseInitStruct.PageAddress  = ETX_APP_FLASH_ADDR;
 8002782:	4b2b      	ldr	r3, [pc, #172]	; (8002830 <firmware_image_download_and_install+0x528>)
		ret = HAL_FLASHEx_Erase(&EraseInitStruct, &page_error);
 8002784:	a903      	add	r1, sp, #12
 8002786:	a804      	add	r0, sp, #16
		EraseInitStruct.PageAddress  = ETX_APP_FLASH_ADDR;
 8002788:	e9cd 3206 	strd	r3, r2, [sp, #24]
		ret = HAL_FLASHEx_Erase(&EraseInitStruct, &page_error);
 800278c:	f001 fc84 	bl	8004098 <HAL_FLASHEx_Erase>
  switch (HAL_status)
 8002790:	2801      	cmp	r0, #1
 8002792:	f43f add0 	beq.w	8002336 <firmware_image_download_and_install+0x2e>
 8002796:	1e83      	subs	r3, r0, #2
 8002798:	b2db      	uxtb	r3, r3
 800279a:	2b01      	cmp	r3, #1
 800279c:	f67f adce 	bls.w	800233c <firmware_image_download_and_install+0x34>
		if (ret != HAL_OK)
 80027a0:	2800      	cmp	r0, #0
 80027a2:	f43f af2d 	beq.w	8002600 <firmware_image_download_and_install+0x2f8>
		ret = HAL_FLASHEx_Erase(&EraseInitStruct, &page_error);
 80027a6:	4683      	mov	fp, r0
 80027a8:	e7d3      	b.n	8002752 <firmware_image_download_and_install+0x44a>
		remaining_data_len_of_last_word = data_len;
 80027aa:	fa5f f28a 	uxtb.w	r2, sl
 80027ae:	9200      	str	r2, [sp, #0]
		for (uint8_t i=0; i<remaining_data_len_of_last_word; i++)
 80027b0:	f1ba 0f00 	cmp.w	sl, #0
 80027b4:	d031      	beq.n	800281a <firmware_image_download_and_install+0x512>
			word_data[i] = data[i];
 80027b6:	491c      	ldr	r1, [pc, #112]	; (8002828 <firmware_image_download_and_install+0x520>)
 80027b8:	a804      	add	r0, sp, #16
 80027ba:	f002 fe39 	bl	8005430 <memcpy>
	ret = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
 80027be:	6839      	ldr	r1, [r7, #0]
 80027c0:	2300      	movs	r3, #0
 80027c2:	f101 6100 	add.w	r1, r1, #134217728	; 0x8000000
 80027c6:	2002      	movs	r0, #2
 80027c8:	9a04      	ldr	r2, [sp, #16]
 80027ca:	f501 4100 	add.w	r1, r1, #32768	; 0x8000
 80027ce:	f001 fb13 	bl	8003df8 <HAL_FLASH_Program>
  switch (HAL_status)
 80027d2:	2801      	cmp	r0, #1
 80027d4:	f43f adaf 	beq.w	8002336 <firmware_image_download_and_install+0x2e>
 80027d8:	1e82      	subs	r2, r0, #2
 80027da:	b2d2      	uxtb	r2, r2
 80027dc:	2a01      	cmp	r2, #1
 80027de:	f67f adad 	bls.w	800233c <firmware_image_download_and_install+0x34>
	if (ret == HAL_OK)
 80027e2:	2800      	cmp	r0, #0
 80027e4:	d1b4      	bne.n	8002750 <firmware_image_download_and_install+0x448>
		etx_ota_fw_received_size += remaining_data_len_of_last_word;
 80027e6:	683b      	ldr	r3, [r7, #0]
 80027e8:	9a00      	ldr	r2, [sp, #0]
 80027ea:	4413      	add	r3, r2
 80027ec:	603b      	str	r3, [r7, #0]
	ret = HAL_FLASH_Lock();
 80027ee:	f001 fbf3 	bl	8003fd8 <HAL_FLASH_Lock>
  switch (HAL_status)
 80027f2:	2801      	cmp	r0, #1
 80027f4:	f43f ad9f 	beq.w	8002336 <firmware_image_download_and_install+0x2e>
 80027f8:	1e82      	subs	r2, r0, #2
 80027fa:	b2d2      	uxtb	r2, r2
 80027fc:	2a01      	cmp	r2, #1
 80027fe:	f67f ad9d 	bls.w	800233c <firmware_image_download_and_install+0x34>
				if (data_ret != HAL_OK)
 8002802:	2800      	cmp	r0, #0
 8002804:	d1a4      	bne.n	8002750 <firmware_image_download_and_install+0x448>
				if (etx_ota_fw_received_size >= p_fw_config->App_fw_size)
 8002806:	4b09      	ldr	r3, [pc, #36]	; (800282c <firmware_image_download_and_install+0x524>)
 8002808:	681b      	ldr	r3, [r3, #0]
 800280a:	689a      	ldr	r2, [r3, #8]
 800280c:	683b      	ldr	r3, [r7, #0]
 800280e:	429a      	cmp	r2, r3
 8002810:	f63f aeba 	bhi.w	8002588 <firmware_image_download_and_install+0x280>
					etx_ota_state = ETX_OTA_STATE_END;
 8002814:	2304      	movs	r3, #4
 8002816:	702b      	strb	r3, [r5, #0]
			switch (ret)
 8002818:	e6b6      	b.n	8002588 <firmware_image_download_and_install+0x280>
		for (uint8_t i=0; i<remaining_data_len_of_last_word; i++)
 800281a:	f8cd a000 	str.w	sl, [sp]
 800281e:	e7ce      	b.n	80027be <firmware_image_download_and_install+0x4b6>
			len += ETX_OTA_DATA_LENGTH_SIZE;
 8002820:	f04f 0b04 	mov.w	fp, #4
 8002824:	e632      	b.n	800248c <firmware_image_download_and_install+0x184>
 8002826:	bf00      	nop
 8002828:	20000060 	.word	0x20000060
 800282c:	2000047c 	.word	0x2000047c
 8002830:	08008000 	.word	0x08008000
 8002834:	20000468 	.word	0x20000468
 8002838:	00460042 	.word	0x00460042
 800283c:	00460041 	.word	0x00460041

08002840 <crc32_mpeg2>:
    {
    	return checksum;
    }

    /* Apply the 32-bit CRC Hash Function to the given input data (i.e., The data towards which the \p p_data pointer points to). */
    for (unsigned int i=0; i<data_length; i++)
 8002840:	1e4b      	subs	r3, r1, #1
 8002842:	3303      	adds	r3, #3
 8002844:	d813      	bhi.n	800286e <crc32_mpeg2+0x2e>
 8002846:	4602      	mov	r2, r0
    uint32_t checksum = 0xFFFFFFFF;
 8002848:	f04f 30ff 	mov.w	r0, #4294967295
 800284c:	4411      	add	r1, r2
{
 800284e:	b410      	push	{r4}
 8002850:	4c08      	ldr	r4, [pc, #32]	; (8002874 <crc32_mpeg2+0x34>)
 8002852:	4402      	add	r2, r0
 8002854:	4401      	add	r1, r0
    {
        uint8_t top = (uint8_t) (checksum >> 24);
        top ^= p_data[i];
 8002856:	f812 3f01 	ldrb.w	r3, [r2, #1]!
        checksum = (checksum << 8) ^ crc_table[top];
 800285a:	ea83 6310 	eor.w	r3, r3, r0, lsr #24
 800285e:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    for (unsigned int i=0; i<data_length; i++)
 8002862:	4291      	cmp	r1, r2
        checksum = (checksum << 8) ^ crc_table[top];
 8002864:	ea83 2000 	eor.w	r0, r3, r0, lsl #8
    for (unsigned int i=0; i<data_length; i++)
 8002868:	d1f5      	bne.n	8002856 <crc32_mpeg2+0x16>
    }
    return checksum;
}
 800286a:	bc10      	pop	{r4}
 800286c:	4770      	bx	lr
    uint32_t checksum = 0xFFFFFFFF;
 800286e:	f04f 30ff 	mov.w	r0, #4294967295
}
 8002872:	4770      	bx	lr
 8002874:	08005478 	.word	0x08005478

08002878 <page_erase>:

	return ret;
}

static FirmUpdConf_Status page_erase(uint32_t *page_start_addr)
{
 8002878:	b5d0      	push	{r4, r6, r7, lr}
 800287a:	b086      	sub	sp, #24
 800287c:	4604      	mov	r4, r0
	#endif
	/** <b>Local variable ret:</b> @ref uin8_t Type variable used to hold the return value of either a @ref FirmUpdConf_Status or a @ref HAL_StatusTypeDef function. */
	uint8_t ret;

	/* Unlock HAL Flash */
	ret = HAL_FLASH_Unlock();
 800287e:	f001 fa95 	bl	8003dac <HAL_FLASH_Unlock>
	return FIRM_UPDT_CONF_EC_OK;
}

static FirmUpdConf_Status HAL_ret_handler(HAL_StatusTypeDef HAL_status)
{
  switch (HAL_status)
 8002882:	2801      	cmp	r0, #1
 8002884:	d006      	beq.n	8002894 <page_erase+0x1c>
 8002886:	1e83      	subs	r3, r0, #2
 8002888:	b2db      	uxtb	r3, r3
 800288a:	2b01      	cmp	r3, #1
 800288c:	d805      	bhi.n	800289a <page_erase+0x22>
    {
  	  case HAL_BUSY:
	  case HAL_TIMEOUT:
		return FIRM_UPDT_CONF_EC_NR;
 800288e:	2002      	movs	r0, #2
}
 8002890:	b006      	add	sp, #24
 8002892:	bdd0      	pop	{r4, r6, r7, pc}
	  case HAL_ERROR:
		return FIRM_UPDT_CONF_EC_ERR;
 8002894:	2004      	movs	r0, #4
}
 8002896:	b006      	add	sp, #24
 8002898:	bdd0      	pop	{r4, r6, r7, pc}
	if (ret != HAL_OK)
 800289a:	2800      	cmp	r0, #0
 800289c:	d1f8      	bne.n	8002890 <page_erase+0x18>
	EraseInitStruct.NbPages      = 1U;
 800289e:	2301      	movs	r3, #1
	EraseInitStruct.TypeErase    = FLASH_TYPEERASE_PAGES;
 80028a0:	2600      	movs	r6, #0
 80028a2:	2701      	movs	r7, #1
	ret = HAL_FLASHEx_Erase(&EraseInitStruct, &page_error);
 80028a4:	a901      	add	r1, sp, #4
 80028a6:	a802      	add	r0, sp, #8
	EraseInitStruct.TypeErase    = FLASH_TYPEERASE_PAGES;
 80028a8:	e9cd 6702 	strd	r6, r7, [sp, #8]
	EraseInitStruct.PageAddress  = (uint32_t) page_start_addr;
 80028ac:	9404      	str	r4, [sp, #16]
	EraseInitStruct.NbPages      = 1U;
 80028ae:	9305      	str	r3, [sp, #20]
	ret = HAL_FLASHEx_Erase(&EraseInitStruct, &page_error);
 80028b0:	f001 fbf2 	bl	8004098 <HAL_FLASHEx_Erase>
  switch (HAL_status)
 80028b4:	2801      	cmp	r0, #1
 80028b6:	d0ed      	beq.n	8002894 <page_erase+0x1c>
 80028b8:	1e83      	subs	r3, r0, #2
 80028ba:	b2db      	uxtb	r3, r3
 80028bc:	2b01      	cmp	r3, #1
 80028be:	d9e6      	bls.n	800288e <page_erase+0x16>
	if (ret != HAL_OK)
 80028c0:	2800      	cmp	r0, #0
 80028c2:	d1e5      	bne.n	8002890 <page_erase+0x18>
	ret = HAL_FLASH_Lock();
 80028c4:	f001 fb88 	bl	8003fd8 <HAL_FLASH_Lock>
  switch (HAL_status)
 80028c8:	2801      	cmp	r0, #1
 80028ca:	d0e3      	beq.n	8002894 <page_erase+0x1c>
 80028cc:	1e83      	subs	r3, r0, #2
 80028ce:	b2db      	uxtb	r3, r3
 80028d0:	2b01      	cmp	r3, #1
 80028d2:	d9dc      	bls.n	800288e <page_erase+0x16>
 80028d4:	e7dc      	b.n	8002890 <page_erase+0x18>
 80028d6:	bf00      	nop

080028d8 <firmware_update_configurations_init>:
{
 80028d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	p_most_recent_val = ((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_END_ADDR_PLUS_ONE) - 1;
 80028da:	4b2e      	ldr	r3, [pc, #184]	; (8002994 <firmware_update_configurations_init+0xbc>)
 80028dc:	4f2e      	ldr	r7, [pc, #184]	; (8002998 <firmware_update_configurations_init+0xc0>)
 80028de:	2100      	movs	r1, #0
 80028e0:	4618      	mov	r0, r3
	for (p_next_val = (firmware_update_config_t *)FIRMWARE_UPDATE_CONFIG_START_ADDR; p_next_val < (firmware_update_config_t *)FIRMWARE_UPDATE_CONFIG_END_ADDR_PLUS_ONE; p_next_val++)
 80028e2:	4c2e      	ldr	r4, [pc, #184]	; (800299c <firmware_update_configurations_init+0xc4>)
 80028e4:	4d2e      	ldr	r5, [pc, #184]	; (80029a0 <firmware_update_configurations_init+0xc8>)
	p_most_recent_val = ((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_END_ADDR_PLUS_ONE) - 1;
 80028e6:	603b      	str	r3, [r7, #0]
	for (p_next_val = (firmware_update_config_t *)FIRMWARE_UPDATE_CONFIG_START_ADDR; p_next_val < (firmware_update_config_t *)FIRMWARE_UPDATE_CONFIG_END_ADDR_PLUS_ONE; p_next_val++)
 80028e8:	e005      	b.n	80028f6 <firmware_update_configurations_init+0x1e>
 80028ea:	42ab      	cmp	r3, r5
 80028ec:	4620      	mov	r0, r4
 80028ee:	f04f 0101 	mov.w	r1, #1
 80028f2:	d02f      	beq.n	8002954 <firmware_update_configurations_init+0x7c>
 80028f4:	461c      	mov	r4, r3
		if (p_next_val->flags.is_erased == FLASH_BLOCK_ERASED)
 80028f6:	7fe2      	ldrb	r2, [r4, #31]
	for (p_next_val = (firmware_update_config_t *)FIRMWARE_UPDATE_CONFIG_START_ADDR; p_next_val < (firmware_update_config_t *)FIRMWARE_UPDATE_CONFIG_END_ADDR_PLUS_ONE; p_next_val++)
 80028f8:	f104 0320 	add.w	r3, r4, #32
		if (p_next_val->flags.is_erased == FLASH_BLOCK_ERASED)
 80028fc:	2aff      	cmp	r2, #255	; 0xff
 80028fe:	d1f4      	bne.n	80028ea <firmware_update_configurations_init+0x12>
			if (p_most_recent_val->flags.is_erased == FLASH_BLOCK_NOT_ERASED)
 8002900:	7fc6      	ldrb	r6, [r0, #31]
 8002902:	2e00      	cmp	r6, #0
 8002904:	d1f1      	bne.n	80028ea <firmware_update_configurations_init+0x12>
 8002906:	b101      	cbz	r1, 800290a <firmware_update_configurations_init+0x32>
 8002908:	6038      	str	r0, [r7, #0]
				cal_crc = crc32_mpeg2((uint8_t *) &p_most_recent_val->data, FIRMWARE_UPDATE_CONFIG_BLOCK_SIZE_WITHOUT_CRC);
 800290a:	211c      	movs	r1, #28
 800290c:	3004      	adds	r0, #4
 800290e:	f7ff ff97 	bl	8002840 <crc32_mpeg2>
				if(cal_crc != p_most_recent_val->crc32)
 8002912:	683b      	ldr	r3, [r7, #0]
 8002914:	681a      	ldr	r2, [r3, #0]
 8002916:	4282      	cmp	r2, r0
 8002918:	d10b      	bne.n	8002932 <firmware_update_configurations_init+0x5a>
	if (p_next_val == (firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_END_ADDR_PLUS_ONE)
 800291a:	4a21      	ldr	r2, [pc, #132]	; (80029a0 <firmware_update_configurations_init+0xc8>)
 800291c:	4294      	cmp	r4, r2
 800291e:	d035      	beq.n	800298c <firmware_update_configurations_init+0xb4>
	if (p_most_recent_val == ((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_PAGE_1_START_ADDR) &&
 8002920:	4a1e      	ldr	r2, [pc, #120]	; (800299c <firmware_update_configurations_init+0xc4>)
 8002922:	4293      	cmp	r3, r2
 8002924:	d028      	beq.n	8002978 <firmware_update_configurations_init+0xa0>
	else if (p_most_recent_val == ((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_PAGE_2_START_ADDR) &&
 8002926:	4a1f      	ldr	r2, [pc, #124]	; (80029a4 <firmware_update_configurations_init+0xcc>)
 8002928:	4293      	cmp	r3, r2
 800292a:	d01c      	beq.n	8002966 <firmware_update_configurations_init+0x8e>
		ret = FIRM_UPDT_CONF_EC_OK;
 800292c:	2600      	movs	r6, #0
}
 800292e:	4630      	mov	r0, r6
 8002930:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ret = page_erase((uint32_t *) FIRMWARE_UPDATE_CONFIG_PAGE_1_START_ADDR);
 8002932:	481a      	ldr	r0, [pc, #104]	; (800299c <firmware_update_configurations_init+0xc4>)
 8002934:	f7ff ffa0 	bl	8002878 <page_erase>
	if (ret != FIRM_UPDT_CONF_EC_OK)
 8002938:	b110      	cbz	r0, 8002940 <firmware_update_configurations_init+0x68>
						return FIRM_UPDT_CONF_EC_CRPT;
 800293a:	2605      	movs	r6, #5
}
 800293c:	4630      	mov	r0, r6
 800293e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ret = page_erase((uint32_t *) FIRMWARE_UPDATE_CONFIG_PAGE_2_START_ADDR);
 8002940:	4818      	ldr	r0, [pc, #96]	; (80029a4 <firmware_update_configurations_init+0xcc>)
 8002942:	f7ff ff99 	bl	8002878 <page_erase>
					if (ret != FIRM_UPDT_CONF_EC_OK)
 8002946:	2800      	cmp	r0, #0
 8002948:	d1f7      	bne.n	800293a <firmware_update_configurations_init+0x62>
					p_most_recent_val = NULL;
 800294a:	2300      	movs	r3, #0
					return FIRM_UPDT_CONF_EC_OK;
 800294c:	461e      	mov	r6, r3
					p_most_recent_val = NULL;
 800294e:	603b      	str	r3, [r7, #0]
}
 8002950:	4630      	mov	r0, r6
 8002952:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (p_most_recent_val->flags.is_erased == FLASH_BLOCK_ERASED)
 8002954:	4b14      	ldr	r3, [pc, #80]	; (80029a8 <firmware_update_configurations_init+0xd0>)
 8002956:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 800295a:	2bff      	cmp	r3, #255	; 0xff
 800295c:	d0f5      	beq.n	800294a <firmware_update_configurations_init+0x72>
 800295e:	4b0d      	ldr	r3, [pc, #52]	; (8002994 <firmware_update_configurations_init+0xbc>)
	else if (p_most_recent_val == ((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_PAGE_2_START_ADDR) &&
 8002960:	4a10      	ldr	r2, [pc, #64]	; (80029a4 <firmware_update_configurations_init+0xcc>)
 8002962:	4293      	cmp	r3, r2
 8002964:	d1e2      	bne.n	800292c <firmware_update_configurations_init+0x54>
 8002966:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 800296a:	2b00      	cmp	r3, #0
 800296c:	d1de      	bne.n	800292c <firmware_update_configurations_init+0x54>
}
 800296e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		ret = page_erase((uint32_t *) FIRMWARE_UPDATE_CONFIG_PAGE_1_START_ADDR);
 8002972:	480a      	ldr	r0, [pc, #40]	; (800299c <firmware_update_configurations_init+0xc4>)
 8002974:	f7ff bf80 	b.w	8002878 <page_erase>
	   (((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_END_ADDR_PLUS_ONE)-1)->flags.is_erased == FLASH_BLOCK_NOT_ERASED)
 8002978:	4b0b      	ldr	r3, [pc, #44]	; (80029a8 <firmware_update_configurations_init+0xd0>)
	if (p_most_recent_val == ((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_PAGE_1_START_ADDR) &&
 800297a:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 800297e:	2b00      	cmp	r3, #0
 8002980:	d1d5      	bne.n	800292e <firmware_update_configurations_init+0x56>
}
 8002982:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		ret = page_erase((uint32_t *) FIRMWARE_UPDATE_CONFIG_PAGE_2_START_ADDR);
 8002986:	4807      	ldr	r0, [pc, #28]	; (80029a4 <firmware_update_configurations_init+0xcc>)
 8002988:	f7ff bf76 	b.w	8002878 <page_erase>
		if (p_most_recent_val->flags.is_erased == FLASH_BLOCK_ERASED)
 800298c:	7fda      	ldrb	r2, [r3, #31]
 800298e:	2aff      	cmp	r2, #255	; 0xff
 8002990:	d1c6      	bne.n	8002920 <firmware_update_configurations_init+0x48>
 8002992:	e7da      	b.n	800294a <firmware_update_configurations_init+0x72>
 8002994:	0801efe0 	.word	0x0801efe0
 8002998:	20000484 	.word	0x20000484
 800299c:	0801e000 	.word	0x0801e000
 80029a0:	0801f000 	.word	0x0801f000
 80029a4:	0801e800 	.word	0x0801e800
 80029a8:	0801ef00 	.word	0x0801ef00

080029ac <firmware_update_configurations_read>:
	firmware_update_config_t *p_current_val = p_most_recent_val;
 80029ac:	4b16      	ldr	r3, [pc, #88]	; (8002a08 <firmware_update_configurations_read+0x5c>)
{
 80029ae:	4684      	mov	ip, r0
	firmware_update_config_t *p_current_val = p_most_recent_val;
 80029b0:	681b      	ldr	r3, [r3, #0]
{
 80029b2:	b510      	push	{r4, lr}
	if (p_current_val == NULL)
 80029b4:	b1ab      	cbz	r3, 80029e2 <firmware_update_configurations_read+0x36>
	return FIRM_UPDT_CONF_EC_OK;
 80029b6:	f04f 0e00 	mov.w	lr, #0
	memcpy(p_data, &(p_current_val->data), FIRMWARE_UPDATE_CONFIG_DATA_SIZE);
 80029ba:	6859      	ldr	r1, [r3, #4]
 80029bc:	689a      	ldr	r2, [r3, #8]
 80029be:	6918      	ldr	r0, [r3, #16]
 80029c0:	68dc      	ldr	r4, [r3, #12]
 80029c2:	f8cc 000c 	str.w	r0, [ip, #12]
 80029c6:	f8cc 1000 	str.w	r1, [ip]
 80029ca:	f8cc 2004 	str.w	r2, [ip, #4]
 80029ce:	f8cc 4008 	str.w	r4, [ip, #8]
 80029d2:	6959      	ldr	r1, [r3, #20]
 80029d4:	699a      	ldr	r2, [r3, #24]
 80029d6:	f8cc 1010 	str.w	r1, [ip, #16]
 80029da:	f8cc 2014 	str.w	r2, [ip, #20]
}
 80029de:	4670      	mov	r0, lr
 80029e0:	bd10      	pop	{r4, pc}
		return FIRM_UPDT_CONF_EC_NO_DATA;
 80029e2:	f04f 0e06 	mov.w	lr, #6
		memcpy(p_data, &(p_current_val->data), FIRMWARE_UPDATE_CONFIG_DATA_SIZE);
 80029e6:	4c09      	ldr	r4, [pc, #36]	; (8002a0c <firmware_update_configurations_read+0x60>)
 80029e8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80029ea:	f8cc 0000 	str.w	r0, [ip]
 80029ee:	f8cc 1004 	str.w	r1, [ip, #4]
 80029f2:	f8cc 2008 	str.w	r2, [ip, #8]
 80029f6:	f8cc 300c 	str.w	r3, [ip, #12]
 80029fa:	cc03      	ldmia	r4!, {r0, r1}
 80029fc:	f8cc 0010 	str.w	r0, [ip, #16]
 8002a00:	f8cc 1014 	str.w	r1, [ip, #20]
}
 8002a04:	4670      	mov	r0, lr
 8002a06:	bd10      	pop	{r4, pc}
 8002a08:	20000484 	.word	0x20000484
 8002a0c:	0801e004 	.word	0x0801e004

08002a10 <firmware_update_configurations_write>:
{
 8002a10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002a14:	4686      	mov	lr, r0
	new_val_struct.data.reserved1 = DATA_BLOCK_32BIT_ERASED_VALUE; // Make sure to keep reserved data's bits set to 1's.
 8002a16:	f04f 34ff 	mov.w	r4, #4294967295
	new_val_struct.flags.reserved2 = DATA_BLOCK_16BIT_ERASED_VALUE; // Make sure to keep reserved data's bits set to 1's.
 8002a1a:	f06f 467f 	mvn.w	r6, #4278190080	; 0xff000000
{
 8002a1e:	b088      	sub	sp, #32
	memcpy(&new_val_struct.data, p_data, FIRMWARE_UPDATE_CONFIG_DATA_SIZE);
 8002a20:	6800      	ldr	r0, [r0, #0]
 8002a22:	f8de 1004 	ldr.w	r1, [lr, #4]
 8002a26:	f8de 2008 	ldr.w	r2, [lr, #8]
 8002a2a:	f8de 300c 	ldr.w	r3, [lr, #12]
 8002a2e:	f10d 0c04 	add.w	ip, sp, #4
 8002a32:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8002a36:	f8de 0010 	ldr.w	r0, [lr, #16]
 8002a3a:	f8de 1014 	ldr.w	r1, [lr, #20]
	if (p_most_recent_val != NULL)
 8002a3e:	4d31      	ldr	r5, [pc, #196]	; (8002b04 <firmware_update_configurations_write+0xf4>)
	memcpy(&new_val_struct.data, p_data, FIRMWARE_UPDATE_CONFIG_DATA_SIZE);
 8002a40:	e8ac 0003 	stmia.w	ip!, {r0, r1}
	new_val_struct.crc32 = crc32_mpeg2((uint8_t *) &new_val_struct.data, FIRMWARE_UPDATE_CONFIG_BLOCK_SIZE_WITHOUT_CRC);
 8002a44:	211c      	movs	r1, #28
 8002a46:	a801      	add	r0, sp, #4
	new_val_struct.data.reserved1 = DATA_BLOCK_32BIT_ERASED_VALUE; // Make sure to keep reserved data's bits set to 1's.
 8002a48:	9405      	str	r4, [sp, #20]
	new_val_struct.data.reserved2 = DATA_BLOCK_16BIT_ERASED_VALUE; // Make sure to keep reserved data's bits set to 1's.
 8002a4a:	f8ad 4018 	strh.w	r4, [sp, #24]
	new_val_struct.flags.reserved2 = DATA_BLOCK_16BIT_ERASED_VALUE; // Make sure to keep reserved data's bits set to 1's.
 8002a4e:	9607      	str	r6, [sp, #28]
	new_val_struct.crc32 = crc32_mpeg2((uint8_t *) &new_val_struct.data, FIRMWARE_UPDATE_CONFIG_BLOCK_SIZE_WITHOUT_CRC);
 8002a50:	f7ff fef6 	bl	8002840 <crc32_mpeg2>
	if (p_most_recent_val != NULL)
 8002a54:	682c      	ldr	r4, [r5, #0]
	new_val_struct.crc32 = crc32_mpeg2((uint8_t *) &new_val_struct.data, FIRMWARE_UPDATE_CONFIG_BLOCK_SIZE_WITHOUT_CRC);
 8002a56:	9000      	str	r0, [sp, #0]
	if (p_most_recent_val != NULL)
 8002a58:	2c00      	cmp	r4, #0
 8002a5a:	d047      	beq.n	8002aec <firmware_update_configurations_write+0xdc>
		if (p_next_val == (firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_END_ADDR_PLUS_ONE)
 8002a5c:	4a2a      	ldr	r2, [pc, #168]	; (8002b08 <firmware_update_configurations_write+0xf8>)
	firmware_update_config_t *p_next_val = (firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_START_ADDR;
 8002a5e:	4b2b      	ldr	r3, [pc, #172]	; (8002b0c <firmware_update_configurations_write+0xfc>)
		p_next_val = p_most_recent_val + 1;
 8002a60:	3420      	adds	r4, #32
	firmware_update_config_t *p_next_val = (firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_START_ADDR;
 8002a62:	4294      	cmp	r4, r2
 8002a64:	bf08      	it	eq
 8002a66:	461c      	moveq	r4, r3
	ret = HAL_FLASH_Unlock();
 8002a68:	f001 f9a0 	bl	8003dac <HAL_FLASH_Unlock>
  switch (HAL_status)
 8002a6c:	2801      	cmp	r0, #1
 8002a6e:	d019      	beq.n	8002aa4 <firmware_update_configurations_write+0x94>
 8002a70:	1e82      	subs	r2, r0, #2
 8002a72:	b2d2      	uxtb	r2, r2
 8002a74:	2a01      	cmp	r2, #1
 8002a76:	d803      	bhi.n	8002a80 <firmware_update_configurations_write+0x70>
		return FIRM_UPDT_CONF_EC_NR;
 8002a78:	2002      	movs	r0, #2
}
 8002a7a:	b008      	add	sp, #32
 8002a7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (ret != HAL_OK)
 8002a80:	2800      	cmp	r0, #0
 8002a82:	d1fa      	bne.n	8002a7a <firmware_update_configurations_write+0x6a>
 8002a84:	4627      	mov	r7, r4
 8002a86:	f1ad 0604 	sub.w	r6, sp, #4
 8002a8a:	f10d 081c 	add.w	r8, sp, #28
		ret = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
 8002a8e:	2300      	movs	r3, #0
 8002a90:	4639      	mov	r1, r7
 8002a92:	2002      	movs	r0, #2
 8002a94:	f856 2f04 	ldr.w	r2, [r6, #4]!
 8002a98:	f001 f9ae 	bl	8003df8 <HAL_FLASH_Program>
  switch (HAL_status)
 8002a9c:	1e83      	subs	r3, r0, #2
 8002a9e:	2801      	cmp	r0, #1
 8002aa0:	b2db      	uxtb	r3, r3
 8002aa2:	d103      	bne.n	8002aac <firmware_update_configurations_write+0x9c>
		return FIRM_UPDT_CONF_EC_ERR;
 8002aa4:	2004      	movs	r0, #4
}
 8002aa6:	b008      	add	sp, #32
 8002aa8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  switch (HAL_status)
 8002aac:	2b01      	cmp	r3, #1
 8002aae:	d9e3      	bls.n	8002a78 <firmware_update_configurations_write+0x68>
	for (uint8_t words_written=0; words_written<FIRMWARE_UPDATE_CONFIG_BLOCK_SIZE; words_written++)
 8002ab0:	3704      	adds	r7, #4
		if (ret != HAL_OK)
 8002ab2:	2800      	cmp	r0, #0
 8002ab4:	d1e1      	bne.n	8002a7a <firmware_update_configurations_write+0x6a>
	for (uint8_t words_written=0; words_written<FIRMWARE_UPDATE_CONFIG_BLOCK_SIZE; words_written++)
 8002ab6:	4546      	cmp	r6, r8
 8002ab8:	d1e9      	bne.n	8002a8e <firmware_update_configurations_write+0x7e>
	ret = HAL_FLASH_Lock();
 8002aba:	f001 fa8d 	bl	8003fd8 <HAL_FLASH_Lock>
  switch (HAL_status)
 8002abe:	2801      	cmp	r0, #1
 8002ac0:	d0f0      	beq.n	8002aa4 <firmware_update_configurations_write+0x94>
 8002ac2:	1e83      	subs	r3, r0, #2
 8002ac4:	b2db      	uxtb	r3, r3
 8002ac6:	2b01      	cmp	r3, #1
 8002ac8:	d9d6      	bls.n	8002a78 <firmware_update_configurations_write+0x68>
	if (ret != HAL_OK)
 8002aca:	2800      	cmp	r0, #0
 8002acc:	d1d5      	bne.n	8002a7a <firmware_update_configurations_write+0x6a>
	if (p_most_recent_val == ((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_PAGE_1_START_ADDR) &&
 8002ace:	4b0f      	ldr	r3, [pc, #60]	; (8002b0c <firmware_update_configurations_write+0xfc>)
	p_most_recent_val = p_next_val;
 8002ad0:	602c      	str	r4, [r5, #0]
	if (p_most_recent_val == ((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_PAGE_1_START_ADDR) &&
 8002ad2:	429c      	cmp	r4, r3
 8002ad4:	d00c      	beq.n	8002af0 <firmware_update_configurations_write+0xe0>
	else if (p_most_recent_val == ((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_PAGE_2_START_ADDR) &&
 8002ad6:	4b0e      	ldr	r3, [pc, #56]	; (8002b10 <firmware_update_configurations_write+0x100>)
 8002ad8:	429c      	cmp	r4, r3
 8002ada:	d1ce      	bne.n	8002a7a <firmware_update_configurations_write+0x6a>
 8002adc:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 8002ae0:	2b00      	cmp	r3, #0
 8002ae2:	d1ca      	bne.n	8002a7a <firmware_update_configurations_write+0x6a>
		ret = page_erase((uint32_t *) FIRMWARE_UPDATE_CONFIG_PAGE_1_START_ADDR);
 8002ae4:	4809      	ldr	r0, [pc, #36]	; (8002b0c <firmware_update_configurations_write+0xfc>)
 8002ae6:	f7ff fec7 	bl	8002878 <page_erase>
	return ret;
 8002aea:	e7c6      	b.n	8002a7a <firmware_update_configurations_write+0x6a>
	firmware_update_config_t *p_next_val = (firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_START_ADDR;
 8002aec:	4c07      	ldr	r4, [pc, #28]	; (8002b0c <firmware_update_configurations_write+0xfc>)
 8002aee:	e7bb      	b.n	8002a68 <firmware_update_configurations_write+0x58>
	   (((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_END_ADDR_PLUS_ONE)-1)->flags.is_erased == FLASH_BLOCK_NOT_ERASED)
 8002af0:	f503 6370 	add.w	r3, r3, #3840	; 0xf00
	if (p_most_recent_val == ((firmware_update_config_t *) FIRMWARE_UPDATE_CONFIG_PAGE_1_START_ADDR) &&
 8002af4:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 8002af8:	2b00      	cmp	r3, #0
 8002afa:	d1be      	bne.n	8002a7a <firmware_update_configurations_write+0x6a>
		ret = page_erase((uint32_t *) FIRMWARE_UPDATE_CONFIG_PAGE_2_START_ADDR);
 8002afc:	4804      	ldr	r0, [pc, #16]	; (8002b10 <firmware_update_configurations_write+0x100>)
 8002afe:	f7ff febb 	bl	8002878 <page_erase>
 8002b02:	e7ba      	b.n	8002a7a <firmware_update_configurations_write+0x6a>
 8002b04:	20000484 	.word	0x20000484
 8002b08:	0801f000 	.word	0x0801f000
 8002b0c:	0801e000 	.word	0x0801e000
 8002b10:	0801e800 	.word	0x0801e800

08002b14 <init_hm10_module>:
 */
static HM10_Status HAL_ret_handler(HAL_StatusTypeDef HAL_status);

void init_hm10_module(UART_HandleTypeDef *huart)
{
	p_huart = huart;
 8002b14:	4b01      	ldr	r3, [pc, #4]	; (8002b1c <init_hm10_module+0x8>)
 8002b16:	6018      	str	r0, [r3, #0]
}
 8002b18:	4770      	bx	lr
 8002b1a:	bf00      	nop
 8002b1c:	2000049c 	.word	0x2000049c

08002b20 <send_hm10_reset_cmd>:

	return HM10_EC_OK;
}

HM10_Status send_hm10_reset_cmd()
{
 8002b20:	b570      	push	{r4, r5, r6, lr}
 8002b22:	4c29      	ldr	r4, [pc, #164]	; (8002bc8 <send_hm10_reset_cmd+0xa8>)
 8002b24:	4d29      	ldr	r5, [pc, #164]	; (8002bcc <send_hm10_reset_cmd+0xac>)
{
	/** <b>Local variable ret:</b> Return value of either a HAL function type. */
	HAL_StatusTypeDef  ret;

	/* Receive the HM-10 Device's BT data that is received Over the Air (OTA), if there is any. */
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, 1, HM10_CUSTOM_HAL_TIMEOUT);
 8002b26:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8002b2a:	2201      	movs	r2, #1
 8002b2c:	4621      	mov	r1, r4
 8002b2e:	6828      	ldr	r0, [r5, #0]
 8002b30:	f002 fbca 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 8002b34:	2803      	cmp	r0, #3
 8002b36:	d1f6      	bne.n	8002b26 <send_hm10_reset_cmd+0x6>
	TxRx_Buffer[0] = 'A';
 8002b38:	4925      	ldr	r1, [pc, #148]	; (8002bd0 <send_hm10_reset_cmd+0xb0>)
 8002b3a:	4a26      	ldr	r2, [pc, #152]	; (8002bd4 <send_hm10_reset_cmd+0xb4>)
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_RESET_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002b3c:	f44f 73a0 	mov.w	r3, #320	; 0x140
	TxRx_Buffer[0] = 'A';
 8002b40:	e9c4 1200 	strd	r1, r2, [r4]
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_RESET_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002b44:	6828      	ldr	r0, [r5, #0]
 8002b46:	2208      	movs	r2, #8
 8002b48:	491f      	ldr	r1, [pc, #124]	; (8002bc8 <send_hm10_reset_cmd+0xa8>)
 8002b4a:	f002 fb1b 	bl	8005184 <HAL_UART_Transmit>
	}
}

static HM10_Status HAL_ret_handler(HAL_StatusTypeDef HAL_status)
{
  switch (HAL_status)
 8002b4e:	2801      	cmp	r0, #1
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_RESET_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002b50:	4606      	mov	r6, r0
  switch (HAL_status)
 8002b52:	d006      	beq.n	8002b62 <send_hm10_reset_cmd+0x42>
 8002b54:	1e83      	subs	r3, r0, #2
 8002b56:	b2db      	uxtb	r3, r3
 8002b58:	2b01      	cmp	r3, #1
 8002b5a:	d805      	bhi.n	8002b68 <send_hm10_reset_cmd+0x48>
    {
  	  case HAL_BUSY:
	  case HAL_TIMEOUT:
		return HM10_EC_NR;
 8002b5c:	2602      	movs	r6, #2
}
 8002b5e:	4630      	mov	r0, r6
 8002b60:	bd70      	pop	{r4, r5, r6, pc}
			return HM10_EC_ERR;
 8002b62:	2604      	movs	r6, #4
}
 8002b64:	4630      	mov	r0, r6
 8002b66:	bd70      	pop	{r4, r5, r6, pc}
	if (ret != HAL_OK)
 8002b68:	2800      	cmp	r0, #0
 8002b6a:	d1f8      	bne.n	8002b5e <send_hm10_reset_cmd+0x3e>
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, HM10_RESET_RESPONSE_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002b6c:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8002b70:	2208      	movs	r2, #8
 8002b72:	4915      	ldr	r1, [pc, #84]	; (8002bc8 <send_hm10_reset_cmd+0xa8>)
 8002b74:	6828      	ldr	r0, [r5, #0]
 8002b76:	f002 fba7 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 8002b7a:	2801      	cmp	r0, #1
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, HM10_RESET_RESPONSE_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002b7c:	4606      	mov	r6, r0
  switch (HAL_status)
 8002b7e:	d0f0      	beq.n	8002b62 <send_hm10_reset_cmd+0x42>
 8002b80:	1e83      	subs	r3, r0, #2
 8002b82:	b2db      	uxtb	r3, r3
 8002b84:	2b01      	cmp	r3, #1
 8002b86:	d9e9      	bls.n	8002b5c <send_hm10_reset_cmd+0x3c>
	if (ret != HAL_OK)
 8002b88:	2800      	cmp	r0, #0
 8002b8a:	d1e8      	bne.n	8002b5e <send_hm10_reset_cmd+0x3e>
		if (TxRx_Buffer[i] != HM10_Reset_resp[i])
 8002b8c:	7823      	ldrb	r3, [r4, #0]
 8002b8e:	2b4f      	cmp	r3, #79	; 0x4f
 8002b90:	d1e7      	bne.n	8002b62 <send_hm10_reset_cmd+0x42>
 8002b92:	7863      	ldrb	r3, [r4, #1]
 8002b94:	2b4b      	cmp	r3, #75	; 0x4b
 8002b96:	d1e4      	bne.n	8002b62 <send_hm10_reset_cmd+0x42>
 8002b98:	78a3      	ldrb	r3, [r4, #2]
 8002b9a:	2b2b      	cmp	r3, #43	; 0x2b
 8002b9c:	d1e1      	bne.n	8002b62 <send_hm10_reset_cmd+0x42>
 8002b9e:	78e3      	ldrb	r3, [r4, #3]
 8002ba0:	2b52      	cmp	r3, #82	; 0x52
 8002ba2:	d1de      	bne.n	8002b62 <send_hm10_reset_cmd+0x42>
 8002ba4:	7923      	ldrb	r3, [r4, #4]
 8002ba6:	2b45      	cmp	r3, #69	; 0x45
 8002ba8:	d1db      	bne.n	8002b62 <send_hm10_reset_cmd+0x42>
 8002baa:	7963      	ldrb	r3, [r4, #5]
 8002bac:	2b53      	cmp	r3, #83	; 0x53
 8002bae:	d1d8      	bne.n	8002b62 <send_hm10_reset_cmd+0x42>
 8002bb0:	79a3      	ldrb	r3, [r4, #6]
 8002bb2:	2b45      	cmp	r3, #69	; 0x45
 8002bb4:	d1d5      	bne.n	8002b62 <send_hm10_reset_cmd+0x42>
 8002bb6:	79e3      	ldrb	r3, [r4, #7]
 8002bb8:	2b54      	cmp	r3, #84	; 0x54
 8002bba:	d1d2      	bne.n	8002b62 <send_hm10_reset_cmd+0x42>
	HAL_Delay(HM10_RESET_AND_RENEW_CMDS_DELAY);
 8002bbc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002bc0:	f001 f85a 	bl	8003c78 <HAL_Delay>
	return HM10_EC_OK;
 8002bc4:	e7cb      	b.n	8002b5e <send_hm10_reset_cmd+0x3e>
 8002bc6:	bf00      	nop
 8002bc8:	20000488 	.word	0x20000488
 8002bcc:	2000049c 	.word	0x2000049c
 8002bd0:	522b5441 	.word	0x522b5441
 8002bd4:	54455345 	.word	0x54455345

08002bd8 <send_hm10_renew_cmd>:
{
 8002bd8:	b570      	push	{r4, r5, r6, lr}
 8002bda:	4c29      	ldr	r4, [pc, #164]	; (8002c80 <send_hm10_renew_cmd+0xa8>)
 8002bdc:	4d29      	ldr	r5, [pc, #164]	; (8002c84 <send_hm10_renew_cmd+0xac>)
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, 1, HM10_CUSTOM_HAL_TIMEOUT);
 8002bde:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8002be2:	2201      	movs	r2, #1
 8002be4:	4621      	mov	r1, r4
 8002be6:	6828      	ldr	r0, [r5, #0]
 8002be8:	f002 fb6e 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 8002bec:	2803      	cmp	r0, #3
 8002bee:	d1f6      	bne.n	8002bde <send_hm10_renew_cmd+0x6>
    TxRx_Buffer[0] = 'A';
 8002bf0:	4925      	ldr	r1, [pc, #148]	; (8002c88 <send_hm10_renew_cmd+0xb0>)
 8002bf2:	4a26      	ldr	r2, [pc, #152]	; (8002c8c <send_hm10_renew_cmd+0xb4>)
    ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_RENEW_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002bf4:	f44f 73a0 	mov.w	r3, #320	; 0x140
    TxRx_Buffer[0] = 'A';
 8002bf8:	e9c4 1200 	strd	r1, r2, [r4]
    ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_RENEW_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002bfc:	6828      	ldr	r0, [r5, #0]
 8002bfe:	2208      	movs	r2, #8
 8002c00:	491f      	ldr	r1, [pc, #124]	; (8002c80 <send_hm10_renew_cmd+0xa8>)
 8002c02:	f002 fabf 	bl	8005184 <HAL_UART_Transmit>
  switch (HAL_status)
 8002c06:	2801      	cmp	r0, #1
    ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_RENEW_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002c08:	4606      	mov	r6, r0
  switch (HAL_status)
 8002c0a:	d006      	beq.n	8002c1a <send_hm10_renew_cmd+0x42>
 8002c0c:	1e83      	subs	r3, r0, #2
 8002c0e:	b2db      	uxtb	r3, r3
 8002c10:	2b01      	cmp	r3, #1
 8002c12:	d805      	bhi.n	8002c20 <send_hm10_renew_cmd+0x48>
		return HM10_EC_NR;
 8002c14:	2602      	movs	r6, #2
}
 8002c16:	4630      	mov	r0, r6
 8002c18:	bd70      	pop	{r4, r5, r6, pc}
            return HM10_EC_ERR;
 8002c1a:	2604      	movs	r6, #4
}
 8002c1c:	4630      	mov	r0, r6
 8002c1e:	bd70      	pop	{r4, r5, r6, pc}
    if (ret != HAL_OK)
 8002c20:	2800      	cmp	r0, #0
 8002c22:	d1f8      	bne.n	8002c16 <send_hm10_renew_cmd+0x3e>
    ret = HAL_UART_Receive(p_huart, TxRx_Buffer, HM10_RENEW_RESPONSE_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002c24:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8002c28:	2208      	movs	r2, #8
 8002c2a:	4915      	ldr	r1, [pc, #84]	; (8002c80 <send_hm10_renew_cmd+0xa8>)
 8002c2c:	6828      	ldr	r0, [r5, #0]
 8002c2e:	f002 fb4b 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 8002c32:	2801      	cmp	r0, #1
    ret = HAL_UART_Receive(p_huart, TxRx_Buffer, HM10_RENEW_RESPONSE_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002c34:	4606      	mov	r6, r0
  switch (HAL_status)
 8002c36:	d0f0      	beq.n	8002c1a <send_hm10_renew_cmd+0x42>
 8002c38:	1e83      	subs	r3, r0, #2
 8002c3a:	b2db      	uxtb	r3, r3
 8002c3c:	2b01      	cmp	r3, #1
 8002c3e:	d9e9      	bls.n	8002c14 <send_hm10_renew_cmd+0x3c>
    if (ret != HAL_OK)
 8002c40:	2800      	cmp	r0, #0
 8002c42:	d1e8      	bne.n	8002c16 <send_hm10_renew_cmd+0x3e>
        if (TxRx_Buffer[i] != HM10_Renew_resp[i])
 8002c44:	7823      	ldrb	r3, [r4, #0]
 8002c46:	2b4f      	cmp	r3, #79	; 0x4f
 8002c48:	d1e7      	bne.n	8002c1a <send_hm10_renew_cmd+0x42>
 8002c4a:	7863      	ldrb	r3, [r4, #1]
 8002c4c:	2b4b      	cmp	r3, #75	; 0x4b
 8002c4e:	d1e4      	bne.n	8002c1a <send_hm10_renew_cmd+0x42>
 8002c50:	78a3      	ldrb	r3, [r4, #2]
 8002c52:	2b2b      	cmp	r3, #43	; 0x2b
 8002c54:	d1e1      	bne.n	8002c1a <send_hm10_renew_cmd+0x42>
 8002c56:	78e3      	ldrb	r3, [r4, #3]
 8002c58:	2b52      	cmp	r3, #82	; 0x52
 8002c5a:	d1de      	bne.n	8002c1a <send_hm10_renew_cmd+0x42>
 8002c5c:	7923      	ldrb	r3, [r4, #4]
 8002c5e:	2b45      	cmp	r3, #69	; 0x45
 8002c60:	d1db      	bne.n	8002c1a <send_hm10_renew_cmd+0x42>
 8002c62:	7963      	ldrb	r3, [r4, #5]
 8002c64:	2b4e      	cmp	r3, #78	; 0x4e
 8002c66:	d1d8      	bne.n	8002c1a <send_hm10_renew_cmd+0x42>
 8002c68:	79a3      	ldrb	r3, [r4, #6]
 8002c6a:	2b45      	cmp	r3, #69	; 0x45
 8002c6c:	d1d5      	bne.n	8002c1a <send_hm10_renew_cmd+0x42>
 8002c6e:	79e3      	ldrb	r3, [r4, #7]
 8002c70:	2b57      	cmp	r3, #87	; 0x57
 8002c72:	d1d2      	bne.n	8002c1a <send_hm10_renew_cmd+0x42>
    HAL_Delay(HM10_RESET_AND_RENEW_CMDS_DELAY);
 8002c74:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002c78:	f000 fffe 	bl	8003c78 <HAL_Delay>
    return HM10_EC_OK;
 8002c7c:	e7cb      	b.n	8002c16 <send_hm10_renew_cmd+0x3e>
 8002c7e:	bf00      	nop
 8002c80:	20000488 	.word	0x20000488
 8002c84:	2000049c 	.word	0x2000049c
 8002c88:	522b5441 	.word	0x522b5441
 8002c8c:	57454e45 	.word	0x57454e45

08002c90 <set_hm10_name>:
	if (size > HM10_MAX_BLE_NAME_SIZE)
 8002c90:	290c      	cmp	r1, #12
 8002c92:	f200 8132 	bhi.w	8002efa <set_hm10_name+0x26a>
{
 8002c96:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002c9a:	460e      	mov	r6, r1
 8002c9c:	4607      	mov	r7, r0
 8002c9e:	4c99      	ldr	r4, [pc, #612]	; (8002f04 <set_hm10_name+0x274>)
 8002ca0:	4d99      	ldr	r5, [pc, #612]	; (8002f08 <set_hm10_name+0x278>)
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, 1, HM10_CUSTOM_HAL_TIMEOUT);
 8002ca2:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8002ca6:	2201      	movs	r2, #1
 8002ca8:	4621      	mov	r1, r4
 8002caa:	6828      	ldr	r0, [r5, #0]
 8002cac:	f002 fb0c 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 8002cb0:	2803      	cmp	r0, #3
 8002cb2:	d1f6      	bne.n	8002ca2 <set_hm10_name+0x12>
	TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'A';
 8002cb4:	4b95      	ldr	r3, [pc, #596]	; (8002f0c <set_hm10_name+0x27c>)
	TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'E';
 8002cb6:	2245      	movs	r2, #69	; 0x45
	TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'A';
 8002cb8:	6023      	str	r3, [r4, #0]
	TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'A';
 8002cba:	f644 5341 	movw	r3, #19777	; 0x4d41
	uint8_t size_with_offset = size + bytes_populated_in_TxRx_Buffer;
 8002cbe:	f106 0807 	add.w	r8, r6, #7
 8002cc2:	fa5f f888 	uxtb.w	r8, r8
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002cc6:	f1b8 0f07 	cmp.w	r8, #7
	TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'E';
 8002cca:	71a2      	strb	r2, [r4, #6]
	TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'A';
 8002ccc:	80a3      	strh	r3, [r4, #4]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002cce:	f000 8116 	beq.w	8002efe <set_hm10_name+0x26e>
 8002cd2:	4b8f      	ldr	r3, [pc, #572]	; (8002f10 <set_hm10_name+0x280>)
 8002cd4:	1bdb      	subs	r3, r3, r7
 8002cd6:	2b02      	cmp	r3, #2
 8002cd8:	f240 80cb 	bls.w	8002e72 <set_hm10_name+0x1e2>
 8002cdc:	1e73      	subs	r3, r6, #1
 8002cde:	2b05      	cmp	r3, #5
 8002ce0:	f240 80c7 	bls.w	8002e72 <set_hm10_name+0x1e2>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ce4:	683b      	ldr	r3, [r7, #0]
 8002ce6:	f8c4 3007 	str.w	r3, [r4, #7]
 8002cea:	08b3      	lsrs	r3, r6, #2
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002cec:	2b01      	cmp	r3, #1
 8002cee:	f000 80a2 	beq.w	8002e36 <set_hm10_name+0x1a6>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002cf2:	687a      	ldr	r2, [r7, #4]
 8002cf4:	2b03      	cmp	r3, #3
 8002cf6:	f8c4 200b 	str.w	r2, [r4, #11]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002cfa:	f040 809c 	bne.w	8002e36 <set_hm10_name+0x1a6>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002cfe:	68bb      	ldr	r3, [r7, #8]
 8002d00:	f8c4 300f 	str.w	r3, [r4, #15]
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, bytes_populated_in_TxRx_Buffer, HM10_CUSTOM_HAL_TIMEOUT);
 8002d04:	fa1f f288 	uxth.w	r2, r8
 8002d08:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8002d0c:	497d      	ldr	r1, [pc, #500]	; (8002f04 <set_hm10_name+0x274>)
 8002d0e:	6828      	ldr	r0, [r5, #0]
 8002d10:	f002 fa38 	bl	8005184 <HAL_UART_Transmit>
  switch (HAL_status)
 8002d14:	2801      	cmp	r0, #1
 8002d16:	f000 808b 	beq.w	8002e30 <set_hm10_name+0x1a0>
 8002d1a:	1e83      	subs	r3, r0, #2
 8002d1c:	b2db      	uxtb	r3, r3
 8002d1e:	2b01      	cmp	r3, #1
 8002d20:	d802      	bhi.n	8002d28 <set_hm10_name+0x98>
		return HM10_EC_NR;
 8002d22:	2002      	movs	r0, #2
}
 8002d24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (ret != HAL_OK)
 8002d28:	2800      	cmp	r0, #0
 8002d2a:	d1fb      	bne.n	8002d24 <set_hm10_name+0x94>
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, bytes_populated_in_TxRx_Buffer, HM10_CUSTOM_HAL_TIMEOUT);
 8002d2c:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8002d30:	4642      	mov	r2, r8
 8002d32:	6828      	ldr	r0, [r5, #0]
 8002d34:	4973      	ldr	r1, [pc, #460]	; (8002f04 <set_hm10_name+0x274>)
 8002d36:	f002 fac7 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 8002d3a:	2801      	cmp	r0, #1
 8002d3c:	d078      	beq.n	8002e30 <set_hm10_name+0x1a0>
 8002d3e:	1e83      	subs	r3, r0, #2
 8002d40:	b2db      	uxtb	r3, r3
 8002d42:	2b01      	cmp	r3, #1
 8002d44:	d9ed      	bls.n	8002d22 <set_hm10_name+0x92>
	if (ret != HAL_OK)
 8002d46:	2800      	cmp	r0, #0
 8002d48:	d1ec      	bne.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared] != HM10_Set_Name_resp_without_name_value[bytes_compared])
 8002d4a:	4b72      	ldr	r3, [pc, #456]	; (8002f14 <set_hm10_name+0x284>)
 8002d4c:	7821      	ldrb	r1, [r4, #0]
 8002d4e:	781a      	ldrb	r2, [r3, #0]
 8002d50:	4291      	cmp	r1, r2
 8002d52:	d16d      	bne.n	8002e30 <set_hm10_name+0x1a0>
 8002d54:	7861      	ldrb	r1, [r4, #1]
 8002d56:	785a      	ldrb	r2, [r3, #1]
 8002d58:	4291      	cmp	r1, r2
 8002d5a:	d169      	bne.n	8002e30 <set_hm10_name+0x1a0>
 8002d5c:	78a1      	ldrb	r1, [r4, #2]
 8002d5e:	789a      	ldrb	r2, [r3, #2]
 8002d60:	4291      	cmp	r1, r2
 8002d62:	d165      	bne.n	8002e30 <set_hm10_name+0x1a0>
 8002d64:	78e1      	ldrb	r1, [r4, #3]
 8002d66:	78da      	ldrb	r2, [r3, #3]
 8002d68:	4291      	cmp	r1, r2
 8002d6a:	d161      	bne.n	8002e30 <set_hm10_name+0x1a0>
 8002d6c:	7921      	ldrb	r1, [r4, #4]
 8002d6e:	791a      	ldrb	r2, [r3, #4]
 8002d70:	4291      	cmp	r1, r2
 8002d72:	d15d      	bne.n	8002e30 <set_hm10_name+0x1a0>
 8002d74:	7961      	ldrb	r1, [r4, #5]
 8002d76:	795a      	ldrb	r2, [r3, #5]
 8002d78:	4291      	cmp	r1, r2
 8002d7a:	d159      	bne.n	8002e30 <set_hm10_name+0x1a0>
 8002d7c:	799b      	ldrb	r3, [r3, #6]
 8002d7e:	79a2      	ldrb	r2, [r4, #6]
 8002d80:	429a      	cmp	r2, r3
 8002d82:	d155      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002d84:	f1b8 0f07 	cmp.w	r8, #7
 8002d88:	d0cc      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002d8a:	79e2      	ldrb	r2, [r4, #7]
 8002d8c:	783b      	ldrb	r3, [r7, #0]
 8002d8e:	429a      	cmp	r2, r3
 8002d90:	d14e      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002d92:	f1b8 0f08 	cmp.w	r8, #8
 8002d96:	d0c5      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002d98:	7a22      	ldrb	r2, [r4, #8]
 8002d9a:	787b      	ldrb	r3, [r7, #1]
 8002d9c:	429a      	cmp	r2, r3
 8002d9e:	d147      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002da0:	f1b8 0f09 	cmp.w	r8, #9
 8002da4:	d0be      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002da6:	7a62      	ldrb	r2, [r4, #9]
 8002da8:	78bb      	ldrb	r3, [r7, #2]
 8002daa:	429a      	cmp	r2, r3
 8002dac:	d140      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002dae:	f1b8 0f0a 	cmp.w	r8, #10
 8002db2:	d0b7      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002db4:	7aa2      	ldrb	r2, [r4, #10]
 8002db6:	78fb      	ldrb	r3, [r7, #3]
 8002db8:	429a      	cmp	r2, r3
 8002dba:	d139      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002dbc:	f1b8 0f0b 	cmp.w	r8, #11
 8002dc0:	d0b0      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002dc2:	7ae2      	ldrb	r2, [r4, #11]
 8002dc4:	793b      	ldrb	r3, [r7, #4]
 8002dc6:	429a      	cmp	r2, r3
 8002dc8:	d132      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002dca:	f1b8 0f0c 	cmp.w	r8, #12
 8002dce:	d0a9      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002dd0:	7b22      	ldrb	r2, [r4, #12]
 8002dd2:	797b      	ldrb	r3, [r7, #5]
 8002dd4:	429a      	cmp	r2, r3
 8002dd6:	d12b      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002dd8:	f1b8 0f0d 	cmp.w	r8, #13
 8002ddc:	d0a2      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002dde:	7b62      	ldrb	r2, [r4, #13]
 8002de0:	79bb      	ldrb	r3, [r7, #6]
 8002de2:	429a      	cmp	r2, r3
 8002de4:	d124      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002de6:	f1b8 0f0e 	cmp.w	r8, #14
 8002dea:	d09b      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002dec:	7ba2      	ldrb	r2, [r4, #14]
 8002dee:	79fb      	ldrb	r3, [r7, #7]
 8002df0:	429a      	cmp	r2, r3
 8002df2:	d11d      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002df4:	f1b8 0f0f 	cmp.w	r8, #15
 8002df8:	d094      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002dfa:	7be2      	ldrb	r2, [r4, #15]
 8002dfc:	7a3b      	ldrb	r3, [r7, #8]
 8002dfe:	429a      	cmp	r2, r3
 8002e00:	d116      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002e02:	f1b8 0f10 	cmp.w	r8, #16
 8002e06:	d08d      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002e08:	7c22      	ldrb	r2, [r4, #16]
 8002e0a:	7a7b      	ldrb	r3, [r7, #9]
 8002e0c:	429a      	cmp	r2, r3
 8002e0e:	d10f      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002e10:	f1b8 0f11 	cmp.w	r8, #17
 8002e14:	d086      	beq.n	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002e16:	7c62      	ldrb	r2, [r4, #17]
 8002e18:	7abb      	ldrb	r3, [r7, #10]
 8002e1a:	429a      	cmp	r2, r3
 8002e1c:	d108      	bne.n	8002e30 <set_hm10_name+0x1a0>
	for (uint8_t i=0; bytes_compared<size_with_offset; i++)
 8002e1e:	f1b8 0f13 	cmp.w	r8, #19
 8002e22:	f47f af7f 	bne.w	8002d24 <set_hm10_name+0x94>
		if (TxRx_Buffer[bytes_compared++] != hm10_name[i])
 8002e26:	7ca2      	ldrb	r2, [r4, #18]
 8002e28:	7afb      	ldrb	r3, [r7, #11]
 8002e2a:	429a      	cmp	r2, r3
 8002e2c:	f43f af7a 	beq.w	8002d24 <set_hm10_name+0x94>
	  case HAL_ERROR:
		return HM10_EC_ERR;
 8002e30:	2004      	movs	r0, #4
}
 8002e32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002e36:	f006 03fc 	and.w	r3, r6, #252	; 0xfc
 8002e3a:	1dda      	adds	r2, r3, #7
 8002e3c:	429e      	cmp	r6, r3
 8002e3e:	b2d2      	uxtb	r2, r2
 8002e40:	f43f af60 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e44:	5cf9      	ldrb	r1, [r7, r3]
 8002e46:	54a1      	strb	r1, [r4, r2]
 8002e48:	f103 0208 	add.w	r2, r3, #8
 8002e4c:	b2d2      	uxtb	r2, r2
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e4e:	1c59      	adds	r1, r3, #1
 8002e50:	4590      	cmp	r8, r2
 8002e52:	b2c9      	uxtb	r1, r1
 8002e54:	f67f af56 	bls.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e58:	5c79      	ldrb	r1, [r7, r1]
 8002e5a:	54a1      	strb	r1, [r4, r2]
 8002e5c:	f103 0209 	add.w	r2, r3, #9
 8002e60:	b2d2      	uxtb	r2, r2
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e62:	3302      	adds	r3, #2
 8002e64:	4590      	cmp	r8, r2
 8002e66:	b2db      	uxtb	r3, r3
 8002e68:	f67f af4c 	bls.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e6c:	5cfb      	ldrb	r3, [r7, r3]
 8002e6e:	54a3      	strb	r3, [r4, r2]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e70:	e748      	b.n	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e72:	783b      	ldrb	r3, [r7, #0]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e74:	f1b8 0f08 	cmp.w	r8, #8
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e78:	71e3      	strb	r3, [r4, #7]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e7a:	f43f af43 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e7e:	787b      	ldrb	r3, [r7, #1]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e80:	f1b8 0f09 	cmp.w	r8, #9
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e84:	7223      	strb	r3, [r4, #8]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e86:	f43f af3d 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e8a:	78bb      	ldrb	r3, [r7, #2]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e8c:	f1b8 0f0a 	cmp.w	r8, #10
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e90:	7263      	strb	r3, [r4, #9]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e92:	f43f af37 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e96:	78fb      	ldrb	r3, [r7, #3]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e98:	f1b8 0f0b 	cmp.w	r8, #11
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002e9c:	72a3      	strb	r3, [r4, #10]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002e9e:	f43f af31 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ea2:	793b      	ldrb	r3, [r7, #4]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002ea4:	f1b8 0f0c 	cmp.w	r8, #12
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ea8:	72e3      	strb	r3, [r4, #11]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002eaa:	f43f af2b 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002eae:	797b      	ldrb	r3, [r7, #5]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002eb0:	f1b8 0f0d 	cmp.w	r8, #13
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002eb4:	7323      	strb	r3, [r4, #12]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002eb6:	f43f af25 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002eba:	79bb      	ldrb	r3, [r7, #6]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002ebc:	f1b8 0f0e 	cmp.w	r8, #14
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ec0:	7363      	strb	r3, [r4, #13]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002ec2:	f43f af1f 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ec6:	79fb      	ldrb	r3, [r7, #7]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002ec8:	f1b8 0f0f 	cmp.w	r8, #15
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ecc:	73a3      	strb	r3, [r4, #14]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002ece:	f43f af19 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ed2:	7a3b      	ldrb	r3, [r7, #8]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002ed4:	f1b8 0f10 	cmp.w	r8, #16
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ed8:	73e3      	strb	r3, [r4, #15]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002eda:	f43f af13 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ede:	7a7b      	ldrb	r3, [r7, #9]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002ee0:	f1b8 0f11 	cmp.w	r8, #17
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ee4:	7423      	strb	r3, [r4, #16]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002ee6:	f43f af0d 	beq.w	8002d04 <set_hm10_name+0x74>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002eea:	7abb      	ldrb	r3, [r7, #10]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002eec:	f1b8 0f13 	cmp.w	r8, #19
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = hm10_name[i];
 8002ef0:	7463      	strb	r3, [r4, #17]
 8002ef2:	bf04      	itt	eq
 8002ef4:	7afb      	ldrbeq	r3, [r7, #11]
 8002ef6:	74a3      	strbeq	r3, [r4, #18]
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002ef8:	e704      	b.n	8002d04 <set_hm10_name+0x74>
		return HM10_EC_ERR;
 8002efa:	2004      	movs	r0, #4
}
 8002efc:	4770      	bx	lr
	for (uint8_t i=0; bytes_populated_in_TxRx_Buffer<size_with_offset; i++)
 8002efe:	4642      	mov	r2, r8
 8002f00:	e702      	b.n	8002d08 <set_hm10_name+0x78>
 8002f02:	bf00      	nop
 8002f04:	20000488 	.word	0x20000488
 8002f08:	2000049c 	.word	0x2000049c
 8002f0c:	4e2b5441 	.word	0x4e2b5441
 8002f10:	2000048e 	.word	0x2000048e
 8002f14:	20000000 	.word	0x20000000

08002f18 <set_hm10_role>:
	switch (ble_role)
 8002f18:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 8002f1c:	2b01      	cmp	r3, #1
 8002f1e:	d901      	bls.n	8002f24 <set_hm10_role+0xc>
			return HM10_EC_ERR;
 8002f20:	2004      	movs	r0, #4
}
 8002f22:	4770      	bx	lr
{
 8002f24:	b570      	push	{r4, r5, r6, lr}
 8002f26:	4605      	mov	r5, r0
 8002f28:	4c2d      	ldr	r4, [pc, #180]	; (8002fe0 <set_hm10_role+0xc8>)
 8002f2a:	4e2e      	ldr	r6, [pc, #184]	; (8002fe4 <set_hm10_role+0xcc>)
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, 1, HM10_CUSTOM_HAL_TIMEOUT);
 8002f2c:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8002f30:	2201      	movs	r2, #1
 8002f32:	4621      	mov	r1, r4
 8002f34:	6830      	ldr	r0, [r6, #0]
 8002f36:	f002 f9c7 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 8002f3a:	2803      	cmp	r0, #3
 8002f3c:	d1f6      	bne.n	8002f2c <set_hm10_role+0x14>
	TxRx_Buffer[4] = 'O';
 8002f3e:	f644 4e4f 	movw	lr, #19535	; 0x4c4f
	TxRx_Buffer[6] = 'E';
 8002f42:	f04f 0c45 	mov.w	ip, #69	; 0x45
	TxRx_Buffer[0] = 'A';
 8002f46:	4b28      	ldr	r3, [pc, #160]	; (8002fe8 <set_hm10_role+0xd0>)
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_SET_ROLE_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002f48:	2208      	movs	r2, #8
	TxRx_Buffer[0] = 'A';
 8002f4a:	6023      	str	r3, [r4, #0]
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_SET_ROLE_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002f4c:	4924      	ldr	r1, [pc, #144]	; (8002fe0 <set_hm10_role+0xc8>)
 8002f4e:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8002f52:	6830      	ldr	r0, [r6, #0]
	TxRx_Buffer[7] = ble_role;
 8002f54:	71e5      	strb	r5, [r4, #7]
	TxRx_Buffer[4] = 'O';
 8002f56:	f8a4 e004 	strh.w	lr, [r4, #4]
	TxRx_Buffer[6] = 'E';
 8002f5a:	f884 c006 	strb.w	ip, [r4, #6]
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_SET_ROLE_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002f5e:	f002 f911 	bl	8005184 <HAL_UART_Transmit>
  switch (HAL_status)
 8002f62:	2801      	cmp	r0, #1
 8002f64:	d010      	beq.n	8002f88 <set_hm10_role+0x70>
 8002f66:	1e82      	subs	r2, r0, #2
 8002f68:	b2d2      	uxtb	r2, r2
 8002f6a:	2a01      	cmp	r2, #1
 8002f6c:	d801      	bhi.n	8002f72 <set_hm10_role+0x5a>
		return HM10_EC_NR;
 8002f6e:	2002      	movs	r0, #2
}
 8002f70:	bd70      	pop	{r4, r5, r6, pc}
	if (ret != HAL_OK)
 8002f72:	2800      	cmp	r0, #0
 8002f74:	d1fc      	bne.n	8002f70 <set_hm10_role+0x58>
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, HM10_ROLE_RESPONSE_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8002f76:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8002f7a:	2208      	movs	r2, #8
 8002f7c:	6830      	ldr	r0, [r6, #0]
 8002f7e:	4918      	ldr	r1, [pc, #96]	; (8002fe0 <set_hm10_role+0xc8>)
 8002f80:	f002 f9a2 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 8002f84:	2801      	cmp	r0, #1
 8002f86:	d101      	bne.n	8002f8c <set_hm10_role+0x74>
		return HM10_EC_ERR;
 8002f88:	2004      	movs	r0, #4
}
 8002f8a:	bd70      	pop	{r4, r5, r6, pc}
  switch (HAL_status)
 8002f8c:	1e82      	subs	r2, r0, #2
 8002f8e:	b2d2      	uxtb	r2, r2
 8002f90:	2a01      	cmp	r2, #1
 8002f92:	d9ec      	bls.n	8002f6e <set_hm10_role+0x56>
	if (ret != HAL_OK)
 8002f94:	2800      	cmp	r0, #0
 8002f96:	d1eb      	bne.n	8002f70 <set_hm10_role+0x58>
		if (TxRx_Buffer[bytes_compared] != HM10_Set_Role_resp_without_role_value[bytes_compared])
 8002f98:	4b14      	ldr	r3, [pc, #80]	; (8002fec <set_hm10_role+0xd4>)
 8002f9a:	7822      	ldrb	r2, [r4, #0]
 8002f9c:	7819      	ldrb	r1, [r3, #0]
 8002f9e:	4291      	cmp	r1, r2
 8002fa0:	d1f2      	bne.n	8002f88 <set_hm10_role+0x70>
 8002fa2:	7861      	ldrb	r1, [r4, #1]
 8002fa4:	785a      	ldrb	r2, [r3, #1]
 8002fa6:	4291      	cmp	r1, r2
 8002fa8:	d1ee      	bne.n	8002f88 <set_hm10_role+0x70>
 8002faa:	78a1      	ldrb	r1, [r4, #2]
 8002fac:	789a      	ldrb	r2, [r3, #2]
 8002fae:	4291      	cmp	r1, r2
 8002fb0:	d1ea      	bne.n	8002f88 <set_hm10_role+0x70>
 8002fb2:	78e1      	ldrb	r1, [r4, #3]
 8002fb4:	78da      	ldrb	r2, [r3, #3]
 8002fb6:	4291      	cmp	r1, r2
 8002fb8:	d1e6      	bne.n	8002f88 <set_hm10_role+0x70>
 8002fba:	7921      	ldrb	r1, [r4, #4]
 8002fbc:	791a      	ldrb	r2, [r3, #4]
 8002fbe:	4291      	cmp	r1, r2
 8002fc0:	d1e2      	bne.n	8002f88 <set_hm10_role+0x70>
 8002fc2:	7961      	ldrb	r1, [r4, #5]
 8002fc4:	795a      	ldrb	r2, [r3, #5]
 8002fc6:	4291      	cmp	r1, r2
 8002fc8:	d1de      	bne.n	8002f88 <set_hm10_role+0x70>
 8002fca:	79a2      	ldrb	r2, [r4, #6]
 8002fcc:	799b      	ldrb	r3, [r3, #6]
 8002fce:	429a      	cmp	r2, r3
 8002fd0:	d1da      	bne.n	8002f88 <set_hm10_role+0x70>
	if (TxRx_Buffer[bytes_compared] != ble_role)
 8002fd2:	79e0      	ldrb	r0, [r4, #7]
 8002fd4:	1b40      	subs	r0, r0, r5
 8002fd6:	bf18      	it	ne
 8002fd8:	2001      	movne	r0, #1
 8002fda:	0080      	lsls	r0, r0, #2
}
 8002fdc:	bd70      	pop	{r4, r5, r6, pc}
 8002fde:	bf00      	nop
 8002fe0:	20000488 	.word	0x20000488
 8002fe4:	2000049c 	.word	0x2000049c
 8002fe8:	522b5441 	.word	0x522b5441
 8002fec:	20000000 	.word	0x20000000

08002ff0 <set_hm10_pin>:
{
 8002ff0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		switch (pin[current_pin_character])
 8002ff2:	7803      	ldrb	r3, [r0, #0]
 8002ff4:	3b30      	subs	r3, #48	; 0x30
 8002ff6:	2b09      	cmp	r3, #9
 8002ff8:	f200 808a 	bhi.w	8003110 <set_hm10_pin+0x120>
 8002ffc:	7843      	ldrb	r3, [r0, #1]
 8002ffe:	4605      	mov	r5, r0
 8003000:	3b30      	subs	r3, #48	; 0x30
 8003002:	2b09      	cmp	r3, #9
 8003004:	f100 0701 	add.w	r7, r0, #1
 8003008:	f200 8082 	bhi.w	8003110 <set_hm10_pin+0x120>
 800300c:	7883      	ldrb	r3, [r0, #2]
 800300e:	3b30      	subs	r3, #48	; 0x30
 8003010:	2b09      	cmp	r3, #9
 8003012:	d87d      	bhi.n	8003110 <set_hm10_pin+0x120>
 8003014:	78c3      	ldrb	r3, [r0, #3]
 8003016:	3b30      	subs	r3, #48	; 0x30
 8003018:	2b09      	cmp	r3, #9
 800301a:	d879      	bhi.n	8003110 <set_hm10_pin+0x120>
 800301c:	7903      	ldrb	r3, [r0, #4]
 800301e:	3b30      	subs	r3, #48	; 0x30
 8003020:	2b09      	cmp	r3, #9
 8003022:	d875      	bhi.n	8003110 <set_hm10_pin+0x120>
 8003024:	7943      	ldrb	r3, [r0, #5]
 8003026:	3b30      	subs	r3, #48	; 0x30
 8003028:	2b09      	cmp	r3, #9
 800302a:	d871      	bhi.n	8003110 <set_hm10_pin+0x120>
 800302c:	4c40      	ldr	r4, [pc, #256]	; (8003130 <set_hm10_pin+0x140>)
 800302e:	4e41      	ldr	r6, [pc, #260]	; (8003134 <set_hm10_pin+0x144>)
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, 1, HM10_CUSTOM_HAL_TIMEOUT);
 8003030:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8003034:	2201      	movs	r2, #1
 8003036:	4621      	mov	r1, r4
 8003038:	6830      	ldr	r0, [r6, #0]
 800303a:	f002 f945 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 800303e:	2803      	cmp	r0, #3
 8003040:	d1f6      	bne.n	8003030 <set_hm10_pin+0x40>
	TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'A';
 8003042:	4b3d      	ldr	r3, [pc, #244]	; (8003138 <set_hm10_pin+0x148>)
    TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'S';
 8003044:	2253      	movs	r2, #83	; 0x53
	TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'A';
 8003046:	6023      	str	r3, [r4, #0]
	TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'A';
 8003048:	f245 3341 	movw	r3, #21313	; 0x5341
 800304c:	80a3      	strh	r3, [r4, #4]
	for (uint8_t current_pin_character=0; bytes_populated_in_TxRx_Buffer<HM10_SET_PIN_CMD_SIZE; current_pin_character++)
 800304e:	4b3b      	ldr	r3, [pc, #236]	; (800313c <set_hm10_pin+0x14c>)
    TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = 'S';
 8003050:	71a2      	strb	r2, [r4, #6]
 8003052:	1bdb      	subs	r3, r3, r7
 8003054:	2b02      	cmp	r3, #2
 8003056:	d95d      	bls.n	8003114 <set_hm10_pin+0x124>
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = pin[current_pin_character];
 8003058:	682b      	ldr	r3, [r5, #0]
 800305a:	f8c4 3007 	str.w	r3, [r4, #7]
 800305e:	792b      	ldrb	r3, [r5, #4]
 8003060:	72e3      	strb	r3, [r4, #11]
 8003062:	796b      	ldrb	r3, [r5, #5]
 8003064:	7323      	strb	r3, [r4, #12]
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_SET_PIN_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8003066:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800306a:	220d      	movs	r2, #13
 800306c:	4930      	ldr	r1, [pc, #192]	; (8003130 <set_hm10_pin+0x140>)
 800306e:	6830      	ldr	r0, [r6, #0]
 8003070:	f002 f888 	bl	8005184 <HAL_UART_Transmit>
  switch (HAL_status)
 8003074:	2801      	cmp	r0, #1
 8003076:	d04b      	beq.n	8003110 <set_hm10_pin+0x120>
 8003078:	1e83      	subs	r3, r0, #2
 800307a:	b2db      	uxtb	r3, r3
 800307c:	2b01      	cmp	r3, #1
 800307e:	d801      	bhi.n	8003084 <set_hm10_pin+0x94>
		return HM10_EC_NR;
 8003080:	2002      	movs	r0, #2
}
 8003082:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (ret != HAL_OK)
 8003084:	2800      	cmp	r0, #0
 8003086:	d1fc      	bne.n	8003082 <set_hm10_pin+0x92>
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, HM10_PIN_RESPONSE_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8003088:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800308c:	220d      	movs	r2, #13
 800308e:	6830      	ldr	r0, [r6, #0]
 8003090:	4927      	ldr	r1, [pc, #156]	; (8003130 <set_hm10_pin+0x140>)
 8003092:	f002 f919 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 8003096:	2801      	cmp	r0, #1
 8003098:	d03a      	beq.n	8003110 <set_hm10_pin+0x120>
 800309a:	1e83      	subs	r3, r0, #2
 800309c:	b2db      	uxtb	r3, r3
 800309e:	2b01      	cmp	r3, #1
 80030a0:	d9ee      	bls.n	8003080 <set_hm10_pin+0x90>
	if (ret != HAL_OK)
 80030a2:	2800      	cmp	r0, #0
 80030a4:	d1ed      	bne.n	8003082 <set_hm10_pin+0x92>
		if (TxRx_Buffer[bytes_compared] != HM10_Set_Pin_resp_without_pin_value[bytes_compared])
 80030a6:	4b26      	ldr	r3, [pc, #152]	; (8003140 <set_hm10_pin+0x150>)
 80030a8:	7821      	ldrb	r1, [r4, #0]
 80030aa:	781a      	ldrb	r2, [r3, #0]
 80030ac:	4291      	cmp	r1, r2
 80030ae:	d12f      	bne.n	8003110 <set_hm10_pin+0x120>
 80030b0:	7861      	ldrb	r1, [r4, #1]
 80030b2:	785a      	ldrb	r2, [r3, #1]
 80030b4:	4291      	cmp	r1, r2
 80030b6:	d12b      	bne.n	8003110 <set_hm10_pin+0x120>
 80030b8:	78a1      	ldrb	r1, [r4, #2]
 80030ba:	789a      	ldrb	r2, [r3, #2]
 80030bc:	4291      	cmp	r1, r2
 80030be:	d127      	bne.n	8003110 <set_hm10_pin+0x120>
 80030c0:	78e1      	ldrb	r1, [r4, #3]
 80030c2:	78da      	ldrb	r2, [r3, #3]
 80030c4:	4291      	cmp	r1, r2
 80030c6:	d123      	bne.n	8003110 <set_hm10_pin+0x120>
 80030c8:	7921      	ldrb	r1, [r4, #4]
 80030ca:	791a      	ldrb	r2, [r3, #4]
 80030cc:	4291      	cmp	r1, r2
 80030ce:	d11f      	bne.n	8003110 <set_hm10_pin+0x120>
 80030d0:	7961      	ldrb	r1, [r4, #5]
 80030d2:	795a      	ldrb	r2, [r3, #5]
 80030d4:	4291      	cmp	r1, r2
 80030d6:	d11b      	bne.n	8003110 <set_hm10_pin+0x120>
 80030d8:	79a2      	ldrb	r2, [r4, #6]
 80030da:	799b      	ldrb	r3, [r3, #6]
 80030dc:	429a      	cmp	r2, r3
 80030de:	d117      	bne.n	8003110 <set_hm10_pin+0x120>
		if (TxRx_Buffer[bytes_compared++] != pin[current_pin_character])
 80030e0:	79e2      	ldrb	r2, [r4, #7]
 80030e2:	782b      	ldrb	r3, [r5, #0]
 80030e4:	429a      	cmp	r2, r3
 80030e6:	d113      	bne.n	8003110 <set_hm10_pin+0x120>
 80030e8:	7a22      	ldrb	r2, [r4, #8]
 80030ea:	786b      	ldrb	r3, [r5, #1]
 80030ec:	429a      	cmp	r2, r3
 80030ee:	d10f      	bne.n	8003110 <set_hm10_pin+0x120>
 80030f0:	7a62      	ldrb	r2, [r4, #9]
 80030f2:	78ab      	ldrb	r3, [r5, #2]
 80030f4:	429a      	cmp	r2, r3
 80030f6:	d10b      	bne.n	8003110 <set_hm10_pin+0x120>
 80030f8:	7aa2      	ldrb	r2, [r4, #10]
 80030fa:	78eb      	ldrb	r3, [r5, #3]
 80030fc:	429a      	cmp	r2, r3
 80030fe:	d107      	bne.n	8003110 <set_hm10_pin+0x120>
 8003100:	7ae2      	ldrb	r2, [r4, #11]
 8003102:	792b      	ldrb	r3, [r5, #4]
 8003104:	429a      	cmp	r2, r3
 8003106:	d103      	bne.n	8003110 <set_hm10_pin+0x120>
 8003108:	7b22      	ldrb	r2, [r4, #12]
 800310a:	796b      	ldrb	r3, [r5, #5]
 800310c:	429a      	cmp	r2, r3
 800310e:	d0b8      	beq.n	8003082 <set_hm10_pin+0x92>
				return HM10_EC_ERR;
 8003110:	2004      	movs	r0, #4
}
 8003112:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		TxRx_Buffer[bytes_populated_in_TxRx_Buffer++] = pin[current_pin_character];
 8003114:	782b      	ldrb	r3, [r5, #0]
 8003116:	71e3      	strb	r3, [r4, #7]
 8003118:	786b      	ldrb	r3, [r5, #1]
 800311a:	7223      	strb	r3, [r4, #8]
 800311c:	78ab      	ldrb	r3, [r5, #2]
 800311e:	7263      	strb	r3, [r4, #9]
 8003120:	78eb      	ldrb	r3, [r5, #3]
 8003122:	72a3      	strb	r3, [r4, #10]
 8003124:	792b      	ldrb	r3, [r5, #4]
 8003126:	72e3      	strb	r3, [r4, #11]
 8003128:	796b      	ldrb	r3, [r5, #5]
 800312a:	7323      	strb	r3, [r4, #12]
	for (uint8_t current_pin_character=0; bytes_populated_in_TxRx_Buffer<HM10_SET_PIN_CMD_SIZE; current_pin_character++)
 800312c:	e79b      	b.n	8003066 <set_hm10_pin+0x76>
 800312e:	bf00      	nop
 8003130:	20000488 	.word	0x20000488
 8003134:	2000049c 	.word	0x2000049c
 8003138:	502b5441 	.word	0x502b5441
 800313c:	2000048f 	.word	0x2000048f
 8003140:	20000000 	.word	0x20000000

08003144 <set_hm10_pin_code_mode>:
	switch (pin_code_mode)
 8003144:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
 8003148:	2b30      	cmp	r3, #48	; 0x30
 800314a:	d001      	beq.n	8003150 <set_hm10_pin_code_mode+0xc>
			return HM10_EC_ERR;
 800314c:	2004      	movs	r0, #4
}
 800314e:	4770      	bx	lr
{
 8003150:	b570      	push	{r4, r5, r6, lr}
 8003152:	4606      	mov	r6, r0
 8003154:	4c2d      	ldr	r4, [pc, #180]	; (800320c <set_hm10_pin_code_mode+0xc8>)
 8003156:	4d2e      	ldr	r5, [pc, #184]	; (8003210 <set_hm10_pin_code_mode+0xcc>)
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, 1, HM10_CUSTOM_HAL_TIMEOUT);
 8003158:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800315c:	2201      	movs	r2, #1
 800315e:	4621      	mov	r1, r4
 8003160:	6828      	ldr	r0, [r5, #0]
 8003162:	f002 f8b1 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 8003166:	2803      	cmp	r0, #3
 8003168:	d1f6      	bne.n	8003158 <set_hm10_pin_code_mode+0x14>
	TxRx_Buffer[4] = 'Y';
 800316a:	f245 0e59 	movw	lr, #20569	; 0x5059
	TxRx_Buffer[6] = 'E';
 800316e:	f04f 0c45 	mov.w	ip, #69	; 0x45
	TxRx_Buffer[0] = 'A';
 8003172:	4b28      	ldr	r3, [pc, #160]	; (8003214 <set_hm10_pin_code_mode+0xd0>)
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_SET_TYPE_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8003174:	2208      	movs	r2, #8
	TxRx_Buffer[0] = 'A';
 8003176:	6023      	str	r3, [r4, #0]
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_SET_TYPE_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8003178:	4924      	ldr	r1, [pc, #144]	; (800320c <set_hm10_pin_code_mode+0xc8>)
 800317a:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800317e:	6828      	ldr	r0, [r5, #0]
	TxRx_Buffer[7] = pin_code_mode;
 8003180:	71e6      	strb	r6, [r4, #7]
	TxRx_Buffer[4] = 'Y';
 8003182:	f8a4 e004 	strh.w	lr, [r4, #4]
	TxRx_Buffer[6] = 'E';
 8003186:	f884 c006 	strb.w	ip, [r4, #6]
	ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_SET_TYPE_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 800318a:	f001 fffb 	bl	8005184 <HAL_UART_Transmit>
  switch (HAL_status)
 800318e:	2801      	cmp	r0, #1
 8003190:	d005      	beq.n	800319e <set_hm10_pin_code_mode+0x5a>
 8003192:	1e83      	subs	r3, r0, #2
 8003194:	b2db      	uxtb	r3, r3
 8003196:	2b01      	cmp	r3, #1
 8003198:	d803      	bhi.n	80031a2 <set_hm10_pin_code_mode+0x5e>
		return HM10_EC_NR;
 800319a:	2002      	movs	r0, #2
}
 800319c:	bd70      	pop	{r4, r5, r6, pc}
			return HM10_EC_ERR;
 800319e:	2004      	movs	r0, #4
}
 80031a0:	bd70      	pop	{r4, r5, r6, pc}
	if (ret != HAL_OK)
 80031a2:	2800      	cmp	r0, #0
 80031a4:	d1fa      	bne.n	800319c <set_hm10_pin_code_mode+0x58>
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, HM10_TYPE_RESPONSE_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 80031a6:	f44f 73a0 	mov.w	r3, #320	; 0x140
 80031aa:	2208      	movs	r2, #8
 80031ac:	6828      	ldr	r0, [r5, #0]
 80031ae:	4917      	ldr	r1, [pc, #92]	; (800320c <set_hm10_pin_code_mode+0xc8>)
 80031b0:	f002 f88a 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 80031b4:	2801      	cmp	r0, #1
 80031b6:	d0f2      	beq.n	800319e <set_hm10_pin_code_mode+0x5a>
 80031b8:	1e83      	subs	r3, r0, #2
 80031ba:	b2db      	uxtb	r3, r3
 80031bc:	2b01      	cmp	r3, #1
 80031be:	d9ec      	bls.n	800319a <set_hm10_pin_code_mode+0x56>
	if (ret != HAL_OK)
 80031c0:	2800      	cmp	r0, #0
 80031c2:	d1eb      	bne.n	800319c <set_hm10_pin_code_mode+0x58>
		if (TxRx_Buffer[bytes_compared] != HM10_Set_Type_resp_without_type_value[bytes_compared])
 80031c4:	4b14      	ldr	r3, [pc, #80]	; (8003218 <set_hm10_pin_code_mode+0xd4>)
 80031c6:	7822      	ldrb	r2, [r4, #0]
 80031c8:	7819      	ldrb	r1, [r3, #0]
 80031ca:	4291      	cmp	r1, r2
 80031cc:	d1e7      	bne.n	800319e <set_hm10_pin_code_mode+0x5a>
 80031ce:	7861      	ldrb	r1, [r4, #1]
 80031d0:	785a      	ldrb	r2, [r3, #1]
 80031d2:	4291      	cmp	r1, r2
 80031d4:	d1e3      	bne.n	800319e <set_hm10_pin_code_mode+0x5a>
 80031d6:	78a1      	ldrb	r1, [r4, #2]
 80031d8:	789a      	ldrb	r2, [r3, #2]
 80031da:	4291      	cmp	r1, r2
 80031dc:	d1df      	bne.n	800319e <set_hm10_pin_code_mode+0x5a>
 80031de:	78e1      	ldrb	r1, [r4, #3]
 80031e0:	78da      	ldrb	r2, [r3, #3]
 80031e2:	4291      	cmp	r1, r2
 80031e4:	d1db      	bne.n	800319e <set_hm10_pin_code_mode+0x5a>
 80031e6:	7921      	ldrb	r1, [r4, #4]
 80031e8:	791a      	ldrb	r2, [r3, #4]
 80031ea:	4291      	cmp	r1, r2
 80031ec:	d1d7      	bne.n	800319e <set_hm10_pin_code_mode+0x5a>
 80031ee:	7961      	ldrb	r1, [r4, #5]
 80031f0:	795a      	ldrb	r2, [r3, #5]
 80031f2:	4291      	cmp	r1, r2
 80031f4:	d1d3      	bne.n	800319e <set_hm10_pin_code_mode+0x5a>
 80031f6:	79a2      	ldrb	r2, [r4, #6]
 80031f8:	799b      	ldrb	r3, [r3, #6]
 80031fa:	429a      	cmp	r2, r3
 80031fc:	d1cf      	bne.n	800319e <set_hm10_pin_code_mode+0x5a>
	if (TxRx_Buffer[bytes_compared] != pin_code_mode)
 80031fe:	79e3      	ldrb	r3, [r4, #7]
 8003200:	1b98      	subs	r0, r3, r6
 8003202:	bf18      	it	ne
 8003204:	2001      	movne	r0, #1
 8003206:	0080      	lsls	r0, r0, #2
}
 8003208:	bd70      	pop	{r4, r5, r6, pc}
 800320a:	bf00      	nop
 800320c:	20000488 	.word	0x20000488
 8003210:	2000049c 	.word	0x2000049c
 8003214:	542b5441 	.word	0x542b5441
 8003218:	20000000 	.word	0x20000000

0800321c <set_hm10_module_work_mode>:
    switch (module_work_mode)
 800321c:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 8003220:	2b02      	cmp	r3, #2
 8003222:	d901      	bls.n	8003228 <set_hm10_module_work_mode+0xc>
            return HM10_EC_ERR;
 8003224:	2004      	movs	r0, #4
}
 8003226:	4770      	bx	lr
{
 8003228:	b570      	push	{r4, r5, r6, lr}
 800322a:	4606      	mov	r6, r0
 800322c:	4c2d      	ldr	r4, [pc, #180]	; (80032e4 <set_hm10_module_work_mode+0xc8>)
 800322e:	4d2e      	ldr	r5, [pc, #184]	; (80032e8 <set_hm10_module_work_mode+0xcc>)
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, 1, HM10_CUSTOM_HAL_TIMEOUT);
 8003230:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8003234:	2201      	movs	r2, #1
 8003236:	4621      	mov	r1, r4
 8003238:	6828      	ldr	r0, [r5, #0]
 800323a:	f002 f845 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 800323e:	2803      	cmp	r0, #3
 8003240:	d1f6      	bne.n	8003230 <set_hm10_module_work_mode+0x14>
    TxRx_Buffer[4] = 'O';
 8003242:	f244 4e4f 	movw	lr, #17487	; 0x444f
    TxRx_Buffer[6] = 'E';
 8003246:	f04f 0c45 	mov.w	ip, #69	; 0x45
    TxRx_Buffer[0] = 'A';
 800324a:	4b28      	ldr	r3, [pc, #160]	; (80032ec <set_hm10_module_work_mode+0xd0>)
    ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_SET_MODE_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 800324c:	2208      	movs	r2, #8
    TxRx_Buffer[0] = 'A';
 800324e:	6023      	str	r3, [r4, #0]
    ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_SET_MODE_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8003250:	4924      	ldr	r1, [pc, #144]	; (80032e4 <set_hm10_module_work_mode+0xc8>)
 8003252:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8003256:	6828      	ldr	r0, [r5, #0]
    TxRx_Buffer[7] = module_work_mode;
 8003258:	71e6      	strb	r6, [r4, #7]
    TxRx_Buffer[4] = 'O';
 800325a:	f8a4 e004 	strh.w	lr, [r4, #4]
    TxRx_Buffer[6] = 'E';
 800325e:	f884 c006 	strb.w	ip, [r4, #6]
    ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_SET_MODE_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8003262:	f001 ff8f 	bl	8005184 <HAL_UART_Transmit>
  switch (HAL_status)
 8003266:	2801      	cmp	r0, #1
 8003268:	d005      	beq.n	8003276 <set_hm10_module_work_mode+0x5a>
 800326a:	1e82      	subs	r2, r0, #2
 800326c:	b2d2      	uxtb	r2, r2
 800326e:	2a01      	cmp	r2, #1
 8003270:	d803      	bhi.n	800327a <set_hm10_module_work_mode+0x5e>
		return HM10_EC_NR;
 8003272:	2002      	movs	r0, #2
}
 8003274:	bd70      	pop	{r4, r5, r6, pc}
		return HM10_EC_ERR;
 8003276:	2004      	movs	r0, #4
}
 8003278:	bd70      	pop	{r4, r5, r6, pc}
    if (ret != HAL_OK)
 800327a:	2800      	cmp	r0, #0
 800327c:	d1fa      	bne.n	8003274 <set_hm10_module_work_mode+0x58>
    ret = HAL_UART_Receive(p_huart, TxRx_Buffer, HM10_MODE_RESPONSE_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 800327e:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8003282:	2208      	movs	r2, #8
 8003284:	6828      	ldr	r0, [r5, #0]
 8003286:	4917      	ldr	r1, [pc, #92]	; (80032e4 <set_hm10_module_work_mode+0xc8>)
 8003288:	f002 f81e 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 800328c:	2801      	cmp	r0, #1
 800328e:	d0f2      	beq.n	8003276 <set_hm10_module_work_mode+0x5a>
 8003290:	1e82      	subs	r2, r0, #2
 8003292:	b2d2      	uxtb	r2, r2
 8003294:	2a01      	cmp	r2, #1
 8003296:	d9ec      	bls.n	8003272 <set_hm10_module_work_mode+0x56>
    if (ret != HAL_OK)
 8003298:	2800      	cmp	r0, #0
 800329a:	d1eb      	bne.n	8003274 <set_hm10_module_work_mode+0x58>
        if (TxRx_Buffer[bytes_compared] != HM10_Set_Mode_resp_without_module_work_mode_value[bytes_compared])
 800329c:	4b14      	ldr	r3, [pc, #80]	; (80032f0 <set_hm10_module_work_mode+0xd4>)
 800329e:	7822      	ldrb	r2, [r4, #0]
 80032a0:	7819      	ldrb	r1, [r3, #0]
 80032a2:	4291      	cmp	r1, r2
 80032a4:	d1e7      	bne.n	8003276 <set_hm10_module_work_mode+0x5a>
 80032a6:	7861      	ldrb	r1, [r4, #1]
 80032a8:	785a      	ldrb	r2, [r3, #1]
 80032aa:	4291      	cmp	r1, r2
 80032ac:	d1e3      	bne.n	8003276 <set_hm10_module_work_mode+0x5a>
 80032ae:	78a1      	ldrb	r1, [r4, #2]
 80032b0:	789a      	ldrb	r2, [r3, #2]
 80032b2:	4291      	cmp	r1, r2
 80032b4:	d1df      	bne.n	8003276 <set_hm10_module_work_mode+0x5a>
 80032b6:	78e1      	ldrb	r1, [r4, #3]
 80032b8:	78da      	ldrb	r2, [r3, #3]
 80032ba:	4291      	cmp	r1, r2
 80032bc:	d1db      	bne.n	8003276 <set_hm10_module_work_mode+0x5a>
 80032be:	7921      	ldrb	r1, [r4, #4]
 80032c0:	791a      	ldrb	r2, [r3, #4]
 80032c2:	4291      	cmp	r1, r2
 80032c4:	d1d7      	bne.n	8003276 <set_hm10_module_work_mode+0x5a>
 80032c6:	7961      	ldrb	r1, [r4, #5]
 80032c8:	795a      	ldrb	r2, [r3, #5]
 80032ca:	4291      	cmp	r1, r2
 80032cc:	d1d3      	bne.n	8003276 <set_hm10_module_work_mode+0x5a>
 80032ce:	79a2      	ldrb	r2, [r4, #6]
 80032d0:	799b      	ldrb	r3, [r3, #6]
 80032d2:	429a      	cmp	r2, r3
 80032d4:	d1cf      	bne.n	8003276 <set_hm10_module_work_mode+0x5a>
    if (TxRx_Buffer[bytes_compared] != module_work_mode)
 80032d6:	79e0      	ldrb	r0, [r4, #7]
 80032d8:	1b80      	subs	r0, r0, r6
 80032da:	bf18      	it	ne
 80032dc:	2001      	movne	r0, #1
 80032de:	0080      	lsls	r0, r0, #2
}
 80032e0:	bd70      	pop	{r4, r5, r6, pc}
 80032e2:	bf00      	nop
 80032e4:	20000488 	.word	0x20000488
 80032e8:	2000049c 	.word	0x2000049c
 80032ec:	4d2b5441 	.word	0x4d2b5441
 80032f0:	20000000 	.word	0x20000000

080032f4 <disconnect_hm10_from_bt_address>:
{
 80032f4:	b570      	push	{r4, r5, r6, lr}
 80032f6:	4d2c      	ldr	r5, [pc, #176]	; (80033a8 <disconnect_hm10_from_bt_address+0xb4>)
 80032f8:	4c2c      	ldr	r4, [pc, #176]	; (80033ac <disconnect_hm10_from_bt_address+0xb8>)
	ret = HAL_UART_Receive(p_huart, TxRx_Buffer, 1, HM10_CUSTOM_HAL_TIMEOUT);
 80032fa:	f44f 73a0 	mov.w	r3, #320	; 0x140
 80032fe:	2201      	movs	r2, #1
 8003300:	4629      	mov	r1, r5
 8003302:	6820      	ldr	r0, [r4, #0]
 8003304:	f001 ffe0 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 8003308:	2803      	cmp	r0, #3
 800330a:	d1f6      	bne.n	80032fa <disconnect_hm10_from_bt_address+0x6>
    TxRx_Buffer[0] = 'A';
 800330c:	f245 4641 	movw	r6, #21569	; 0x5441
    ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_TEST_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8003310:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8003314:	2202      	movs	r2, #2
 8003316:	4924      	ldr	r1, [pc, #144]	; (80033a8 <disconnect_hm10_from_bt_address+0xb4>)
 8003318:	6820      	ldr	r0, [r4, #0]
    TxRx_Buffer[0] = 'A';
 800331a:	802e      	strh	r6, [r5, #0]
    ret = HAL_UART_Transmit(p_huart, TxRx_Buffer, HM10_TEST_CMD_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 800331c:	f001 ff32 	bl	8005184 <HAL_UART_Transmit>
  switch (HAL_status)
 8003320:	1e43      	subs	r3, r0, #1
 8003322:	b2db      	uxtb	r3, r3
 8003324:	2b02      	cmp	r3, #2
 8003326:	d802      	bhi.n	800332e <disconnect_hm10_from_bt_address+0x3a>
        return HM10_BT_Connection_Status_Unknown;
 8003328:	2600      	movs	r6, #0
}
 800332a:	4630      	mov	r0, r6
 800332c:	bd70      	pop	{r4, r5, r6, pc}
    if (ret != HAL_OK)
 800332e:	2800      	cmp	r0, #0
 8003330:	d1fa      	bne.n	8003328 <disconnect_hm10_from_bt_address+0x34>
    ret = HAL_UART_Receive(p_huart, TxRx_Buffer, HM10_OK_RESPONSE_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8003332:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8003336:	2202      	movs	r2, #2
 8003338:	491b      	ldr	r1, [pc, #108]	; (80033a8 <disconnect_hm10_from_bt_address+0xb4>)
 800333a:	6820      	ldr	r0, [r4, #0]
 800333c:	f001 ffc4 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 8003340:	1e43      	subs	r3, r0, #1
 8003342:	b2db      	uxtb	r3, r3
 8003344:	2b02      	cmp	r3, #2
    ret = HAL_UART_Receive(p_huart, TxRx_Buffer, HM10_OK_RESPONSE_SIZE, HM10_CUSTOM_HAL_TIMEOUT);
 8003346:	4606      	mov	r6, r0
  switch (HAL_status)
 8003348:	d9ee      	bls.n	8003328 <disconnect_hm10_from_bt_address+0x34>
    if (ret != HAL_OK)
 800334a:	2800      	cmp	r0, #0
 800334c:	d1ec      	bne.n	8003328 <disconnect_hm10_from_bt_address+0x34>
        if (TxRx_Buffer[bytes_compared] != HM10_OK_LOST_resp[bytes_compared])
 800334e:	782b      	ldrb	r3, [r5, #0]
 8003350:	2b4f      	cmp	r3, #79	; 0x4f
 8003352:	d1e9      	bne.n	8003328 <disconnect_hm10_from_bt_address+0x34>
 8003354:	786b      	ldrb	r3, [r5, #1]
 8003356:	2b4b      	cmp	r3, #75	; 0x4b
 8003358:	d1e6      	bne.n	8003328 <disconnect_hm10_from_bt_address+0x34>
    ret = HAL_UART_Receive(p_huart, &TxRx_Buffer[bytes_compared], HM10_OK_LOST_RESPONSE_SIZE_WITHOUT_THE_OK_PART, HM10_CUSTOM_HAL_TIMEOUT);
 800335a:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800335e:	2205      	movs	r2, #5
 8003360:	6820      	ldr	r0, [r4, #0]
 8003362:	4913      	ldr	r1, [pc, #76]	; (80033b0 <disconnect_hm10_from_bt_address+0xbc>)
 8003364:	f001 ffb0 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 8003368:	2801      	cmp	r0, #1
 800336a:	d0de      	beq.n	800332a <disconnect_hm10_from_bt_address+0x36>
 800336c:	1e83      	subs	r3, r0, #2
 800336e:	b2db      	uxtb	r3, r3
 8003370:	2b01      	cmp	r3, #1
 8003372:	d801      	bhi.n	8003378 <disconnect_hm10_from_bt_address+0x84>
 8003374:	2601      	movs	r6, #1
    if (ret != HAL_OK)
 8003376:	e7d8      	b.n	800332a <disconnect_hm10_from_bt_address+0x36>
    ret = HAL_ret_handler(ret);
 8003378:	b200      	sxth	r0, r0
    if (ret != HAL_OK)
 800337a:	b980      	cbnz	r0, 800339e <disconnect_hm10_from_bt_address+0xaa>
        if (TxRx_Buffer[bytes_compared] != HM10_OK_LOST_resp[bytes_compared])
 800337c:	78ab      	ldrb	r3, [r5, #2]
 800337e:	2b2b      	cmp	r3, #43	; 0x2b
 8003380:	d1d2      	bne.n	8003328 <disconnect_hm10_from_bt_address+0x34>
 8003382:	78eb      	ldrb	r3, [r5, #3]
 8003384:	2b4c      	cmp	r3, #76	; 0x4c
 8003386:	d1cf      	bne.n	8003328 <disconnect_hm10_from_bt_address+0x34>
 8003388:	792b      	ldrb	r3, [r5, #4]
 800338a:	2b4f      	cmp	r3, #79	; 0x4f
 800338c:	d1cc      	bne.n	8003328 <disconnect_hm10_from_bt_address+0x34>
 800338e:	796b      	ldrb	r3, [r5, #5]
 8003390:	2b53      	cmp	r3, #83	; 0x53
 8003392:	d1c9      	bne.n	8003328 <disconnect_hm10_from_bt_address+0x34>
 8003394:	79ab      	ldrb	r3, [r5, #6]
 8003396:	2b54      	cmp	r3, #84	; 0x54
 8003398:	d1c6      	bne.n	8003328 <disconnect_hm10_from_bt_address+0x34>
    return HM10_BT_Connection_Lost;
 800339a:	2602      	movs	r6, #2
 800339c:	e7c5      	b.n	800332a <disconnect_hm10_from_bt_address+0x36>
        return HM10_BT_Connection_Status_Unknown;
 800339e:	1e83      	subs	r3, r0, #2
 80033a0:	425e      	negs	r6, r3
 80033a2:	415e      	adcs	r6, r3
        if (ret == HM10_EC_NR)
 80033a4:	e7c1      	b.n	800332a <disconnect_hm10_from_bt_address+0x36>
 80033a6:	bf00      	nop
 80033a8:	20000488 	.word	0x20000488
 80033ac:	2000049c 	.word	0x2000049c
 80033b0:	2000048a 	.word	0x2000048a

080033b4 <send_hm10_ota_data>:
{
 80033b4:	468c      	mov	ip, r1
 80033b6:	b508      	push	{r3, lr}
 80033b8:	4686      	mov	lr, r0
 80033ba:	4613      	mov	r3, r2
	ret = HAL_UART_Transmit(p_huart, ble_ota_data, size, timeout);
 80033bc:	4a07      	ldr	r2, [pc, #28]	; (80033dc <send_hm10_ota_data+0x28>)
 80033be:	4671      	mov	r1, lr
 80033c0:	6810      	ldr	r0, [r2, #0]
 80033c2:	4662      	mov	r2, ip
 80033c4:	f001 fede 	bl	8005184 <HAL_UART_Transmit>
  switch (HAL_status)
 80033c8:	2801      	cmp	r0, #1
 80033ca:	d005      	beq.n	80033d8 <send_hm10_ota_data+0x24>
 80033cc:	1e83      	subs	r3, r0, #2
 80033ce:	b2db      	uxtb	r3, r3
 80033d0:	2b01      	cmp	r3, #1
 80033d2:	bf98      	it	ls
 80033d4:	2002      	movls	r0, #2
}
 80033d6:	bd08      	pop	{r3, pc}
		return HM10_EC_ERR;
 80033d8:	2004      	movs	r0, #4
}
 80033da:	bd08      	pop	{r3, pc}
 80033dc:	2000049c 	.word	0x2000049c

080033e0 <get_hm10_ota_data>:
{
 80033e0:	468c      	mov	ip, r1
 80033e2:	b508      	push	{r3, lr}
 80033e4:	4686      	mov	lr, r0
 80033e6:	4613      	mov	r3, r2
	ret = HAL_UART_Receive(p_huart, ble_ota_data, size, timeout);
 80033e8:	4a07      	ldr	r2, [pc, #28]	; (8003408 <get_hm10_ota_data+0x28>)
 80033ea:	4671      	mov	r1, lr
 80033ec:	6810      	ldr	r0, [r2, #0]
 80033ee:	4662      	mov	r2, ip
 80033f0:	f001 ff6a 	bl	80052c8 <HAL_UART_Receive>
  switch (HAL_status)
 80033f4:	2801      	cmp	r0, #1
 80033f6:	d005      	beq.n	8003404 <get_hm10_ota_data+0x24>
 80033f8:	1e83      	subs	r3, r0, #2
 80033fa:	b2db      	uxtb	r3, r3
 80033fc:	2b01      	cmp	r3, #1
 80033fe:	bf98      	it	ls
 8003400:	2002      	movls	r0, #2
}
 8003402:	bd08      	pop	{r3, pc}
		return HM10_EC_ERR;
 8003404:	2004      	movs	r0, #4
}
 8003406:	bd08      	pop	{r3, pc}
 8003408:	2000049c 	.word	0x2000049c

0800340c <validate_application_firmware>:
		printf("DONE: Bootloader Firmware of our MCU/MPU has been successfully validated.\r\n");
	#endif
}

static void validate_application_firmware(uint8_t *is_app_fw_validation_ok)
{
 800340c:	b538      	push	{r3, r4, r5, lr}
    #if ETX_OTA_VERBOSE
        printf("Validating the Application Firmware of our MCU/MPU...\r\n");
    #endif
    if ((fw_config.App_fw_rec_crc==DATA_BLOCK_32BIT_ERASED_VALUE) || (fw_config.App_fw_size==DATA_BLOCK_32BIT_ERASED_VALUE) || (fw_config.App_fw_size==0x00000000))
 800340e:	4d0b      	ldr	r5, [pc, #44]	; (800343c <validate_application_firmware+0x30>)
{
 8003410:	4604      	mov	r4, r0
    if ((fw_config.App_fw_rec_crc==DATA_BLOCK_32BIT_ERASED_VALUE) || (fw_config.App_fw_size==DATA_BLOCK_32BIT_ERASED_VALUE) || (fw_config.App_fw_size==0x00000000))
 8003412:	68eb      	ldr	r3, [r5, #12]
 8003414:	3301      	adds	r3, #1
 8003416:	d003      	beq.n	8003420 <validate_application_firmware+0x14>
 8003418:	68a9      	ldr	r1, [r5, #8]
 800341a:	1e4b      	subs	r3, r1, #1
 800341c:	3303      	adds	r3, #3
 800341e:	d902      	bls.n	8003426 <validate_application_firmware+0x1a>
    {
        #if ETX_OTA_VERBOSE
            printf("WARNING: No Application Firmware has been identified to be installed in our MCU/MPU.\r\n");
        #endif
        *is_app_fw_validation_ok = 0;
 8003420:	2300      	movs	r3, #0
 8003422:	7023      	strb	r3, [r4, #0]
        }
    }
    #if ETX_OTA_VERBOSE
		printf("DONE: Application Firmware of our MCU/MPU has been successfully validated.\r\n");
	#endif
}
 8003424:	bd38      	pop	{r3, r4, r5, pc}
    else if (fw_config.is_bl_fw_stored_in_app_fw == BT_FW_STORED_IN_APP_FW)
 8003426:	7dab      	ldrb	r3, [r5, #22]
 8003428:	2b01      	cmp	r3, #1
 800342a:	d0f9      	beq.n	8003420 <validate_application_firmware+0x14>
        uint32_t cal_crc = crc32_mpeg2((uint8_t *) APLICATION_FIRMWARE_ADDRESS, fw_config.App_fw_size);
 800342c:	4804      	ldr	r0, [pc, #16]	; (8003440 <validate_application_firmware+0x34>)
 800342e:	f7ff fa07 	bl	8002840 <crc32_mpeg2>
        if (cal_crc != fw_config.App_fw_rec_crc)
 8003432:	68eb      	ldr	r3, [r5, #12]
 8003434:	4283      	cmp	r3, r0
 8003436:	d1f3      	bne.n	8003420 <validate_application_firmware+0x14>
 8003438:	e7f4      	b.n	8003424 <validate_application_firmware+0x18>
 800343a:	bf00      	nop
 800343c:	20000500 	.word	0x20000500
 8003440:	08008000 	.word	0x08008000

08003444 <HAL_uart_rx_flush.constprop.0>:
	HAL_StatusTypeDef  ret;
	/** <b>Local variable buff:</b> @ref uint8_t Type variable used to temporarily hold an available byte of data from the UART from which it is desired to flush its Rx. */
	uint8_t buff;

	/* Receive the HM-10 Device's BT data that is received Over the Air (OTA), if there is any. */
	ret = HAL_UART_Receive(p_huart, &buff, 1, 1);
 8003444:	2301      	movs	r3, #1
static void HAL_uart_rx_flush(UART_HandleTypeDef *p_huart)
 8003446:	b500      	push	{lr}
 8003448:	b083      	sub	sp, #12
	ret = HAL_UART_Receive(p_huart, &buff, 1, 1);
 800344a:	461a      	mov	r2, r3
 800344c:	4813      	ldr	r0, [pc, #76]	; (800349c <HAL_uart_rx_flush.constprop.0+0x58>)
 800344e:	a901      	add	r1, sp, #4
 8003450:	f001 ff3a 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 8003454:	2803      	cmp	r0, #3
 8003456:	d102      	bne.n	800345e <HAL_uart_rx_flush.constprop.0+0x1a>
	{
		HAL_uart_rx_flush(p_huart);
	}
}
 8003458:	b003      	add	sp, #12
 800345a:	f85d fb04 	ldr.w	pc, [sp], #4
	ret = HAL_UART_Receive(p_huart, &buff, 1, 1);
 800345e:	2301      	movs	r3, #1
 8003460:	480e      	ldr	r0, [pc, #56]	; (800349c <HAL_uart_rx_flush.constprop.0+0x58>)
 8003462:	461a      	mov	r2, r3
 8003464:	f10d 0105 	add.w	r1, sp, #5
 8003468:	f001 ff2e 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 800346c:	2803      	cmp	r0, #3
 800346e:	d0f3      	beq.n	8003458 <HAL_uart_rx_flush.constprop.0+0x14>
	ret = HAL_UART_Receive(p_huart, &buff, 1, 1);
 8003470:	2301      	movs	r3, #1
 8003472:	480a      	ldr	r0, [pc, #40]	; (800349c <HAL_uart_rx_flush.constprop.0+0x58>)
 8003474:	461a      	mov	r2, r3
 8003476:	f10d 0106 	add.w	r1, sp, #6
 800347a:	f001 ff25 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 800347e:	2803      	cmp	r0, #3
 8003480:	d0ea      	beq.n	8003458 <HAL_uart_rx_flush.constprop.0+0x14>
	ret = HAL_UART_Receive(p_huart, &buff, 1, 1);
 8003482:	2301      	movs	r3, #1
 8003484:	4805      	ldr	r0, [pc, #20]	; (800349c <HAL_uart_rx_flush.constprop.0+0x58>)
 8003486:	461a      	mov	r2, r3
 8003488:	f10d 0107 	add.w	r1, sp, #7
 800348c:	f001 ff1c 	bl	80052c8 <HAL_UART_Receive>
	if (ret != HAL_TIMEOUT)
 8003490:	2803      	cmp	r0, #3
 8003492:	d0e1      	beq.n	8003458 <HAL_uart_rx_flush.constprop.0+0x14>
		HAL_uart_rx_flush(p_huart);
 8003494:	f7ff ffd6 	bl	8003444 <HAL_uart_rx_flush.constprop.0>
}
 8003498:	e7de      	b.n	8003458 <HAL_uart_rx_flush.constprop.0+0x14>
 800349a:	bf00      	nop
 800349c:	200005a8 	.word	0x200005a8

080034a0 <SystemClock_Config>:
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80034a0:	2220      	movs	r2, #32
{
 80034a2:	b530      	push	{r4, r5, lr}
 80034a4:	b091      	sub	sp, #68	; 0x44
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80034a6:	2100      	movs	r1, #0
 80034a8:	eb0d 0002 	add.w	r0, sp, r2
 80034ac:	f001 ff94 	bl	80053d8 <memset>
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80034b0:	2401      	movs	r4, #1
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80034b2:	2300      	movs	r3, #0
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80034b4:	f44f 3580 	mov.w	r5, #65536	; 0x10000
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80034b8:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80034ba:	e9cd 4506 	strd	r4, r5, [sp, #24]
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80034be:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80034c2:	e9cd 3304 	strd	r3, r3, [sp, #16]
 80034c6:	9301      	str	r3, [sp, #4]
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80034c8:	f000 ff60 	bl	800438c <HAL_RCC_OscConfig>
 80034cc:	b108      	cbz	r0, 80034d2 <SystemClock_Config+0x32>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80034ce:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80034d0:	e7fe      	b.n	80034d0 <SystemClock_Config+0x30>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80034d2:	4601      	mov	r1, r0
 80034d4:	240f      	movs	r4, #15
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSE;
 80034d6:	2201      	movs	r2, #1
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV4;
 80034d8:	2390      	movs	r3, #144	; 0x90
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 80034da:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80034dc:	e9cd 1104 	strd	r1, r1, [sp, #16]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSE;
 80034e0:	e9cd 4201 	strd	r4, r2, [sp, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV4;
 80034e4:	9303      	str	r3, [sp, #12]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 80034e6:	f001 f941 	bl	800476c <HAL_RCC_ClockConfig>
 80034ea:	b108      	cbz	r0, 80034f0 <SystemClock_Config+0x50>
 80034ec:	b672      	cpsid	i
  while (1)
 80034ee:	e7fe      	b.n	80034ee <SystemClock_Config+0x4e>
}
 80034f0:	b011      	add	sp, #68	; 0x44
 80034f2:	bd30      	pop	{r4, r5, pc}

080034f4 <main>:
{
 80034f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80034f8:	2400      	movs	r4, #0
{
 80034fa:	b092      	sub	sp, #72	; 0x48
  HAL_Init();
 80034fc:	f000 fb98 	bl	8003c30 <HAL_Init>
  SystemClock_Config();
 8003500:	f7ff ffce 	bl	80034a0 <SystemClock_Config>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003504:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
 8003508:	e9cd 440d 	strd	r4, r4, [sp, #52]	; 0x34
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800350c:	4ba7      	ldr	r3, [pc, #668]	; (80037ac <main+0x2b8>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800350e:	2601      	movs	r6, #1
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8003510:	699a      	ldr	r2, [r3, #24]
  HAL_GPIO_WritePin(IATR_LED_GPIO_Output_GPIO_Port, IATR_LED_GPIO_Output_Pin, GPIO_PIN_RESET);
 8003512:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8003516:	f042 0210 	orr.w	r2, r2, #16
 800351a:	619a      	str	r2, [r3, #24]
 800351c:	699a      	ldr	r2, [r3, #24]
  HAL_GPIO_WritePin(IATR_LED_GPIO_Output_GPIO_Port, IATR_LED_GPIO_Output_Pin, GPIO_PIN_RESET);
 800351e:	48a4      	ldr	r0, [pc, #656]	; (80037b0 <main+0x2bc>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8003520:	f002 0210 	and.w	r2, r2, #16
 8003524:	9201      	str	r2, [sp, #4]
 8003526:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8003528:	699a      	ldr	r2, [r3, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800352a:	2502      	movs	r5, #2
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800352c:	f042 0220 	orr.w	r2, r2, #32
 8003530:	619a      	str	r2, [r3, #24]
 8003532:	699a      	ldr	r2, [r3, #24]
 8003534:	f002 0220 	and.w	r2, r2, #32
 8003538:	9202      	str	r2, [sp, #8]
 800353a:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800353c:	699a      	ldr	r2, [r3, #24]
 800353e:	f042 0204 	orr.w	r2, r2, #4
 8003542:	619a      	str	r2, [r3, #24]
 8003544:	699a      	ldr	r2, [r3, #24]
 8003546:	f002 0204 	and.w	r2, r2, #4
 800354a:	9203      	str	r2, [sp, #12]
 800354c:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800354e:	699a      	ldr	r2, [r3, #24]
 8003550:	f042 0208 	orr.w	r2, r2, #8
 8003554:	619a      	str	r2, [r3, #24]
 8003556:	699b      	ldr	r3, [r3, #24]
  HAL_GPIO_WritePin(IATR_LED_GPIO_Output_GPIO_Port, IATR_LED_GPIO_Output_Pin, GPIO_PIN_RESET);
 8003558:	4622      	mov	r2, r4
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800355a:	f003 0308 	and.w	r3, r3, #8
 800355e:	9304      	str	r3, [sp, #16]
 8003560:	9b04      	ldr	r3, [sp, #16]
  HAL_GPIO_WritePin(IATR_LED_GPIO_Output_GPIO_Port, IATR_LED_GPIO_Output_Pin, GPIO_PIN_RESET);
 8003562:	f000 ff0f 	bl	8004384 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOA, Display_C_terminal_GPIO_Output_Pin|Display_D_terminal_GPIO_Output_Pin|Water_Heating_Resistor_GPIO_Output_Pin|Cold_Water_Pump_GPIO_Output_Pin, GPIO_PIN_RESET);
 8003566:	4622      	mov	r2, r4
 8003568:	f44f 7196 	mov.w	r1, #300	; 0x12c
 800356c:	4891      	ldr	r0, [pc, #580]	; (80037b4 <main+0x2c0>)
 800356e:	f000 ff09 	bl	8004384 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, Display_A_terminal_GPIO_Output_Pin|Display_B_terminal_GPIO_Output_Pin|Hot_Water_Pump_GPIO_Output_Pin|Display_E_terminal_GPIO_Output_Pin
 8003572:	4622      	mov	r2, r4
 8003574:	f248 11e3 	movw	r1, #33251	; 0x81e3
 8003578:	488f      	ldr	r0, [pc, #572]	; (80037b8 <main+0x2c4>)
 800357a:	f000 ff03 	bl	8004384 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, Display_K2_terminal_GPIO_Output_Pin|Display_K3_terminal_GPIO_Output_Pin|Display_K4_terminal_GPIO_Output_Pin|Display_K1_terminal_GPIO_Output_Pin, GPIO_PIN_SET);
 800357e:	4632      	mov	r2, r6
 8003580:	f44f 41e4 	mov.w	r1, #29184	; 0x7200
 8003584:	488c      	ldr	r0, [pc, #560]	; (80037b8 <main+0x2c4>)
 8003586:	f000 fefd 	bl	8004384 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = IATR_LED_GPIO_Output_Pin;
 800358a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(IATR_LED_GPIO_Output_GPIO_Port, &GPIO_InitStruct);
 800358e:	4888      	ldr	r0, [pc, #544]	; (80037b0 <main+0x2bc>)
 8003590:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Pin = IATR_LED_GPIO_Output_Pin;
 8003592:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003594:	e9cd 640c 	strd	r6, r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8003598:	950e      	str	r5, [sp, #56]	; 0x38
  HAL_GPIO_Init(IATR_LED_GPIO_Output_GPIO_Port, &GPIO_InitStruct);
 800359a:	f000 fddf 	bl	800415c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = HM10_is_default_settings_GPIO_Input_Pin;
 800359e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  HAL_GPIO_Init(HM10_is_default_settings_GPIO_Input_GPIO_Port, &GPIO_InitStruct);
 80035a2:	4883      	ldr	r0, [pc, #524]	; (80037b0 <main+0x2bc>)
 80035a4:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Pin = HM10_is_default_settings_GPIO_Input_Pin;
 80035a6:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80035a8:	e9cd 450c 	strd	r4, r5, [sp, #48]	; 0x30
  HAL_GPIO_Init(HM10_is_default_settings_GPIO_Input_GPIO_Port, &GPIO_InitStruct);
 80035ac:	f000 fdd6 	bl	800415c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = Display_C_terminal_GPIO_Output_Pin|Display_D_terminal_GPIO_Output_Pin|Water_Heating_Resistor_GPIO_Output_Pin|Cold_Water_Pump_GPIO_Output_Pin;
 80035b0:	f44f 7396 	mov.w	r3, #300	; 0x12c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80035b4:	487f      	ldr	r0, [pc, #508]	; (80037b4 <main+0x2c0>)
 80035b6:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Pin = Display_C_terminal_GPIO_Output_Pin|Display_D_terminal_GPIO_Output_Pin|Water_Heating_Resistor_GPIO_Output_Pin|Cold_Water_Pump_GPIO_Output_Pin;
 80035b8:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80035ba:	e9cd 640c 	strd	r6, r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80035be:	950e      	str	r5, [sp, #56]	; 0x38
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80035c0:	f000 fdcc 	bl	800415c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = Display_A_terminal_GPIO_Output_Pin|Display_B_terminal_GPIO_Output_Pin|Display_K2_terminal_GPIO_Output_Pin|Display_K3_terminal_GPIO_Output_Pin
 80035c4:	f24f 33e3 	movw	r3, #62435	; 0xf3e3
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80035c8:	487b      	ldr	r0, [pc, #492]	; (80037b8 <main+0x2c4>)
 80035ca:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Pin = Display_A_terminal_GPIO_Output_Pin|Display_B_terminal_GPIO_Output_Pin|Display_K2_terminal_GPIO_Output_Pin|Display_K3_terminal_GPIO_Output_Pin
 80035cc:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80035ce:	e9cd 450d 	strd	r4, r5, [sp, #52]	; 0x34
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80035d2:	960c      	str	r6, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80035d4:	f000 fdc2 	bl	800415c <HAL_GPIO_Init>
  huart3.Init.Mode = UART_MODE_TX_RX;
 80035d8:	230c      	movs	r3, #12
  huart3.Init.BaudRate = 9600;
 80035da:	f44f 5216 	mov.w	r2, #9600	; 0x2580
  huart3.Instance = USART3;
 80035de:	4877      	ldr	r0, [pc, #476]	; (80037bc <main+0x2c8>)
  huart3.Init.Mode = UART_MODE_TX_RX;
 80035e0:	6143      	str	r3, [r0, #20]
  huart3.Instance = USART3;
 80035e2:	4b77      	ldr	r3, [pc, #476]	; (80037c0 <main+0x2cc>)
  huart3.Init.StopBits = UART_STOPBITS_1;
 80035e4:	e9c0 4402 	strd	r4, r4, [r0, #8]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 80035e8:	e9c0 4406 	strd	r4, r4, [r0, #24]
  huart3.Init.Parity = UART_PARITY_NONE;
 80035ec:	6104      	str	r4, [r0, #16]
  huart3.Init.BaudRate = 9600;
 80035ee:	6042      	str	r2, [r0, #4]
  huart3.Instance = USART3;
 80035f0:	6003      	str	r3, [r0, #0]
  if (HAL_UART_Init(&huart3) != HAL_OK)
 80035f2:	f001 fd59 	bl	80050a8 <HAL_UART_Init>
 80035f6:	b108      	cbz	r0, 80035fc <main+0x108>
 80035f8:	b672      	cpsid	i
  while (1)
 80035fa:	e7fe      	b.n	80035fa <main+0x106>
  htim2.Instance = TIM2;
 80035fc:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  htim2.Init.Period = 416-1;
 8003600:	f240 139f 	movw	r3, #415	; 0x19f
  htim2.Instance = TIM2;
 8003604:	4c6f      	ldr	r4, [pc, #444]	; (80037c4 <main+0x2d0>)
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8003606:	e9cd 000b 	strd	r0, r0, [sp, #44]	; 0x2c
 800360a:	e9cd 000d 	strd	r0, r0, [sp, #52]	; 0x34
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 800360e:	e9c4 0001 	strd	r0, r0, [r4, #4]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8003612:	9007      	str	r0, [sp, #28]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8003614:	6120      	str	r0, [r4, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8003616:	61a0      	str	r0, [r4, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8003618:	9008      	str	r0, [sp, #32]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 800361a:	4620      	mov	r0, r4
  htim2.Instance = TIM2;
 800361c:	6022      	str	r2, [r4, #0]
  htim2.Init.Period = 416-1;
 800361e:	60e3      	str	r3, [r4, #12]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 8003620:	f001 f986 	bl	8004930 <HAL_TIM_Base_Init>
 8003624:	b108      	cbz	r0, 800362a <main+0x136>
 8003626:	b672      	cpsid	i
  while (1)
 8003628:	e7fe      	b.n	8003628 <main+0x134>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800362a:	f44f 5580 	mov.w	r5, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 800362e:	4620      	mov	r0, r4
 8003630:	a90b      	add	r1, sp, #44	; 0x2c
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8003632:	950b      	str	r5, [sp, #44]	; 0x2c
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8003634:	f001 fba0 	bl	8004d78 <HAL_TIM_ConfigClockSource>
 8003638:	4603      	mov	r3, r0
 800363a:	b108      	cbz	r0, 8003640 <main+0x14c>
 800363c:	b672      	cpsid	i
  while (1)
 800363e:	e7fe      	b.n	800363e <main+0x14a>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8003640:	4620      	mov	r0, r4
 8003642:	a907      	add	r1, sp, #28
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8003644:	e9cd 3307 	strd	r3, r3, [sp, #28]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8003648:	f001 fcf8 	bl	800503c <HAL_TIMEx_MasterConfigSynchronization>
 800364c:	b9e0      	cbnz	r0, 8003688 <main+0x194>
  htim3.Init.Period = 1818-1;
 800364e:	f240 7219 	movw	r2, #1817	; 0x719
  htim3.Instance = TIM3;
 8003652:	4c5d      	ldr	r4, [pc, #372]	; (80037c8 <main+0x2d4>)
 8003654:	4b5d      	ldr	r3, [pc, #372]	; (80037cc <main+0x2d8>)
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8003656:	e9cd 0007 	strd	r0, r0, [sp, #28]
 800365a:	e9cd 0009 	strd	r0, r0, [sp, #36]	; 0x24
  TIM_OC_InitTypeDef sConfigOC = {0};
 800365e:	e9cd 000b 	strd	r0, r0, [sp, #44]	; 0x2c
 8003662:	e9cd 000d 	strd	r0, r0, [sp, #52]	; 0x34
 8003666:	e9cd 000f 	strd	r0, r0, [sp, #60]	; 0x3c
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 800366a:	e9c4 0001 	strd	r0, r0, [r4, #4]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800366e:	9005      	str	r0, [sp, #20]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8003670:	9011      	str	r0, [sp, #68]	; 0x44
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8003672:	9006      	str	r0, [sp, #24]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8003674:	6120      	str	r0, [r4, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8003676:	61a0      	str	r0, [r4, #24]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8003678:	4620      	mov	r0, r4
  htim3.Init.Period = 1818-1;
 800367a:	60e2      	str	r2, [r4, #12]
  htim3.Instance = TIM3;
 800367c:	6023      	str	r3, [r4, #0]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 800367e:	f001 f957 	bl	8004930 <HAL_TIM_Base_Init>
 8003682:	b118      	cbz	r0, 800368c <main+0x198>
 8003684:	b672      	cpsid	i
  while (1)
 8003686:	e7fe      	b.n	8003686 <main+0x192>
 8003688:	b672      	cpsid	i
 800368a:	e7fe      	b.n	800368a <main+0x196>
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 800368c:	4620      	mov	r0, r4
 800368e:	a907      	add	r1, sp, #28
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8003690:	9507      	str	r5, [sp, #28]
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8003692:	f001 fb71 	bl	8004d78 <HAL_TIM_ConfigClockSource>
 8003696:	b108      	cbz	r0, 800369c <main+0x1a8>
 8003698:	b672      	cpsid	i
  while (1)
 800369a:	e7fe      	b.n	800369a <main+0x1a6>
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 800369c:	4620      	mov	r0, r4
 800369e:	f001 f9fd 	bl	8004a9c <HAL_TIM_PWM_Init>
 80036a2:	4603      	mov	r3, r0
 80036a4:	b108      	cbz	r0, 80036aa <main+0x1b6>
 80036a6:	b672      	cpsid	i
  while (1)
 80036a8:	e7fe      	b.n	80036a8 <main+0x1b4>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 80036aa:	4620      	mov	r0, r4
 80036ac:	a905      	add	r1, sp, #20
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80036ae:	e9cd 3305 	strd	r3, r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 80036b2:	f001 fcc3 	bl	800503c <HAL_TIMEx_MasterConfigSynchronization>
 80036b6:	4602      	mov	r2, r0
 80036b8:	b108      	cbz	r0, 80036be <main+0x1ca>
 80036ba:	b672      	cpsid	i
  while (1)
 80036bc:	e7fe      	b.n	80036bc <main+0x1c8>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80036be:	2360      	movs	r3, #96	; 0x60
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80036c0:	e9cd 000c 	strd	r0, r0, [sp, #48]	; 0x30
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80036c4:	900f      	str	r0, [sp, #60]	; 0x3c
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80036c6:	a90b      	add	r1, sp, #44	; 0x2c
 80036c8:	4620      	mov	r0, r4
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80036ca:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80036cc:	f001 fa54 	bl	8004b78 <HAL_TIM_PWM_ConfigChannel>
 80036d0:	b108      	cbz	r0, 80036d6 <main+0x1e2>
 80036d2:	b672      	cpsid	i
  while (1)
 80036d4:	e7fe      	b.n	80036d4 <main+0x1e0>
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 80036d6:	2204      	movs	r2, #4
 80036d8:	4620      	mov	r0, r4
 80036da:	a90b      	add	r1, sp, #44	; 0x2c
 80036dc:	f001 fa4c 	bl	8004b78 <HAL_TIM_PWM_ConfigChannel>
 80036e0:	b108      	cbz	r0, 80036e6 <main+0x1f2>
 80036e2:	b672      	cpsid	i
  while (1)
 80036e4:	e7fe      	b.n	80036e4 <main+0x1f0>
  HAL_TIM_MspPostInit(&htim3);
 80036e6:	4838      	ldr	r0, [pc, #224]	; (80037c8 <main+0x2d4>)
 80036e8:	f000 f9d2 	bl	8003a90 <HAL_TIM_MspPostInit>
  uint8_t is_app_fw_validation_ok = 1;
 80036ec:	2001      	movs	r0, #1
    display_peripherals.A.GPIO_Port = GPIOB;
 80036ee:	4938      	ldr	r1, [pc, #224]	; (80037d0 <main+0x2dc>)
    display_peripherals.A.GPIO_Pin = GPIO_PIN_0;
 80036f0:	4b31      	ldr	r3, [pc, #196]	; (80037b8 <main+0x2c4>)
 80036f2:	4a38      	ldr	r2, [pc, #224]	; (80037d4 <main+0x2e0>)
    display_peripherals.E.GPIO_Port = GPIOB;
 80036f4:	618b      	str	r3, [r1, #24]
    display_peripherals.A.GPIO_Pin = GPIO_PIN_0;
 80036f6:	e9c1 3200 	strd	r3, r2, [r1]
    display_peripherals.B.GPIO_Port = GPIOB;
 80036fa:	4a37      	ldr	r2, [pc, #220]	; (80037d8 <main+0x2e4>)
    display_peripherals.G.GPIO_Port = GPIOB;
 80036fc:	624b      	str	r3, [r1, #36]	; 0x24
    display_peripherals.B.GPIO_Port = GPIOB;
 80036fe:	608a      	str	r2, [r1, #8]
    display_peripherals.C.GPIO_Port = GPIOA;
 8003700:	4a2c      	ldr	r2, [pc, #176]	; (80037b4 <main+0x2c0>)
    display_peripherals.K1.GPIO_Port = GPIOB;
 8003702:	630b      	str	r3, [r1, #48]	; 0x30
    display_peripherals.C.GPIO_Port = GPIOA;
 8003704:	60ca      	str	r2, [r1, #12]
    display_peripherals.C.GPIO_Pin = GPIO_PIN_2;
 8003706:	4a35      	ldr	r2, [pc, #212]	; (80037dc <main+0x2e8>)
    display_peripherals.K3.GPIO_Port = GPIOB;
 8003708:	63cb      	str	r3, [r1, #60]	; 0x3c
    display_peripherals.C.GPIO_Pin = GPIO_PIN_2;
 800370a:	610a      	str	r2, [r1, #16]
    display_peripherals.D.GPIO_Port = GPIOA;
 800370c:	4a34      	ldr	r2, [pc, #208]	; (80037e0 <main+0x2ec>)
    display_peripherals.K3.GPIO_Pin = GPIO_PIN_13;
 800370e:	4b35      	ldr	r3, [pc, #212]	; (80037e4 <main+0x2f0>)
    display_peripherals.D.GPIO_Port = GPIOA;
 8003710:	614a      	str	r2, [r1, #20]
    display_peripherals.E.GPIO_Pin = GPIO_PIN_5;
 8003712:	4a35      	ldr	r2, [pc, #212]	; (80037e8 <main+0x2f4>)
    display_peripherals.K3.GPIO_Pin = GPIO_PIN_13;
 8003714:	640b      	str	r3, [r1, #64]	; 0x40
    display_peripherals.E.GPIO_Pin = GPIO_PIN_5;
 8003716:	61ca      	str	r2, [r1, #28]
    display_peripherals.F.GPIO_Port = GPIOB;
 8003718:	4a34      	ldr	r2, [pc, #208]	; (80037ec <main+0x2f8>)
    display_peripherals.K4.GPIO_Port = GPIOB;
 800371a:	4b35      	ldr	r3, [pc, #212]	; (80037f0 <main+0x2fc>)
    display_peripherals.F.GPIO_Port = GPIOB;
 800371c:	620a      	str	r2, [r1, #32]
    display_peripherals.G.GPIO_Pin = GPIO_PIN_7;
 800371e:	4a35      	ldr	r2, [pc, #212]	; (80037f4 <main+0x300>)
  uint8_t is_app_fw_validation_ok = 1;
 8003720:	f88d 002c 	strb.w	r0, [sp, #44]	; 0x2c
    display_peripherals.G.GPIO_Pin = GPIO_PIN_7;
 8003724:	628a      	str	r2, [r1, #40]	; 0x28
    display_peripherals.Dp.GPIO_Port = GPIOB;
 8003726:	4a34      	ldr	r2, [pc, #208]	; (80037f8 <main+0x304>)
    display_peripherals.K1.GPIO_Pin = GPIO_PIN_9;
 8003728:	4834      	ldr	r0, [pc, #208]	; (80037fc <main+0x308>)
    display_peripherals.Dp.GPIO_Port = GPIOB;
 800372a:	62ca      	str	r2, [r1, #44]	; 0x2c
    display_peripherals.K2.GPIO_Port = GPIOB;
 800372c:	f102 6270 	add.w	r2, r2, #251658240	; 0xf000000
 8003730:	e9c1 020d 	strd	r0, r2, [r1, #52]	; 0x34
    display_peripherals.K4.GPIO_Port = GPIOB;
 8003734:	644b      	str	r3, [r1, #68]	; 0x44
    init_5641as_display_module(&htim2, &display_peripherals, on_time_steps, off_time_steps);
 8003736:	2206      	movs	r2, #6
 8003738:	2304      	movs	r3, #4
 800373a:	4822      	ldr	r0, [pc, #136]	; (80037c4 <main+0x2d0>)
 800373c:	f7fe f9d4 	bl	8001ae8 <init_5641as_display_module>
  display_output[0] = 'B';
 8003740:	4c2f      	ldr	r4, [pc, #188]	; (8003800 <main+0x30c>)
 8003742:	4a30      	ldr	r2, [pc, #192]	; (8003804 <main+0x310>)
 8003744:	4b30      	ldr	r3, [pc, #192]	; (8003808 <main+0x314>)
  set_5641as_display_output(display_output);
 8003746:	4620      	mov	r0, r4
  display_output[0] = 'B';
 8003748:	e9c4 2300 	strd	r2, r3, [r4]
  set_5641as_display_output(display_output);
 800374c:	2503      	movs	r5, #3
 800374e:	f7fe f9eb 	bl	8001b28 <set_5641as_display_output>
        end_tick = HAL_GetTick() + 500;
 8003752:	f000 fa8b 	bl	8003c6c <HAL_GetTick>
        current_tick = 0;
 8003756:	2300      	movs	r3, #0
        end_tick = HAL_GetTick() + 500;
 8003758:	f500 76fa 	add.w	r6, r0, #500	; 0x1f4
        while (current_tick < end_tick)
 800375c:	e002      	b.n	8003764 <main+0x270>
            current_tick = HAL_GetTick();
 800375e:	f000 fa85 	bl	8003c6c <HAL_GetTick>
 8003762:	4603      	mov	r3, r0
        while (current_tick < end_tick)
 8003764:	429e      	cmp	r6, r3
 8003766:	d8fa      	bhi.n	800375e <main+0x26a>
        ret = firmware_update_configurations_init();
 8003768:	f7ff f8b6 	bl	80028d8 <firmware_update_configurations_init>
        if (ret == FIRM_UPDT_CONF_EC_OK)
 800376c:	2800      	cmp	r0, #0
 800376e:	d055      	beq.n	800381c <main+0x328>
    while(attempts < 3);
 8003770:	3d01      	subs	r5, #1
 8003772:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 8003776:	d1ec      	bne.n	8003752 <main+0x25e>
                dst[0] = Command_NULL_in_ASCII;
 8003778:	2330      	movs	r3, #48	; 0x30
    display_output[0] = 'E';
 800377a:	4a24      	ldr	r2, [pc, #144]	; (800380c <main+0x318>)
                dst[0] = Command_NULL_in_ASCII;
 800377c:	4d24      	ldr	r5, [pc, #144]	; (8003810 <main+0x31c>)
 800377e:	4925      	ldr	r1, [pc, #148]	; (8003814 <main+0x320>)
    display_output[0] = 'E';
 8003780:	6022      	str	r2, [r4, #0]
 8003782:	4a25      	ldr	r2, [pc, #148]	; (8003818 <main+0x324>)
        set_5641as_display_output(display_output);
 8003784:	4e1e      	ldr	r6, [pc, #120]	; (8003800 <main+0x30c>)
                dst[0] = Command_NULL_in_ASCII;
 8003786:	6029      	str	r1, [r5, #0]
    display_output[0] = 'E';
 8003788:	6062      	str	r2, [r4, #4]
                dst[0] = Command_NULL_in_ASCII;
 800378a:	606b      	str	r3, [r5, #4]
        set_5641as_display_output(display_output);
 800378c:	4630      	mov	r0, r6
 800378e:	f7fe f9cb 	bl	8001b28 <set_5641as_display_output>
        HAL_Delay(2000);
 8003792:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8003796:	f000 fa6f 	bl	8003c78 <HAL_Delay>
        set_5641as_display_output(ascii_error_code);
 800379a:	4628      	mov	r0, r5
 800379c:	f7fe f9c4 	bl	8001b28 <set_5641as_display_output>
        HAL_Delay(2000);
 80037a0:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80037a4:	f000 fa68 	bl	8003c78 <HAL_Delay>
    while (1)
 80037a8:	e7f0      	b.n	800378c <main+0x298>
 80037aa:	bf00      	nop
 80037ac:	40021000 	.word	0x40021000
 80037b0:	40011000 	.word	0x40011000
 80037b4:	40010800 	.word	0x40010800
 80037b8:	40010c00 	.word	0x40010c00
 80037bc:	200005a8 	.word	0x200005a8
 80037c0:	40004800 	.word	0x40004800
 80037c4:	20000518 	.word	0x20000518
 80037c8:	20000560 	.word	0x20000560
 80037cc:	40000400 	.word	0x40000400
 80037d0:	200004b8 	.word	0x200004b8
 80037d4:	0c000001 	.word	0x0c000001
 80037d8:	00024001 	.word	0x00024001
 80037dc:	08000004 	.word	0x08000004
 80037e0:	00084001 	.word	0x00084001
 80037e4:	0c002000 	.word	0x0c002000
 80037e8:	0c000020 	.word	0x0c000020
 80037ec:	00404001 	.word	0x00404001
 80037f0:	40004001 	.word	0x40004001
 80037f4:	0c000080 	.word	0x0c000080
 80037f8:	01004001 	.word	0x01004001
 80037fc:	0c000200 	.word	0x0c000200
 8003800:	200004b0 	.word	0x200004b0
 8003804:	006f0042 	.word	0x006f0042
 8003808:	0074006f 	.word	0x0074006f
 800380c:	00720045 	.word	0x00720045
 8003810:	200004a8 	.word	0x200004a8
 8003814:	01050000 	.word	0x01050000
 8003818:	003d0072 	.word	0x003d0072
    GPIO_is_hm10_default_settings.GPIO_Pin = GPIO_is_hm10_default_settings_Pin;
 800381c:	f44f 4680 	mov.w	r6, #16384	; 0x4000
            firmware_update_configurations_read(&fw_config);
 8003820:	4d69      	ldr	r5, [pc, #420]	; (80039c8 <main+0x4d4>)
 8003822:	4628      	mov	r0, r5
 8003824:	f7ff f8c2 	bl	80029ac <firmware_update_configurations_read>
    GPIO_is_hm10_default_settings.GPIO_Port = GPIO_is_hm10_default_settings_Port;
 8003828:	4b68      	ldr	r3, [pc, #416]	; (80039cc <main+0x4d8>)
 800382a:	4a69      	ldr	r2, [pc, #420]	; (80039d0 <main+0x4dc>)
    ret = init_firmware_update_module(hw_protocol, p_huart, &fw_config, &GPIO_is_hm10_default_settings);
 800382c:	2001      	movs	r0, #1
    GPIO_is_hm10_default_settings.GPIO_Port = GPIO_is_hm10_default_settings_Port;
 800382e:	601a      	str	r2, [r3, #0]
    ret = init_firmware_update_module(hw_protocol, p_huart, &fw_config, &GPIO_is_hm10_default_settings);
 8003830:	4968      	ldr	r1, [pc, #416]	; (80039d4 <main+0x4e0>)
 8003832:	462a      	mov	r2, r5
    GPIO_is_hm10_default_settings.GPIO_Pin = GPIO_is_hm10_default_settings_Pin;
 8003834:	809e      	strh	r6, [r3, #4]
    ret = init_firmware_update_module(hw_protocol, p_huart, &fw_config, &GPIO_is_hm10_default_settings);
 8003836:	f7fe fd0d 	bl	8002254 <init_firmware_update_module>
    if (ret != ETX_OTA_EC_OK)
 800383a:	b1c8      	cbz	r0, 8003870 <main+0x37c>
                dst[0] = Command_NULL_in_ASCII;
 800383c:	f04f 7283 	mov.w	r2, #17170432	; 0x1060000
 8003840:	2330      	movs	r3, #48	; 0x30
 8003842:	4d65      	ldr	r5, [pc, #404]	; (80039d8 <main+0x4e4>)
        display_output[0] = 'E';
 8003844:	4e65      	ldr	r6, [pc, #404]	; (80039dc <main+0x4e8>)
 8003846:	4966      	ldr	r1, [pc, #408]	; (80039e0 <main+0x4ec>)
                dst[0] = Command_NULL_in_ASCII;
 8003848:	e9c5 2300 	strd	r2, r3, [r5]
        display_output[0] = 'E';
 800384c:	e9c4 6100 	strd	r6, r1, [r4]
            set_5641as_display_output(display_output);
 8003850:	4c64      	ldr	r4, [pc, #400]	; (80039e4 <main+0x4f0>)
 8003852:	4620      	mov	r0, r4
 8003854:	f7fe f968 	bl	8001b28 <set_5641as_display_output>
            HAL_Delay(2000);
 8003858:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 800385c:	f000 fa0c 	bl	8003c78 <HAL_Delay>
            set_5641as_display_output(ascii_error_code);
 8003860:	4628      	mov	r0, r5
 8003862:	f7fe f961 	bl	8001b28 <set_5641as_display_output>
            HAL_Delay(2000);
 8003866:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 800386a:	f000 fa05 	bl	8003c78 <HAL_Delay>
        while (1)
 800386e:	e7f0      	b.n	8003852 <main+0x35e>
    if (fw_config.BL_fw_rec_crc != DATA_BLOCK_32BIT_ERASED_VALUE)
 8003870:	686b      	ldr	r3, [r5, #4]
 8003872:	3301      	adds	r3, #1
 8003874:	d01f      	beq.n	80038b6 <main+0x3c2>
        uint32_t cal_crc = crc32_mpeg2((uint8_t *) BOOTLOADER_FIRMWARE_ADDRESS, fw_config.BL_fw_size);
 8003876:	6829      	ldr	r1, [r5, #0]
 8003878:	485b      	ldr	r0, [pc, #364]	; (80039e8 <main+0x4f4>)
 800387a:	f7fe ffe1 	bl	8002840 <crc32_mpeg2>
        if (cal_crc != fw_config.BL_fw_rec_crc)
 800387e:	686b      	ldr	r3, [r5, #4]
 8003880:	4298      	cmp	r0, r3
 8003882:	d018      	beq.n	80038b6 <main+0x3c2>
                dst[0] = Command_NULL_in_ASCII;
 8003884:	2330      	movs	r3, #48	; 0x30
            display_output[0] = 'E';
 8003886:	4a55      	ldr	r2, [pc, #340]	; (80039dc <main+0x4e8>)
                dst[0] = Command_NULL_in_ASCII;
 8003888:	4d53      	ldr	r5, [pc, #332]	; (80039d8 <main+0x4e4>)
 800388a:	4958      	ldr	r1, [pc, #352]	; (80039ec <main+0x4f8>)
            display_output[0] = 'E';
 800388c:	6022      	str	r2, [r4, #0]
 800388e:	4a54      	ldr	r2, [pc, #336]	; (80039e0 <main+0x4ec>)
                set_5641as_display_output(display_output);
 8003890:	4e54      	ldr	r6, [pc, #336]	; (80039e4 <main+0x4f0>)
                dst[0] = Command_NULL_in_ASCII;
 8003892:	6029      	str	r1, [r5, #0]
            display_output[0] = 'E';
 8003894:	6062      	str	r2, [r4, #4]
                dst[0] = Command_NULL_in_ASCII;
 8003896:	606b      	str	r3, [r5, #4]
                set_5641as_display_output(display_output);
 8003898:	4630      	mov	r0, r6
 800389a:	f7fe f945 	bl	8001b28 <set_5641as_display_output>
                HAL_Delay(2000);
 800389e:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80038a2:	f000 f9e9 	bl	8003c78 <HAL_Delay>
                set_5641as_display_output(ascii_error_code);
 80038a6:	4628      	mov	r0, r5
 80038a8:	f7fe f93e 	bl	8001b28 <set_5641as_display_output>
                HAL_Delay(2000);
 80038ac:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80038b0:	f000 f9e2 	bl	8003c78 <HAL_Delay>
            while (1)
 80038b4:	e7f0      	b.n	8003898 <main+0x3a4>
  validate_application_firmware(&is_app_fw_validation_ok);
 80038b6:	a80b      	add	r0, sp, #44	; 0x2c
 80038b8:	f7ff fda8 	bl	800340c <validate_application_firmware>
  HAL_Delay(PRE_ETX_OTA_REQUESTS_HEARING_DELAY);
 80038bc:	f640 30b8 	movw	r0, #3000	; 0xbb8
 80038c0:	f000 f9da 	bl	8003c78 <HAL_Delay>
  HAL_uart_rx_flush(&huart3);
 80038c4:	f7ff fdbe 	bl	8003444 <HAL_uart_rx_flush.constprop.0>
  display_output[0] = '.';
 80038c8:	f04f 132e 	mov.w	r3, #3014702	; 0x2e002e
  set_5641as_display_output(display_output);
 80038cc:	4845      	ldr	r0, [pc, #276]	; (80039e4 <main+0x4f0>)
  display_output[0] = '.';
 80038ce:	e9c4 3300 	strd	r3, r3, [r4]
                set_5641as_display_output(display_output);
 80038d2:	4607      	mov	r7, r0
  set_5641as_display_output(display_output);
 80038d4:	f7fe f928 	bl	8001b28 <set_5641as_display_output>
  end_tick = HAL_GetTick() + ETX_CUSTOM_HAL_TIMEOUT;
 80038d8:	f000 f9c8 	bl	8003c6c <HAL_GetTick>
  uint32_t current_tick = 0;
 80038dc:	2500      	movs	r5, #0
                display_output[0] = 'E';
 80038de:	f44f 0a8a 	mov.w	sl, #4521984	; 0x450000
  end_tick = HAL_GetTick() + ETX_CUSTOM_HAL_TIMEOUT;
 80038e2:	f500 560c 	add.w	r6, r0, #8960	; 0x2300
                display_output[0] = 'E';
 80038e6:	f8df 9108 	ldr.w	r9, [pc, #264]	; 80039f0 <main+0x4fc>
  end_tick = HAL_GetTick() + ETX_CUSTOM_HAL_TIMEOUT;
 80038ea:	3628      	adds	r6, #40	; 0x28
		  ret = firmware_image_download_and_install();
 80038ec:	f7fe fd0c 	bl	8002308 <firmware_image_download_and_install>
 80038f0:	4680      	mov	r8, r0
		  start_5641as_display_module(); // We start back again the 5641AS Driver Timer's Base generation in Interrupt Mode.
 80038f2:	f7fe f90d 	bl	8001b10 <start_5641as_display_module>
		  switch (ret)
 80038f6:	f1b8 0f04 	cmp.w	r8, #4
 80038fa:	d84a      	bhi.n	8003992 <main+0x49e>
 80038fc:	e8df f008 	tbb	[pc, r8]
 8003900:	442d3803 	.word	0x442d3803
 8003904:	24          	.byte	0x24
 8003905:	00          	.byte	0x00
				HAL_NVIC_SystemReset();
 8003906:	f000 fa27 	bl	8003d58 <HAL_NVIC_SystemReset>
	  while ((current_tick<end_tick) || (is_app_fw_validation_ok==0));
 800390a:	42b5      	cmp	r5, r6
 800390c:	d3ee      	bcc.n	80038ec <main+0x3f8>
 800390e:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 8003912:	2b00      	cmp	r3, #0
 8003914:	d0ea      	beq.n	80038ec <main+0x3f8>
	  validate_application_firmware(&is_app_fw_validation_ok);
 8003916:	a80b      	add	r0, sp, #44	; 0x2c
 8003918:	f7ff fd78 	bl	800340c <validate_application_firmware>
  while (is_app_fw_validation_ok == 0);
 800391c:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 8003920:	2b00      	cmp	r3, #0
 8003922:	d0e3      	beq.n	80038ec <main+0x3f8>
  display_output[0] = 0;
 8003924:	2300      	movs	r3, #0
  set_5641as_display_output(display_output);
 8003926:	482f      	ldr	r0, [pc, #188]	; (80039e4 <main+0x4f0>)
  display_output[0] = 0;
 8003928:	e9c4 3300 	strd	r3, r3, [r4]
  set_5641as_display_output(display_output);
 800392c:	f7fe f8fc 	bl	8001b28 <set_5641as_display_output>
  HAL_Delay(1); // Give the right Delay to guarantee that the 5641AS 7-segment Display Device LEDs will all be turned Off.
 8003930:	2001      	movs	r0, #1
 8003932:	f000 f9a1 	bl	8003c78 <HAL_Delay>
  stop_5641as_display_module();
 8003936:	f7fe f8f1 	bl	8001b1c <stop_5641as_display_module>
  HAL_Delay(1); // Give the right Delay to guarantee that the non-blocking Interrupts will stop working (this is based in the time at which they are triggered, which was configured at the STM32CubeMx App).
 800393a:	2001      	movs	r0, #1
 800393c:	f000 f99c 	bl	8003c78 <HAL_Delay>
	void (*app_reset_handler) (void) = (void*) (*(volatile uint32_t *) (APPLICATION_FIRMWARE_RESET_HANDLER_ADDRESS));
 8003940:	4b2c      	ldr	r3, [pc, #176]	; (80039f4 <main+0x500>)
 8003942:	685b      	ldr	r3, [r3, #4]
	app_reset_handler();
 8003944:	4798      	blx	r3
  while (1)
 8003946:	e7fe      	b.n	8003946 <main+0x452>
				current_tick = HAL_GetTick();
 8003948:	f000 f990 	bl	8003c6c <HAL_GetTick>
                display_output[0] = 'E';
 800394c:	e9c4 9a00 	strd	r9, sl, [r4]
				current_tick = HAL_GetTick();
 8003950:	4605      	mov	r5, r0
                set_5641as_display_output(display_output);
 8003952:	4638      	mov	r0, r7
 8003954:	f7fe f8e8 	bl	8001b28 <set_5641as_display_output>
				break;
 8003958:	e7d7      	b.n	800390a <main+0x416>
				current_tick = HAL_GetTick();
 800395a:	f000 f987 	bl	8003c6c <HAL_GetTick>
				display_output[0] = '.';
 800395e:	f04f 132e 	mov.w	r3, #3014702	; 0x2e002e
				current_tick = HAL_GetTick();
 8003962:	4605      	mov	r5, r0
				display_output[0] = '.';
 8003964:	e9c4 3300 	strd	r3, r3, [r4]
				set_5641as_display_output(display_output);
 8003968:	4638      	mov	r0, r7
 800396a:	f7fe f8dd 	bl	8001b28 <set_5641as_display_output>
				break;
 800396e:	e7cc      	b.n	800390a <main+0x416>
				current_tick = HAL_GetTick();
 8003970:	f000 f97c 	bl	8003c6c <HAL_GetTick>
                display_output[0] = 'E';
 8003974:	f44f 03a2 	mov.w	r3, #5308416	; 0x510000
				current_tick = HAL_GetTick();
 8003978:	4605      	mov	r5, r0
				display_output[0] = 'E';
 800397a:	6063      	str	r3, [r4, #4]
				set_5641as_display_output(display_output);
 800397c:	4638      	mov	r0, r7
				display_output[0] = 'E';
 800397e:	f8c4 9000 	str.w	r9, [r4]
				set_5641as_display_output(display_output);
 8003982:	f7fe f8d1 	bl	8001b28 <set_5641as_display_output>
				break;
 8003986:	e7c0      	b.n	800390a <main+0x416>
				current_tick = HAL_GetTick();
 8003988:	f000 f970 	bl	8003c6c <HAL_GetTick>
				display_output[0] = 'E';
 800398c:	f44f 0386 	mov.w	r3, #4390912	; 0x430000
 8003990:	e7f2      	b.n	8003978 <main+0x484>
                dst[0] = Command_NULL_in_ASCII;
 8003992:	f04f 7282 	mov.w	r2, #17039360	; 0x1040000
 8003996:	2330      	movs	r3, #48	; 0x30
 8003998:	4d0f      	ldr	r5, [pc, #60]	; (80039d8 <main+0x4e4>)
                display_output[0] = 'E';
 800399a:	4810      	ldr	r0, [pc, #64]	; (80039dc <main+0x4e8>)
 800399c:	4910      	ldr	r1, [pc, #64]	; (80039e0 <main+0x4ec>)
                dst[0] = Command_NULL_in_ASCII;
 800399e:	e9c5 2300 	strd	r2, r3, [r5]
                display_output[0] = 'E';
 80039a2:	e9c4 0100 	strd	r0, r1, [r4]
                    set_5641as_display_output(display_output);
 80039a6:	4c0f      	ldr	r4, [pc, #60]	; (80039e4 <main+0x4f0>)
 80039a8:	4620      	mov	r0, r4
 80039aa:	f7fe f8bd 	bl	8001b28 <set_5641as_display_output>
                    HAL_Delay(2000);
 80039ae:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80039b2:	f000 f961 	bl	8003c78 <HAL_Delay>
                    set_5641as_display_output(ascii_error_code);
 80039b6:	4628      	mov	r0, r5
 80039b8:	f7fe f8b6 	bl	8001b28 <set_5641as_display_output>
                    HAL_Delay(2000);
 80039bc:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80039c0:	f000 f95a 	bl	8003c78 <HAL_Delay>
                while (1)
 80039c4:	e7f0      	b.n	80039a8 <main+0x4b4>
 80039c6:	bf00      	nop
 80039c8:	20000500 	.word	0x20000500
 80039cc:	200004a0 	.word	0x200004a0
 80039d0:	40011000 	.word	0x40011000
 80039d4:	200005a8 	.word	0x200005a8
 80039d8:	200004a8 	.word	0x200004a8
 80039dc:	00720045 	.word	0x00720045
 80039e0:	003d0072 	.word	0x003d0072
 80039e4:	200004b0 	.word	0x200004b0
 80039e8:	08001800 	.word	0x08001800
 80039ec:	01070000 	.word	0x01070000
 80039f0:	004f0045 	.word	0x004f0045
 80039f4:	08008000 	.word	0x08008000

080039f8 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 80039f8:	4b0a      	ldr	r3, [pc, #40]	; (8003a24 <HAL_MspInit+0x2c>)
{
 80039fa:	b082      	sub	sp, #8
  __HAL_RCC_AFIO_CLK_ENABLE();
 80039fc:	699a      	ldr	r2, [r3, #24]
 80039fe:	f042 0201 	orr.w	r2, r2, #1
 8003a02:	619a      	str	r2, [r3, #24]
 8003a04:	699a      	ldr	r2, [r3, #24]
 8003a06:	f002 0201 	and.w	r2, r2, #1
 8003a0a:	9200      	str	r2, [sp, #0]
 8003a0c:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8003a0e:	69da      	ldr	r2, [r3, #28]
 8003a10:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003a14:	61da      	str	r2, [r3, #28]
 8003a16:	69db      	ldr	r3, [r3, #28]
 8003a18:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003a1c:	9301      	str	r3, [sp, #4]
 8003a1e:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8003a20:	b002      	add	sp, #8
 8003a22:	4770      	bx	lr
 8003a24:	40021000 	.word	0x40021000

08003a28 <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 8003a28:	b500      	push	{lr}
  if(htim_base->Instance==TIM2)
 8003a2a:	6803      	ldr	r3, [r0, #0]
{
 8003a2c:	b083      	sub	sp, #12
  if(htim_base->Instance==TIM2)
 8003a2e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8003a32:	d012      	beq.n	8003a5a <HAL_TIM_Base_MspInit+0x32>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
  else if(htim_base->Instance==TIM3)
 8003a34:	4a14      	ldr	r2, [pc, #80]	; (8003a88 <HAL_TIM_Base_MspInit+0x60>)
 8003a36:	4293      	cmp	r3, r2
 8003a38:	d002      	beq.n	8003a40 <HAL_TIM_Base_MspInit+0x18>
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }

}
 8003a3a:	b003      	add	sp, #12
 8003a3c:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_RCC_TIM3_CLK_ENABLE();
 8003a40:	4b12      	ldr	r3, [pc, #72]	; (8003a8c <HAL_TIM_Base_MspInit+0x64>)
 8003a42:	69da      	ldr	r2, [r3, #28]
 8003a44:	f042 0202 	orr.w	r2, r2, #2
 8003a48:	61da      	str	r2, [r3, #28]
 8003a4a:	69db      	ldr	r3, [r3, #28]
 8003a4c:	f003 0302 	and.w	r3, r3, #2
 8003a50:	9301      	str	r3, [sp, #4]
 8003a52:	9b01      	ldr	r3, [sp, #4]
}
 8003a54:	b003      	add	sp, #12
 8003a56:	f85d fb04 	ldr.w	pc, [sp], #4
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8003a5a:	2200      	movs	r2, #0
    __HAL_RCC_TIM2_CLK_ENABLE();
 8003a5c:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8003a60:	69d9      	ldr	r1, [r3, #28]
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8003a62:	201c      	movs	r0, #28
    __HAL_RCC_TIM2_CLK_ENABLE();
 8003a64:	f041 0101 	orr.w	r1, r1, #1
 8003a68:	61d9      	str	r1, [r3, #28]
 8003a6a:	69db      	ldr	r3, [r3, #28]
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8003a6c:	4611      	mov	r1, r2
    __HAL_RCC_TIM2_CLK_ENABLE();
 8003a6e:	f003 0301 	and.w	r3, r3, #1
 8003a72:	9300      	str	r3, [sp, #0]
 8003a74:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8003a76:	f000 f923 	bl	8003cc0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8003a7a:	201c      	movs	r0, #28
}
 8003a7c:	b003      	add	sp, #12
 8003a7e:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8003a82:	f000 b95b 	b.w	8003d3c <HAL_NVIC_EnableIRQ>
 8003a86:	bf00      	nop
 8003a88:	40000400 	.word	0x40000400
 8003a8c:	40021000 	.word	0x40021000

08003a90 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003a90:	2300      	movs	r3, #0
{
 8003a92:	b570      	push	{r4, r5, r6, lr}
  if(htim->Instance==TIM3)
 8003a94:	4a11      	ldr	r2, [pc, #68]	; (8003adc <HAL_TIM_MspPostInit+0x4c>)
 8003a96:	6801      	ldr	r1, [r0, #0]
{
 8003a98:	b086      	sub	sp, #24
  if(htim->Instance==TIM3)
 8003a9a:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003a9c:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8003aa0:	e9cd 3304 	strd	r3, r3, [sp, #16]
  if(htim->Instance==TIM3)
 8003aa4:	d001      	beq.n	8003aaa <HAL_TIM_MspPostInit+0x1a>
  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }

}
 8003aa6:	b006      	add	sp, #24
 8003aa8:	bd70      	pop	{r4, r5, r6, pc}
    GPIO_InitStruct.Pin = Cold_Fan_PWM_TIM3_CH1_Pin|Hot_Fan_PWM_TIM3_CH2_Pin;
 8003aaa:	24c0      	movs	r4, #192	; 0xc0
 8003aac:	2502      	movs	r5, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8003aae:	2602      	movs	r6, #2
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003ab0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8003ab4:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8003ab8:	699a      	ldr	r2, [r3, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003aba:	4809      	ldr	r0, [pc, #36]	; (8003ae0 <HAL_TIM_MspPostInit+0x50>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003abc:	f042 0204 	orr.w	r2, r2, #4
 8003ac0:	619a      	str	r2, [r3, #24]
 8003ac2:	699b      	ldr	r3, [r3, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003ac4:	a902      	add	r1, sp, #8
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003ac6:	f003 0304 	and.w	r3, r3, #4
 8003aca:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = Cold_Fan_PWM_TIM3_CH1_Pin|Hot_Fan_PWM_TIM3_CH2_Pin;
 8003acc:	e9cd 4502 	strd	r4, r5, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003ad0:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8003ad2:	9605      	str	r6, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003ad4:	f000 fb42 	bl	800415c <HAL_GPIO_Init>
}
 8003ad8:	b006      	add	sp, #24
 8003ada:	bd70      	pop	{r4, r5, r6, pc}
 8003adc:	40000400 	.word	0x40000400
 8003ae0:	40010800 	.word	0x40010800

08003ae4 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8003ae4:	b5d0      	push	{r4, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003ae6:	2400      	movs	r4, #0
  if(huart->Instance==USART3)
 8003ae8:	4b1a      	ldr	r3, [pc, #104]	; (8003b54 <HAL_UART_MspInit+0x70>)
 8003aea:	6802      	ldr	r2, [r0, #0]
{
 8003aec:	b086      	sub	sp, #24
  if(huart->Instance==USART3)
 8003aee:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003af0:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8003af4:	e9cd 4404 	strd	r4, r4, [sp, #16]
  if(huart->Instance==USART3)
 8003af8:	d001      	beq.n	8003afe <HAL_UART_MspInit+0x1a>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 8003afa:	b006      	add	sp, #24
 8003afc:	bdd0      	pop	{r4, r6, r7, pc}
    __HAL_RCC_USART3_CLK_ENABLE();
 8003afe:	f503 33e4 	add.w	r3, r3, #116736	; 0x1c800
 8003b02:	69da      	ldr	r2, [r3, #28]
    GPIO_InitStruct.Pin = BLE_TX_Pin;
 8003b04:	f44f 6680 	mov.w	r6, #1024	; 0x400
    __HAL_RCC_USART3_CLK_ENABLE();
 8003b08:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8003b0c:	61da      	str	r2, [r3, #28]
 8003b0e:	69da      	ldr	r2, [r3, #28]
    GPIO_InitStruct.Pin = BLE_TX_Pin;
 8003b10:	2702      	movs	r7, #2
    __HAL_RCC_USART3_CLK_ENABLE();
 8003b12:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 8003b16:	9200      	str	r2, [sp, #0]
 8003b18:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003b1a:	699a      	ldr	r2, [r3, #24]
    HAL_GPIO_Init(BLE_TX_GPIO_Port, &GPIO_InitStruct);
 8003b1c:	a902      	add	r1, sp, #8
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003b1e:	f042 0208 	orr.w	r2, r2, #8
 8003b22:	619a      	str	r2, [r3, #24]
 8003b24:	699b      	ldr	r3, [r3, #24]
    HAL_GPIO_Init(BLE_TX_GPIO_Port, &GPIO_InitStruct);
 8003b26:	480c      	ldr	r0, [pc, #48]	; (8003b58 <HAL_UART_MspInit+0x74>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003b28:	f003 0308 	and.w	r3, r3, #8
 8003b2c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8003b2e:	2303      	movs	r3, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003b30:	9a01      	ldr	r2, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8003b32:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = BLE_TX_Pin;
 8003b34:	e9cd 6702 	strd	r6, r7, [sp, #8]
    HAL_GPIO_Init(BLE_TX_GPIO_Port, &GPIO_InitStruct);
 8003b38:	f000 fb10 	bl	800415c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = BLE_RX_Pin;
 8003b3c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8003b40:	2300      	movs	r3, #0
    HAL_GPIO_Init(BLE_RX_GPIO_Port, &GPIO_InitStruct);
 8003b42:	4805      	ldr	r0, [pc, #20]	; (8003b58 <HAL_UART_MspInit+0x74>)
 8003b44:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = BLE_RX_Pin;
 8003b46:	e9cd 2302 	strd	r2, r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003b4a:	9404      	str	r4, [sp, #16]
    HAL_GPIO_Init(BLE_RX_GPIO_Port, &GPIO_InitStruct);
 8003b4c:	f000 fb06 	bl	800415c <HAL_GPIO_Init>
}
 8003b50:	b006      	add	sp, #24
 8003b52:	bdd0      	pop	{r4, r6, r7, pc}
 8003b54:	40004800 	.word	0x40004800
 8003b58:	40010c00 	.word	0x40010c00

08003b5c <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8003b5c:	e7fe      	b.n	8003b5c <NMI_Handler>
 8003b5e:	bf00      	nop

08003b60 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8003b60:	e7fe      	b.n	8003b60 <HardFault_Handler>
 8003b62:	bf00      	nop

08003b64 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8003b64:	e7fe      	b.n	8003b64 <MemManage_Handler>
 8003b66:	bf00      	nop

08003b68 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8003b68:	e7fe      	b.n	8003b68 <BusFault_Handler>
 8003b6a:	bf00      	nop

08003b6c <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8003b6c:	e7fe      	b.n	8003b6c <UsageFault_Handler>
 8003b6e:	bf00      	nop

08003b70 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8003b70:	4770      	bx	lr
 8003b72:	bf00      	nop

08003b74 <DebugMon_Handler>:
 8003b74:	4770      	bx	lr
 8003b76:	bf00      	nop

08003b78 <PendSV_Handler>:
 8003b78:	4770      	bx	lr
 8003b7a:	bf00      	nop

08003b7c <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8003b7c:	f000 b86a 	b.w	8003c54 <HAL_IncTick>

08003b80 <TIM2_IRQHandler>:
void TIM2_IRQHandler(void)
{
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
 8003b80:	4801      	ldr	r0, [pc, #4]	; (8003b88 <TIM2_IRQHandler+0x8>)
 8003b82:	f001 b9b1 	b.w	8004ee8 <HAL_TIM_IRQHandler>
 8003b86:	bf00      	nop
 8003b88:	20000518 	.word	0x20000518

08003b8c <SystemInit>:
  #endif /* DATA_IN_ExtSRAM */
#endif 

    /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
 8003b8c:	4b01      	ldr	r3, [pc, #4]	; (8003b94 <SystemInit+0x8>)
 8003b8e:	4a02      	ldr	r2, [pc, #8]	; (8003b98 <SystemInit+0xc>)
 8003b90:	609a      	str	r2, [r3, #8]
#endif /* USER_VECT_TAB_ADDRESS */
}
 8003b92:	4770      	bx	lr
 8003b94:	e000ed00 	.word	0xe000ed00
 8003b98:	08001800 	.word	0x08001800

08003b9c <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Call the clock system initialization function.*/
    bl  SystemInit
 8003b9c:	f7ff fff6 	bl	8003b8c <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8003ba0:	480b      	ldr	r0, [pc, #44]	; (8003bd0 <LoopFillZerobss+0xe>)
  ldr r1, =_edata
 8003ba2:	490c      	ldr	r1, [pc, #48]	; (8003bd4 <LoopFillZerobss+0x12>)
  ldr r2, =_sidata
 8003ba4:	4a0c      	ldr	r2, [pc, #48]	; (8003bd8 <LoopFillZerobss+0x16>)
  movs r3, #0
 8003ba6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8003ba8:	e002      	b.n	8003bb0 <LoopCopyDataInit>

08003baa <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8003baa:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8003bac:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8003bae:	3304      	adds	r3, #4

08003bb0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8003bb0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8003bb2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8003bb4:	d3f9      	bcc.n	8003baa <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8003bb6:	4a09      	ldr	r2, [pc, #36]	; (8003bdc <LoopFillZerobss+0x1a>)
  ldr r4, =_ebss
 8003bb8:	4c09      	ldr	r4, [pc, #36]	; (8003be0 <LoopFillZerobss+0x1e>)
  movs r3, #0
 8003bba:	2300      	movs	r3, #0
  b LoopFillZerobss
 8003bbc:	e001      	b.n	8003bc2 <LoopFillZerobss>

08003bbe <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8003bbe:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8003bc0:	3204      	adds	r2, #4

08003bc2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8003bc2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8003bc4:	d3fb      	bcc.n	8003bbe <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8003bc6:	f001 fc0f 	bl	80053e8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8003bca:	f7ff fc93 	bl	80034f4 <main>
  bx lr
 8003bce:	4770      	bx	lr
  ldr r0, =_sdata
 8003bd0:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8003bd4:	20000014 	.word	0x20000014
  ldr r2, =_sidata
 8003bd8:	080058ac 	.word	0x080058ac
  ldr r2, =_sbss
 8003bdc:	20000018 	.word	0x20000018
  ldr r4, =_ebss
 8003be0:	20000618 	.word	0x20000618

08003be4 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8003be4:	e7fe      	b.n	8003be4 <ADC1_2_IRQHandler>
	...

08003be8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8003be8:	b538      	push	{r3, r4, r5, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8003bea:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003bee:	4a0d      	ldr	r2, [pc, #52]	; (8003c24 <HAL_InitTick+0x3c>)
{
 8003bf0:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8003bf2:	7811      	ldrb	r1, [r2, #0]
 8003bf4:	4a0c      	ldr	r2, [pc, #48]	; (8003c28 <HAL_InitTick+0x40>)
 8003bf6:	fbb3 f3f1 	udiv	r3, r3, r1
 8003bfa:	6812      	ldr	r2, [r2, #0]
 8003bfc:	fbb2 f0f3 	udiv	r0, r2, r3
 8003c00:	f000 f8bc 	bl	8003d7c <HAL_SYSTICK_Config>
 8003c04:	b908      	cbnz	r0, 8003c0a <HAL_InitTick+0x22>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8003c06:	2d0f      	cmp	r5, #15
 8003c08:	d901      	bls.n	8003c0e <HAL_InitTick+0x26>
    return HAL_ERROR;
 8003c0a:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 8003c0c:	bd38      	pop	{r3, r4, r5, pc}
 8003c0e:	4604      	mov	r4, r0
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8003c10:	4602      	mov	r2, r0
 8003c12:	4629      	mov	r1, r5
 8003c14:	f04f 30ff 	mov.w	r0, #4294967295
 8003c18:	f000 f852 	bl	8003cc0 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8003c1c:	4b03      	ldr	r3, [pc, #12]	; (8003c2c <HAL_InitTick+0x44>)
 8003c1e:	4620      	mov	r0, r4
 8003c20:	601d      	str	r5, [r3, #0]
}
 8003c22:	bd38      	pop	{r3, r4, r5, pc}
 8003c24:	2000000c 	.word	0x2000000c
 8003c28:	20000008 	.word	0x20000008
 8003c2c:	20000010 	.word	0x20000010

08003c30 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8003c30:	4a07      	ldr	r2, [pc, #28]	; (8003c50 <HAL_Init+0x20>)
{
 8003c32:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8003c34:	6813      	ldr	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8003c36:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8003c38:	f043 0310 	orr.w	r3, r3, #16
 8003c3c:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8003c3e:	f000 f82d 	bl	8003c9c <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8003c42:	200f      	movs	r0, #15
 8003c44:	f7ff ffd0 	bl	8003be8 <HAL_InitTick>
  HAL_MspInit();
 8003c48:	f7ff fed6 	bl	80039f8 <HAL_MspInit>
}
 8003c4c:	2000      	movs	r0, #0
 8003c4e:	bd08      	pop	{r3, pc}
 8003c50:	40022000 	.word	0x40022000

08003c54 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8003c54:	4a03      	ldr	r2, [pc, #12]	; (8003c64 <HAL_IncTick+0x10>)
 8003c56:	4b04      	ldr	r3, [pc, #16]	; (8003c68 <HAL_IncTick+0x14>)
 8003c58:	6811      	ldr	r1, [r2, #0]
 8003c5a:	781b      	ldrb	r3, [r3, #0]
 8003c5c:	440b      	add	r3, r1
 8003c5e:	6013      	str	r3, [r2, #0]
}
 8003c60:	4770      	bx	lr
 8003c62:	bf00      	nop
 8003c64:	200005f0 	.word	0x200005f0
 8003c68:	2000000c 	.word	0x2000000c

08003c6c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8003c6c:	4b01      	ldr	r3, [pc, #4]	; (8003c74 <HAL_GetTick+0x8>)
 8003c6e:	6818      	ldr	r0, [r3, #0]
}
 8003c70:	4770      	bx	lr
 8003c72:	bf00      	nop
 8003c74:	200005f0 	.word	0x200005f0

08003c78 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8003c78:	b538      	push	{r3, r4, r5, lr}
 8003c7a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8003c7c:	f7ff fff6 	bl	8003c6c <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8003c80:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 8003c82:	4605      	mov	r5, r0
  if (wait < HAL_MAX_DELAY)
 8003c84:	d002      	beq.n	8003c8c <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 8003c86:	4b04      	ldr	r3, [pc, #16]	; (8003c98 <HAL_Delay+0x20>)
 8003c88:	781b      	ldrb	r3, [r3, #0]
 8003c8a:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8003c8c:	f7ff ffee 	bl	8003c6c <HAL_GetTick>
 8003c90:	1b40      	subs	r0, r0, r5
 8003c92:	42a0      	cmp	r0, r4
 8003c94:	d3fa      	bcc.n	8003c8c <HAL_Delay+0x14>
  {
  }
}
 8003c96:	bd38      	pop	{r3, r4, r5, pc}
 8003c98:	2000000c 	.word	0x2000000c

08003c9c <HAL_NVIC_SetPriorityGrouping>:
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8003c9c:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003ca0:	4906      	ldr	r1, [pc, #24]	; (8003cbc <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 8003ca2:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003ca4:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 8003ca6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8003caa:	ea02 020c 	and.w	r2, r2, ip
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8003cae:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8003cb0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8003cb4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 8003cb8:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8003cba:	4770      	bx	lr
 8003cbc:	e000ed00 	.word	0xe000ed00

08003cc0 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8003cc0:	4b1c      	ldr	r3, [pc, #112]	; (8003d34 <HAL_NVIC_SetPriority+0x74>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8003cc2:	b500      	push	{lr}
 8003cc4:	68db      	ldr	r3, [r3, #12]
 8003cc6:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8003cca:	f1c3 0e07 	rsb	lr, r3, #7
 8003cce:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8003cd2:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8003cd6:	bf28      	it	cs
 8003cd8:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8003cdc:	f1bc 0f06 	cmp.w	ip, #6
 8003ce0:	d91b      	bls.n	8003d1a <HAL_NVIC_SetPriority+0x5a>

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8003ce2:	f04f 3cff 	mov.w	ip, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8003ce6:	3b03      	subs	r3, #3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8003ce8:	fa0c fc03 	lsl.w	ip, ip, r3
 8003cec:	ea22 020c 	bic.w	r2, r2, ip
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8003cf0:	f04f 3cff 	mov.w	ip, #4294967295
 8003cf4:	fa0c fc0e 	lsl.w	ip, ip, lr
 8003cf8:	ea21 010c 	bic.w	r1, r1, ip
 8003cfc:	4099      	lsls	r1, r3
  if ((int32_t)(IRQn) >= 0)
 8003cfe:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8003d00:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 8003d04:	db0c      	blt.n	8003d20 <HAL_NVIC_SetPriority+0x60>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003d06:	0109      	lsls	r1, r1, #4
 8003d08:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8003d0c:	b2c9      	uxtb	r1, r1
 8003d0e:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8003d12:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8003d16:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d1a:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8003d1c:	4613      	mov	r3, r2
 8003d1e:	e7e7      	b.n	8003cf0 <HAL_NVIC_SetPriority+0x30>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003d20:	4b05      	ldr	r3, [pc, #20]	; (8003d38 <HAL_NVIC_SetPriority+0x78>)
 8003d22:	f000 000f 	and.w	r0, r0, #15
 8003d26:	0109      	lsls	r1, r1, #4
 8003d28:	b2c9      	uxtb	r1, r1
 8003d2a:	4403      	add	r3, r0
 8003d2c:	7619      	strb	r1, [r3, #24]
 8003d2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d32:	bf00      	nop
 8003d34:	e000ed00 	.word	0xe000ed00
 8003d38:	e000ecfc 	.word	0xe000ecfc

08003d3c <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8003d3c:	2800      	cmp	r0, #0
 8003d3e:	db07      	blt.n	8003d50 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8003d40:	2301      	movs	r3, #1
 8003d42:	f000 011f 	and.w	r1, r0, #31
 8003d46:	4a03      	ldr	r2, [pc, #12]	; (8003d54 <HAL_NVIC_EnableIRQ+0x18>)
 8003d48:	0940      	lsrs	r0, r0, #5
 8003d4a:	408b      	lsls	r3, r1
 8003d4c:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8003d50:	4770      	bx	lr
 8003d52:	bf00      	nop
 8003d54:	e000e100 	.word	0xe000e100

08003d58 <HAL_NVIC_SystemReset>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8003d58:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8003d5c:	4905      	ldr	r1, [pc, #20]	; (8003d74 <HAL_NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8003d5e:	4b06      	ldr	r3, [pc, #24]	; (8003d78 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8003d60:	68ca      	ldr	r2, [r1, #12]
 8003d62:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8003d66:	4313      	orrs	r3, r2
 8003d68:	60cb      	str	r3, [r1, #12]
 8003d6a:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8003d6e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8003d70:	e7fd      	b.n	8003d6e <HAL_NVIC_SystemReset+0x16>
 8003d72:	bf00      	nop
 8003d74:	e000ed00 	.word	0xe000ed00
 8003d78:	05fa0004 	.word	0x05fa0004

08003d7c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8003d7c:	3801      	subs	r0, #1
 8003d7e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8003d82:	d20f      	bcs.n	8003da4 <HAL_SYSTICK_Config+0x28>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8003d84:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003d88:	f04f 0cf0 	mov.w	ip, #240	; 0xf0
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8003d8c:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8003d8e:	2107      	movs	r1, #7
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8003d90:	b410      	push	{r4}
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003d92:	4c05      	ldr	r4, [pc, #20]	; (8003da8 <HAL_SYSTICK_Config+0x2c>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8003d94:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003d96:	f884 c023 	strb.w	ip, [r4, #35]	; 0x23
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8003d9a:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8003d9c:	619a      	str	r2, [r3, #24]
   return SysTick_Config(TicksNumb);
}
 8003d9e:	bc10      	pop	{r4}
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8003da0:	6119      	str	r1, [r3, #16]
 8003da2:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8003da4:	2001      	movs	r0, #1
 8003da6:	4770      	bx	lr
 8003da8:	e000ed00 	.word	0xe000ed00

08003dac <HAL_FLASH_Unlock>:
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef __attribute__((optimize("O0"))) HAL_FLASH_Unlock(void)
//HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
 8003dac:	b480      	push	{r7}
 8003dae:	b083      	sub	sp, #12
 8003db0:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 8003db2:	2300      	movs	r3, #0
 8003db4:	71fb      	strb	r3, [r7, #7]

  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8003db6:	4b0d      	ldr	r3, [pc, #52]	; (8003dec <HAL_FLASH_Unlock+0x40>)
 8003db8:	691b      	ldr	r3, [r3, #16]
 8003dba:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003dbe:	2b00      	cmp	r3, #0
 8003dc0:	d00d      	beq.n	8003dde <HAL_FLASH_Unlock+0x32>
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8003dc2:	4b0a      	ldr	r3, [pc, #40]	; (8003dec <HAL_FLASH_Unlock+0x40>)
 8003dc4:	4a0a      	ldr	r2, [pc, #40]	; (8003df0 <HAL_FLASH_Unlock+0x44>)
 8003dc6:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8003dc8:	4b08      	ldr	r3, [pc, #32]	; (8003dec <HAL_FLASH_Unlock+0x40>)
 8003dca:	4a0a      	ldr	r2, [pc, #40]	; (8003df4 <HAL_FLASH_Unlock+0x48>)
 8003dcc:	605a      	str	r2, [r3, #4]

    /* Verify Flash is unlocked */
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8003dce:	4b07      	ldr	r3, [pc, #28]	; (8003dec <HAL_FLASH_Unlock+0x40>)
 8003dd0:	691b      	ldr	r3, [r3, #16]
 8003dd2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003dd6:	2b00      	cmp	r3, #0
 8003dd8:	d001      	beq.n	8003dde <HAL_FLASH_Unlock+0x32>
    {
      status = HAL_ERROR;
 8003dda:	2301      	movs	r3, #1
 8003ddc:	71fb      	strb	r3, [r7, #7]
      status = HAL_ERROR;
    }
  }
#endif /* FLASH_BANK2_END */

  return status;
 8003dde:	79fb      	ldrb	r3, [r7, #7]
}
 8003de0:	4618      	mov	r0, r3
 8003de2:	370c      	adds	r7, #12
 8003de4:	46bd      	mov	sp, r7
 8003de6:	bc80      	pop	{r7}
 8003de8:	4770      	bx	lr
 8003dea:	bf00      	nop
 8003dec:	40022000 	.word	0x40022000
 8003df0:	45670123 	.word	0x45670123
 8003df4:	cdef89ab 	.word	0xcdef89ab

08003df8 <HAL_FLASH_Program>:
{
 8003df8:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
  __HAL_LOCK(&pFlash);
 8003dfc:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 8003fd0 <HAL_FLASH_Program+0x1d8>
{
 8003e00:	b082      	sub	sp, #8
  __HAL_LOCK(&pFlash);
 8003e02:	f89a 4018 	ldrb.w	r4, [sl, #24]
{
 8003e06:	e9cd 2000 	strd	r2, r0, [sp]
  __HAL_LOCK(&pFlash);
 8003e0a:	2c01      	cmp	r4, #1
 8003e0c:	f000 80d2 	beq.w	8003fb4 <HAL_FLASH_Program+0x1bc>
 8003e10:	469b      	mov	fp, r3
 8003e12:	2301      	movs	r3, #1
 8003e14:	4689      	mov	r9, r1
 8003e16:	f88a 3018 	strb.w	r3, [sl, #24]
{
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
     
  uint32_t tickstart = HAL_GetTick();
 8003e1a:	f7ff ff27 	bl	8003c6c <HAL_GetTick>
     
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
  { 
    if (Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8003e1e:	f24c 3650 	movw	r6, #50000	; 0xc350
  uint32_t tickstart = HAL_GetTick();
 8003e22:	4604      	mov	r4, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8003e24:	4d6b      	ldr	r5, [pc, #428]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
 8003e26:	e005      	b.n	8003e34 <HAL_FLASH_Program+0x3c>
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8003e28:	f7ff ff20 	bl	8003c6c <HAL_GetTick>
 8003e2c:	1b00      	subs	r0, r0, r4
 8003e2e:	42b0      	cmp	r0, r6
 8003e30:	f200 80be 	bhi.w	8003fb0 <HAL_FLASH_Program+0x1b8>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8003e34:	68eb      	ldr	r3, [r5, #12]
 8003e36:	07da      	lsls	r2, r3, #31
 8003e38:	d4f6      	bmi.n	8003e28 <HAL_FLASH_Program+0x30>
      }
    }
  }
  
  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8003e3a:	68eb      	ldr	r3, [r5, #12]
 8003e3c:	069b      	lsls	r3, r3, #26
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8003e3e:	bf44      	itt	mi
 8003e40:	2320      	movmi	r3, #32
 8003e42:	60eb      	strmi	r3, [r5, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8003e44:	4b63      	ldr	r3, [pc, #396]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
 8003e46:	68da      	ldr	r2, [r3, #12]
 8003e48:	06d6      	lsls	r6, r2, #27
 8003e4a:	d458      	bmi.n	8003efe <HAL_FLASH_Program+0x106>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8003e4c:	69da      	ldr	r2, [r3, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8003e4e:	07d5      	lsls	r5, r2, #31
 8003e50:	d455      	bmi.n	8003efe <HAL_FLASH_Program+0x106>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8003e52:	68db      	ldr	r3, [r3, #12]
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8003e54:	f013 0804 	ands.w	r8, r3, #4
 8003e58:	d151      	bne.n	8003efe <HAL_FLASH_Program+0x106>
    if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8003e5a:	9b01      	ldr	r3, [sp, #4]
 8003e5c:	2b01      	cmp	r3, #1
 8003e5e:	d004      	beq.n	8003e6a <HAL_FLASH_Program+0x72>
      nbiterations = 4U;
 8003e60:	2b02      	cmp	r3, #2
 8003e62:	bf0c      	ite	eq
 8003e64:	2302      	moveq	r3, #2
 8003e66:	2304      	movne	r3, #4
 8003e68:	9301      	str	r3, [sp, #4]
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8003e6a:	f24c 3650 	movw	r6, #50000	; 0xc350
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8003e6e:	4c59      	ldr	r4, [pc, #356]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8003e70:	9800      	ldr	r0, [sp, #0]
 8003e72:	ea4f 1308 	mov.w	r3, r8, lsl #4
 8003e76:	f1c3 0120 	rsb	r1, r3, #32
 8003e7a:	f1a3 0220 	sub.w	r2, r3, #32
 8003e7e:	fa0b f101 	lsl.w	r1, fp, r1
 8003e82:	fa20 f303 	lsr.w	r3, r0, r3
 8003e86:	430b      	orrs	r3, r1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8003e88:	2100      	movs	r1, #0
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8003e8a:	fa2b f202 	lsr.w	r2, fp, r2
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8003e8e:	f8ca 101c 	str.w	r1, [sl, #28]
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8003e92:	4313      	orrs	r3, r2
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8003e94:	6922      	ldr	r2, [r4, #16]
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8003e96:	b29b      	uxth	r3, r3
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8003e98:	f042 0201 	orr.w	r2, r2, #1
 8003e9c:	6122      	str	r2, [r4, #16]
  *(__IO uint16_t*)Address = Data;
 8003e9e:	f8a9 3000 	strh.w	r3, [r9]
  uint32_t tickstart = HAL_GetTick();
 8003ea2:	f7ff fee3 	bl	8003c6c <HAL_GetTick>
 8003ea6:	4605      	mov	r5, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8003ea8:	e004      	b.n	8003eb4 <HAL_FLASH_Program+0xbc>
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8003eaa:	f7ff fedf 	bl	8003c6c <HAL_GetTick>
 8003eae:	1b40      	subs	r0, r0, r5
 8003eb0:	42b0      	cmp	r0, r6
 8003eb2:	d875      	bhi.n	8003fa0 <HAL_FLASH_Program+0x1a8>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8003eb4:	68e3      	ldr	r3, [r4, #12]
 8003eb6:	07d9      	lsls	r1, r3, #31
 8003eb8:	d4f7      	bmi.n	8003eaa <HAL_FLASH_Program+0xb2>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8003eba:	68e3      	ldr	r3, [r4, #12]
 8003ebc:	069a      	lsls	r2, r3, #26
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8003ebe:	bf44      	itt	mi
 8003ec0:	2320      	movmi	r3, #32
 8003ec2:	60e3      	strmi	r3, [r4, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8003ec4:	68e3      	ldr	r3, [r4, #12]
 8003ec6:	06db      	lsls	r3, r3, #27
 8003ec8:	d43c      	bmi.n	8003f44 <HAL_FLASH_Program+0x14c>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8003eca:	69e3      	ldr	r3, [r4, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8003ecc:	07dd      	lsls	r5, r3, #31
 8003ece:	d439      	bmi.n	8003f44 <HAL_FLASH_Program+0x14c>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8003ed0:	68e0      	ldr	r0, [r4, #12]
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8003ed2:	f010 0004 	ands.w	r0, r0, #4
 8003ed6:	d135      	bne.n	8003f44 <HAL_FLASH_Program+0x14c>
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8003ed8:	6923      	ldr	r3, [r4, #16]
    for (index = 0U; index < nbiterations; index++)
 8003eda:	f108 0801 	add.w	r8, r8, #1
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8003ede:	f023 0301 	bic.w	r3, r3, #1
 8003ee2:	6123      	str	r3, [r4, #16]
    for (index = 0U; index < nbiterations; index++)
 8003ee4:	9b01      	ldr	r3, [sp, #4]
 8003ee6:	fa5f f288 	uxtb.w	r2, r8
 8003eea:	4293      	cmp	r3, r2
 8003eec:	f109 0902 	add.w	r9, r9, #2
 8003ef0:	d8be      	bhi.n	8003e70 <HAL_FLASH_Program+0x78>
  __HAL_UNLOCK(&pFlash);
 8003ef2:	2300      	movs	r3, #0
 8003ef4:	f88a 3018 	strb.w	r3, [sl, #24]
}
 8003ef8:	b002      	add	sp, #8
 8003efa:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
  uint32_t flags = 0U;
  
#if defined(FLASH_BANK2_END)
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK2))
#else
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8003efe:	4b35      	ldr	r3, [pc, #212]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
 8003f00:	68db      	ldr	r3, [r3, #12]
 8003f02:	f013 0310 	ands.w	r3, r3, #16
 8003f06:	d159      	bne.n	8003fbc <HAL_FLASH_Program+0x1c4>
 8003f08:	2104      	movs	r1, #4
#endif /* FLASH_BANK2_END */
  }
#if defined(FLASH_BANK2_END)
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK2))
#else
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8003f0a:	4a32      	ldr	r2, [pc, #200]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
 8003f0c:	68d2      	ldr	r2, [r2, #12]
 8003f0e:	0754      	lsls	r4, r2, #29
 8003f10:	d506      	bpl.n	8003f20 <HAL_FLASH_Program+0x128>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
#if defined(FLASH_BANK2_END)
    flags |= FLASH_FLAG_PGERR | FLASH_FLAG_PGERR_BANK2;
#else
    flags |= FLASH_FLAG_PGERR;
 8003f12:	460b      	mov	r3, r1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8003f14:	f8da 201c 	ldr.w	r2, [sl, #28]
 8003f18:	f042 0201 	orr.w	r2, r2, #1
 8003f1c:	f8ca 201c 	str.w	r2, [sl, #28]
#endif /* FLASH_BANK2_END */
  }
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8003f20:	4a2c      	ldr	r2, [pc, #176]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
 8003f22:	69d1      	ldr	r1, [r2, #28]
 8003f24:	07c8      	lsls	r0, r1, #31
 8003f26:	d509      	bpl.n	8003f3c <HAL_FLASH_Program+0x144>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8003f28:	f8da 101c 	ldr.w	r1, [sl, #28]
 8003f2c:	f041 0104 	orr.w	r1, r1, #4
 8003f30:	f8ca 101c 	str.w	r1, [sl, #28]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8003f34:	69d1      	ldr	r1, [r2, #28]
 8003f36:	f021 0101 	bic.w	r1, r1, #1
 8003f3a:	61d1      	str	r1, [r2, #28]
  }

  /* Clear FLASH error pending bits */
  __HAL_FLASH_CLEAR_FLAG(flags);
 8003f3c:	4a25      	ldr	r2, [pc, #148]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
    return HAL_ERROR;
 8003f3e:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(flags);
 8003f40:	60d3      	str	r3, [r2, #12]
  if(status == HAL_OK)
 8003f42:	e7d6      	b.n	8003ef2 <HAL_FLASH_Program+0xfa>
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8003f44:	4b23      	ldr	r3, [pc, #140]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
 8003f46:	68da      	ldr	r2, [r3, #12]
 8003f48:	f012 0210 	ands.w	r2, r2, #16
 8003f4c:	d02e      	beq.n	8003fac <HAL_FLASH_Program+0x1b4>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8003f4e:	2114      	movs	r1, #20
    flags |= FLASH_FLAG_WRPERR;
 8003f50:	2210      	movs	r2, #16
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8003f52:	f8da 301c 	ldr.w	r3, [sl, #28]
 8003f56:	f043 0302 	orr.w	r3, r3, #2
 8003f5a:	f8ca 301c 	str.w	r3, [sl, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8003f5e:	4b1d      	ldr	r3, [pc, #116]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
 8003f60:	68db      	ldr	r3, [r3, #12]
 8003f62:	0758      	lsls	r0, r3, #29
 8003f64:	d506      	bpl.n	8003f74 <HAL_FLASH_Program+0x17c>
    flags |= FLASH_FLAG_PGERR;
 8003f66:	460a      	mov	r2, r1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8003f68:	f8da 301c 	ldr.w	r3, [sl, #28]
 8003f6c:	f043 0301 	orr.w	r3, r3, #1
 8003f70:	f8ca 301c 	str.w	r3, [sl, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8003f74:	4b17      	ldr	r3, [pc, #92]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
 8003f76:	69d9      	ldr	r1, [r3, #28]
 8003f78:	07c9      	lsls	r1, r1, #31
 8003f7a:	d509      	bpl.n	8003f90 <HAL_FLASH_Program+0x198>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8003f7c:	f8da 101c 	ldr.w	r1, [sl, #28]
 8003f80:	f041 0104 	orr.w	r1, r1, #4
 8003f84:	f8ca 101c 	str.w	r1, [sl, #28]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8003f88:	69d9      	ldr	r1, [r3, #28]
 8003f8a:	f021 0101 	bic.w	r1, r1, #1
 8003f8e:	61d9      	str	r1, [r3, #28]
  __HAL_FLASH_CLEAR_FLAG(flags);
 8003f90:	4b10      	ldr	r3, [pc, #64]	; (8003fd4 <HAL_FLASH_Program+0x1dc>)
    return HAL_ERROR;
 8003f92:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(flags);
 8003f94:	60da      	str	r2, [r3, #12]
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8003f96:	691a      	ldr	r2, [r3, #16]
 8003f98:	f022 0201 	bic.w	r2, r2, #1
 8003f9c:	611a      	str	r2, [r3, #16]
      if (status != HAL_OK)
 8003f9e:	e7a8      	b.n	8003ef2 <HAL_FLASH_Program+0xfa>
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8003fa0:	6923      	ldr	r3, [r4, #16]
 8003fa2:	2003      	movs	r0, #3
 8003fa4:	f023 0301 	bic.w	r3, r3, #1
 8003fa8:	6123      	str	r3, [r4, #16]
      if (status != HAL_OK)
 8003faa:	e7a2      	b.n	8003ef2 <HAL_FLASH_Program+0xfa>
 8003fac:	2104      	movs	r1, #4
 8003fae:	e7d6      	b.n	8003f5e <HAL_FLASH_Program+0x166>
 8003fb0:	2003      	movs	r0, #3
 8003fb2:	e79e      	b.n	8003ef2 <HAL_FLASH_Program+0xfa>
  __HAL_LOCK(&pFlash);
 8003fb4:	2002      	movs	r0, #2
}
 8003fb6:	b002      	add	sp, #8
 8003fb8:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8003fbc:	f8da 201c 	ldr.w	r2, [sl, #28]
 8003fc0:	2114      	movs	r1, #20
 8003fc2:	f042 0202 	orr.w	r2, r2, #2
    flags |= FLASH_FLAG_WRPERR;
 8003fc6:	2310      	movs	r3, #16
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8003fc8:	f8ca 201c 	str.w	r2, [sl, #28]
    flags |= FLASH_FLAG_WRPERR;
 8003fcc:	e79d      	b.n	8003f0a <HAL_FLASH_Program+0x112>
 8003fce:	bf00      	nop
 8003fd0:	200005f8 	.word	0x200005f8
 8003fd4:	40022000 	.word	0x40022000

08003fd8 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8003fd8:	4a03      	ldr	r2, [pc, #12]	; (8003fe8 <HAL_FLASH_Lock+0x10>)
}
 8003fda:	2000      	movs	r0, #0
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8003fdc:	6913      	ldr	r3, [r2, #16]
 8003fde:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003fe2:	6113      	str	r3, [r2, #16]
}
 8003fe4:	4770      	bx	lr
 8003fe6:	bf00      	nop
 8003fe8:	40022000 	.word	0x40022000

08003fec <FLASH_WaitForLastOperation>:
{
 8003fec:	b570      	push	{r4, r5, r6, lr}
 8003fee:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8003ff0:	f7ff fe3c 	bl	8003c6c <HAL_GetTick>
 8003ff4:	4605      	mov	r5, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8003ff6:	4e26      	ldr	r6, [pc, #152]	; (8004090 <FLASH_WaitForLastOperation+0xa4>)
 8003ff8:	1c60      	adds	r0, r4, #1
 8003ffa:	d136      	bne.n	800406a <FLASH_WaitForLastOperation+0x7e>
 8003ffc:	4a24      	ldr	r2, [pc, #144]	; (8004090 <FLASH_WaitForLastOperation+0xa4>)
 8003ffe:	68d3      	ldr	r3, [r2, #12]
 8004000:	07d9      	lsls	r1, r3, #31
 8004002:	d4fc      	bmi.n	8003ffe <FLASH_WaitForLastOperation+0x12>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8004004:	4b22      	ldr	r3, [pc, #136]	; (8004090 <FLASH_WaitForLastOperation+0xa4>)
 8004006:	68da      	ldr	r2, [r3, #12]
 8004008:	0696      	lsls	r6, r2, #26
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 800400a:	bf44      	itt	mi
 800400c:	2220      	movmi	r2, #32
 800400e:	60da      	strmi	r2, [r3, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8004010:	4b1f      	ldr	r3, [pc, #124]	; (8004090 <FLASH_WaitForLastOperation+0xa4>)
 8004012:	68da      	ldr	r2, [r3, #12]
 8004014:	06d5      	lsls	r5, r2, #27
 8004016:	d407      	bmi.n	8004028 <FLASH_WaitForLastOperation+0x3c>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8004018:	69da      	ldr	r2, [r3, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 800401a:	07d4      	lsls	r4, r2, #31
 800401c:	d404      	bmi.n	8004028 <FLASH_WaitForLastOperation+0x3c>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 800401e:	68d8      	ldr	r0, [r3, #12]
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8004020:	f010 0004 	ands.w	r0, r0, #4
 8004024:	d100      	bne.n	8004028 <FLASH_WaitForLastOperation+0x3c>
}
 8004026:	bd70      	pop	{r4, r5, r6, pc}
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8004028:	4b19      	ldr	r3, [pc, #100]	; (8004090 <FLASH_WaitForLastOperation+0xa4>)
 800402a:	68db      	ldr	r3, [r3, #12]
 800402c:	f013 0310 	ands.w	r3, r3, #16
 8004030:	d126      	bne.n	8004080 <FLASH_WaitForLastOperation+0x94>
 8004032:	2104      	movs	r1, #4
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8004034:	4a16      	ldr	r2, [pc, #88]	; (8004090 <FLASH_WaitForLastOperation+0xa4>)
 8004036:	68d2      	ldr	r2, [r2, #12]
 8004038:	0750      	lsls	r0, r2, #29
 800403a:	d505      	bpl.n	8004048 <FLASH_WaitForLastOperation+0x5c>
    flags |= FLASH_FLAG_PGERR;
 800403c:	460b      	mov	r3, r1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 800403e:	4915      	ldr	r1, [pc, #84]	; (8004094 <FLASH_WaitForLastOperation+0xa8>)
 8004040:	69ca      	ldr	r2, [r1, #28]
 8004042:	f042 0201 	orr.w	r2, r2, #1
 8004046:	61ca      	str	r2, [r1, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8004048:	4a11      	ldr	r2, [pc, #68]	; (8004090 <FLASH_WaitForLastOperation+0xa4>)
 800404a:	69d1      	ldr	r1, [r2, #28]
 800404c:	07c9      	lsls	r1, r1, #31
 800404e:	d508      	bpl.n	8004062 <FLASH_WaitForLastOperation+0x76>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8004050:	4810      	ldr	r0, [pc, #64]	; (8004094 <FLASH_WaitForLastOperation+0xa8>)
 8004052:	69c1      	ldr	r1, [r0, #28]
 8004054:	f041 0104 	orr.w	r1, r1, #4
 8004058:	61c1      	str	r1, [r0, #28]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 800405a:	69d1      	ldr	r1, [r2, #28]
 800405c:	f021 0101 	bic.w	r1, r1, #1
 8004060:	61d1      	str	r1, [r2, #28]
  __HAL_FLASH_CLEAR_FLAG(flags);
 8004062:	4a0b      	ldr	r2, [pc, #44]	; (8004090 <FLASH_WaitForLastOperation+0xa4>)
    return HAL_ERROR;
 8004064:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(flags);
 8004066:	60d3      	str	r3, [r2, #12]
}
 8004068:	bd70      	pop	{r4, r5, r6, pc}
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 800406a:	68f3      	ldr	r3, [r6, #12]
 800406c:	07db      	lsls	r3, r3, #31
 800406e:	d5c9      	bpl.n	8004004 <FLASH_WaitForLastOperation+0x18>
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8004070:	b124      	cbz	r4, 800407c <FLASH_WaitForLastOperation+0x90>
 8004072:	f7ff fdfb 	bl	8003c6c <HAL_GetTick>
 8004076:	1b40      	subs	r0, r0, r5
 8004078:	42a0      	cmp	r0, r4
 800407a:	d9bd      	bls.n	8003ff8 <FLASH_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
 800407c:	2003      	movs	r0, #3
}
 800407e:	bd70      	pop	{r4, r5, r6, pc}
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8004080:	4804      	ldr	r0, [pc, #16]	; (8004094 <FLASH_WaitForLastOperation+0xa8>)
 8004082:	2114      	movs	r1, #20
 8004084:	69c2      	ldr	r2, [r0, #28]
    flags |= FLASH_FLAG_WRPERR;
 8004086:	2310      	movs	r3, #16
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8004088:	f042 0202 	orr.w	r2, r2, #2
 800408c:	61c2      	str	r2, [r0, #28]
    flags |= FLASH_FLAG_WRPERR;
 800408e:	e7d1      	b.n	8004034 <FLASH_WaitForLastOperation+0x48>
 8004090:	40022000 	.word	0x40022000
 8004094:	200005f8 	.word	0x200005f8

08004098 <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFF means that all the pages have been correctly erased)
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
 8004098:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t address = 0U;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 800409c:	4e2d      	ldr	r6, [pc, #180]	; (8004154 <HAL_FLASHEx_Erase+0xbc>)
 800409e:	7e33      	ldrb	r3, [r6, #24]
 80040a0:	2b01      	cmp	r3, #1
 80040a2:	d054      	beq.n	800414e <HAL_FLASHEx_Erase+0xb6>
 80040a4:	2301      	movs	r3, #1
 80040a6:	7633      	strb	r3, [r6, #24]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 80040a8:	6803      	ldr	r3, [r0, #0]
 80040aa:	4681      	mov	r9, r0
 80040ac:	2b02      	cmp	r3, #2
 80040ae:	d031      	beq.n	8004114 <HAL_FLASHEx_Erase+0x7c>
    else
#endif /* FLASH_BANK2_END */
   {
      /* Page Erase requested on address located on bank1 */
      /* Wait for last operation to be completed */
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 80040b0:	f24c 3050 	movw	r0, #50000	; 0xc350
 80040b4:	4688      	mov	r8, r1
 80040b6:	f7ff ff99 	bl	8003fec <FLASH_WaitForLastOperation>
 80040ba:	4607      	mov	r7, r0
 80040bc:	bb78      	cbnz	r0, 800411e <HAL_FLASHEx_Erase+0x86>
      {
        /*Initialization of PageError variable*/
        *PageError = 0xFFFFFFFFU;
 80040be:	f04f 33ff 	mov.w	r3, #4294967295
 80040c2:	f8c8 3000 	str.w	r3, [r8]
        
        /* Erase page by page to be done*/
        for(address = pEraseInit->PageAddress;
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
 80040c6:	e9d9 5302 	ldrd	r5, r3, [r9, #8]
 80040ca:	eb05 2383 	add.w	r3, r5, r3, lsl #10
 80040ce:	429d      	cmp	r5, r3
 80040d0:	d225      	bcs.n	800411e <HAL_FLASHEx_Erase+0x86>
  }
  else
  {
#endif /* FLASH_BANK2_END */
    /* Proceed to erase the page */
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 80040d2:	4c21      	ldr	r4, [pc, #132]	; (8004158 <HAL_FLASHEx_Erase+0xc0>)
 80040d4:	e007      	b.n	80040e6 <HAL_FLASHEx_Erase+0x4e>
            address += FLASH_PAGE_SIZE)
 80040d6:	f505 6580 	add.w	r5, r5, #1024	; 0x400
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
 80040da:	e9d9 3202 	ldrd	r3, r2, [r9, #8]
 80040de:	eb03 2382 	add.w	r3, r3, r2, lsl #10
 80040e2:	42ab      	cmp	r3, r5
 80040e4:	d91c      	bls.n	8004120 <HAL_FLASHEx_Erase+0x88>
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80040e6:	61f7      	str	r7, [r6, #28]
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 80040e8:	6923      	ldr	r3, [r4, #16]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80040ea:	f24c 3050 	movw	r0, #50000	; 0xc350
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 80040ee:	f043 0302 	orr.w	r3, r3, #2
 80040f2:	6123      	str	r3, [r4, #16]
    WRITE_REG(FLASH->AR, PageAddress);
 80040f4:	6165      	str	r5, [r4, #20]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 80040f6:	6923      	ldr	r3, [r4, #16]
 80040f8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80040fc:	6123      	str	r3, [r4, #16]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80040fe:	f7ff ff75 	bl	8003fec <FLASH_WaitForLastOperation>
          CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8004102:	6923      	ldr	r3, [r4, #16]
 8004104:	f023 0302 	bic.w	r3, r3, #2
 8004108:	6123      	str	r3, [r4, #16]
          if (status != HAL_OK)
 800410a:	2800      	cmp	r0, #0
 800410c:	d0e3      	beq.n	80040d6 <HAL_FLASHEx_Erase+0x3e>
            *PageError = address;
 800410e:	f8c8 5000 	str.w	r5, [r8]
            break;
 8004112:	e005      	b.n	8004120 <HAL_FLASHEx_Erase+0x88>
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 8004114:	f24c 3050 	movw	r0, #50000	; 0xc350
 8004118:	f7ff ff68 	bl	8003fec <FLASH_WaitForLastOperation>
 800411c:	b120      	cbz	r0, 8004128 <HAL_FLASHEx_Erase+0x90>
  HAL_StatusTypeDef status = HAL_ERROR;
 800411e:	2001      	movs	r0, #1
  __HAL_UNLOCK(&pFlash);
 8004120:	2300      	movs	r3, #0
 8004122:	7633      	strb	r3, [r6, #24]
}
 8004124:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 8004128:	4c0b      	ldr	r4, [pc, #44]	; (8004158 <HAL_FLASHEx_Erase+0xc0>)
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800412a:	61f0      	str	r0, [r6, #28]
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 800412c:	6923      	ldr	r3, [r4, #16]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800412e:	f24c 3050 	movw	r0, #50000	; 0xc350
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 8004132:	f043 0304 	orr.w	r3, r3, #4
 8004136:	6123      	str	r3, [r4, #16]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 8004138:	6923      	ldr	r3, [r4, #16]
 800413a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800413e:	6123      	str	r3, [r4, #16]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8004140:	f7ff ff54 	bl	8003fec <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
 8004144:	6923      	ldr	r3, [r4, #16]
 8004146:	f023 0304 	bic.w	r3, r3, #4
 800414a:	6123      	str	r3, [r4, #16]
 800414c:	e7e8      	b.n	8004120 <HAL_FLASHEx_Erase+0x88>
  __HAL_LOCK(&pFlash);
 800414e:	2002      	movs	r0, #2
}
 8004150:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004154:	200005f8 	.word	0x200005f8
 8004158:	40022000 	.word	0x40022000

0800415c <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800415c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8004160:	680e      	ldr	r6, [r1, #0]
{
 8004162:	b083      	sub	sp, #12
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8004164:	2e00      	cmp	r6, #0
 8004166:	f000 80b5 	beq.w	80042d4 <HAL_GPIO_Init+0x178>
 800416a:	2200      	movs	r2, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 800416c:	4f7a      	ldr	r7, [pc, #488]	; (8004358 <HAL_GPIO_Init+0x1fc>)
  uint32_t config = 0x00u;
 800416e:	4692      	mov	sl, r2
  uint32_t position = 0x00u;
 8004170:	4613      	mov	r3, r2
        {
          SET_BIT(EXTI->IMR, iocurrent);
        }
        else
        {
          CLEAR_BIT(EXTI->IMR, iocurrent);
 8004172:	4d7a      	ldr	r5, [pc, #488]	; (800435c <HAL_GPIO_Init+0x200>)
      switch (GPIO_Init->Mode)
 8004174:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 8004360 <HAL_GPIO_Init+0x204>
 8004178:	e006      	b.n	8004188 <HAL_GPIO_Init+0x2c>
        }
      }
    }

	position++;
 800417a:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800417c:	fa36 f403 	lsrs.w	r4, r6, r3
 8004180:	f102 0204 	add.w	r2, r2, #4
 8004184:	f000 80a6 	beq.w	80042d4 <HAL_GPIO_Init+0x178>
    ioposition = (0x01uL << position);
 8004188:	2401      	movs	r4, #1
 800418a:	409c      	lsls	r4, r3
    if (iocurrent == ioposition)
 800418c:	ea34 0e06 	bics.w	lr, r4, r6
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8004190:	ea04 0c06 	and.w	ip, r4, r6
    if (iocurrent == ioposition)
 8004194:	d1f1      	bne.n	800417a <HAL_GPIO_Init+0x1e>
      switch (GPIO_Init->Mode)
 8004196:	684e      	ldr	r6, [r1, #4]
 8004198:	2e12      	cmp	r6, #18
 800419a:	f200 809e 	bhi.w	80042da <HAL_GPIO_Init+0x17e>
 800419e:	2e12      	cmp	r6, #18
 80041a0:	d81a      	bhi.n	80041d8 <HAL_GPIO_Init+0x7c>
 80041a2:	e8df f006 	tbb	[pc, r6]
 80041a6:	b9a7      	.short	0xb9a7
 80041a8:	1919ceb5 	.word	0x1919ceb5
 80041ac:	19191919 	.word	0x19191919
 80041b0:	19191919 	.word	0x19191919
 80041b4:	b1191919 	.word	0xb1191919
 80041b8:	bc          	.byte	0xbc
 80041b9:	00          	.byte	0x00
 80041ba:	f8df e1a8 	ldr.w	lr, [pc, #424]	; 8004364 <HAL_GPIO_Init+0x208>
 80041be:	4576      	cmp	r6, lr
 80041c0:	f000 8098 	beq.w	80042f4 <HAL_GPIO_Init+0x198>
 80041c4:	f50e 2e70 	add.w	lr, lr, #983040	; 0xf0000
 80041c8:	4576      	cmp	r6, lr
 80041ca:	f000 8093 	beq.w	80042f4 <HAL_GPIO_Init+0x198>
 80041ce:	f5ae 1e80 	sub.w	lr, lr, #1048576	; 0x100000
 80041d2:	4576      	cmp	r6, lr
 80041d4:	f000 808e 	beq.w	80042f4 <HAL_GPIO_Init+0x198>
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80041d8:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 80041dc:	bf9c      	itt	ls
 80041de:	4686      	movls	lr, r0
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 80041e0:	4693      	movls	fp, r2
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 80041e2:	f04f 060f 	mov.w	r6, #15
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80041e6:	bf84      	itt	hi
 80041e8:	f100 0e04 	addhi.w	lr, r0, #4
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 80041ec:	f1a2 0b20 	subhi.w	fp, r2, #32
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 80041f0:	f8de 4000 	ldr.w	r4, [lr]
 80041f4:	fa0a f90b 	lsl.w	r9, sl, fp
 80041f8:	fa06 fb0b 	lsl.w	fp, r6, fp
 80041fc:	ea24 040b 	bic.w	r4, r4, fp
 8004200:	ea44 0409 	orr.w	r4, r4, r9
 8004204:	f8ce 4000 	str.w	r4, [lr]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8004208:	684c      	ldr	r4, [r1, #4]
 800420a:	f014 5f80 	tst.w	r4, #268435456	; 0x10000000
 800420e:	d079      	beq.n	8004304 <HAL_GPIO_Init+0x1a8>
        __HAL_RCC_AFIO_CLK_ENABLE();
 8004210:	f8d7 e018 	ldr.w	lr, [r7, #24]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8004214:	f003 0903 	and.w	r9, r3, #3
        __HAL_RCC_AFIO_CLK_ENABLE();
 8004218:	f04e 0e01 	orr.w	lr, lr, #1
 800421c:	f8c7 e018 	str.w	lr, [r7, #24]
 8004220:	f8d7 e018 	ldr.w	lr, [r7, #24]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8004224:	ea4f 0989 	mov.w	r9, r9, lsl #2
        __HAL_RCC_AFIO_CLK_ENABLE();
 8004228:	f00e 0e01 	and.w	lr, lr, #1
 800422c:	f8cd e004 	str.w	lr, [sp, #4]
 8004230:	f8dd e004 	ldr.w	lr, [sp, #4]
        temp = AFIO->EXTICR[position >> 2u];
 8004234:	f023 0e03 	bic.w	lr, r3, #3
 8004238:	f10e 4e80 	add.w	lr, lr, #1073741824	; 0x40000000
 800423c:	f50e 3e80 	add.w	lr, lr, #65536	; 0x10000
 8004240:	f8de b008 	ldr.w	fp, [lr, #8]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8004244:	fa06 f609 	lsl.w	r6, r6, r9
 8004248:	ea2b 0606 	bic.w	r6, fp, r6
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 800424c:	f8df b118 	ldr.w	fp, [pc, #280]	; 8004368 <HAL_GPIO_Init+0x20c>
 8004250:	4558      	cmp	r0, fp
 8004252:	d013      	beq.n	800427c <HAL_GPIO_Init+0x120>
 8004254:	f50b 6b80 	add.w	fp, fp, #1024	; 0x400
 8004258:	4558      	cmp	r0, fp
 800425a:	d06b      	beq.n	8004334 <HAL_GPIO_Init+0x1d8>
 800425c:	f8df b10c 	ldr.w	fp, [pc, #268]	; 800436c <HAL_GPIO_Init+0x210>
 8004260:	4558      	cmp	r0, fp
 8004262:	d060      	beq.n	8004326 <HAL_GPIO_Init+0x1ca>
 8004264:	f8df b108 	ldr.w	fp, [pc, #264]	; 8004370 <HAL_GPIO_Init+0x214>
 8004268:	4558      	cmp	r0, fp
 800426a:	bf0c      	ite	eq
 800426c:	f04f 0b03 	moveq.w	fp, #3
 8004270:	f04f 0b04 	movne.w	fp, #4
 8004274:	fa0b f909 	lsl.w	r9, fp, r9
 8004278:	ea46 0609 	orr.w	r6, r6, r9
        AFIO->EXTICR[position >> 2u] = temp;
 800427c:	f8ce 6008 	str.w	r6, [lr, #8]
          SET_BIT(EXTI->RTSR, iocurrent);
 8004280:	68ae      	ldr	r6, [r5, #8]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8004282:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
          SET_BIT(EXTI->RTSR, iocurrent);
 8004286:	bf14      	ite	ne
 8004288:	ea46 060c 	orrne.w	r6, r6, ip
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 800428c:	ea26 060c 	biceq.w	r6, r6, ip
 8004290:	60ae      	str	r6, [r5, #8]
          SET_BIT(EXTI->FTSR, iocurrent);
 8004292:	68ee      	ldr	r6, [r5, #12]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8004294:	f414 1f00 	tst.w	r4, #2097152	; 0x200000
          SET_BIT(EXTI->FTSR, iocurrent);
 8004298:	bf14      	ite	ne
 800429a:	ea46 060c 	orrne.w	r6, r6, ip
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 800429e:	ea26 060c 	biceq.w	r6, r6, ip
 80042a2:	60ee      	str	r6, [r5, #12]
          SET_BIT(EXTI->EMR, iocurrent);
 80042a4:	686e      	ldr	r6, [r5, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80042a6:	f414 3f00 	tst.w	r4, #131072	; 0x20000
          SET_BIT(EXTI->EMR, iocurrent);
 80042aa:	bf14      	ite	ne
 80042ac:	ea46 060c 	orrne.w	r6, r6, ip
          CLEAR_BIT(EXTI->EMR, iocurrent);
 80042b0:	ea26 060c 	biceq.w	r6, r6, ip
 80042b4:	606e      	str	r6, [r5, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80042b6:	f414 3f80 	tst.w	r4, #65536	; 0x10000
          SET_BIT(EXTI->IMR, iocurrent);
 80042ba:	682c      	ldr	r4, [r5, #0]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80042bc:	d01f      	beq.n	80042fe <HAL_GPIO_Init+0x1a2>
          SET_BIT(EXTI->IMR, iocurrent);
 80042be:	ea44 040c 	orr.w	r4, r4, ip
 80042c2:	602c      	str	r4, [r5, #0]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80042c4:	680e      	ldr	r6, [r1, #0]
	position++;
 80042c6:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80042c8:	fa36 f403 	lsrs.w	r4, r6, r3
 80042cc:	f102 0204 	add.w	r2, r2, #4
 80042d0:	f47f af5a 	bne.w	8004188 <HAL_GPIO_Init+0x2c>
  }
}
 80042d4:	b003      	add	sp, #12
 80042d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      switch (GPIO_Init->Mode)
 80042da:	4546      	cmp	r6, r8
 80042dc:	d00a      	beq.n	80042f4 <HAL_GPIO_Init+0x198>
 80042de:	f67f af6c 	bls.w	80041ba <HAL_GPIO_Init+0x5e>
 80042e2:	f8df e090 	ldr.w	lr, [pc, #144]	; 8004374 <HAL_GPIO_Init+0x218>
 80042e6:	4576      	cmp	r6, lr
 80042e8:	d004      	beq.n	80042f4 <HAL_GPIO_Init+0x198>
 80042ea:	f50e 3e80 	add.w	lr, lr, #65536	; 0x10000
 80042ee:	4576      	cmp	r6, lr
 80042f0:	f47f af72 	bne.w	80041d8 <HAL_GPIO_Init+0x7c>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 80042f4:	688e      	ldr	r6, [r1, #8]
 80042f6:	bb3e      	cbnz	r6, 8004348 <HAL_GPIO_Init+0x1ec>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 80042f8:	f04f 0a04 	mov.w	sl, #4
 80042fc:	e76c      	b.n	80041d8 <HAL_GPIO_Init+0x7c>
          CLEAR_BIT(EXTI->IMR, iocurrent);
 80042fe:	ea24 040c 	bic.w	r4, r4, ip
 8004302:	602c      	str	r4, [r5, #0]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8004304:	680e      	ldr	r6, [r1, #0]
 8004306:	e738      	b.n	800417a <HAL_GPIO_Init+0x1e>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 8004308:	68cc      	ldr	r4, [r1, #12]
 800430a:	f104 0a04 	add.w	sl, r4, #4
          break;
 800430e:	e763      	b.n	80041d8 <HAL_GPIO_Init+0x7c>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 8004310:	68cc      	ldr	r4, [r1, #12]
 8004312:	f104 0a08 	add.w	sl, r4, #8
          break;
 8004316:	e75f      	b.n	80041d8 <HAL_GPIO_Init+0x7c>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 8004318:	f8d1 a00c 	ldr.w	sl, [r1, #12]
          break;
 800431c:	e75c      	b.n	80041d8 <HAL_GPIO_Init+0x7c>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 800431e:	68cc      	ldr	r4, [r1, #12]
 8004320:	f104 0a0c 	add.w	sl, r4, #12
          break;
 8004324:	e758      	b.n	80041d8 <HAL_GPIO_Init+0x7c>
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8004326:	f04f 0b02 	mov.w	fp, #2
 800432a:	fa0b f909 	lsl.w	r9, fp, r9
 800432e:	ea46 0609 	orr.w	r6, r6, r9
 8004332:	e7a3      	b.n	800427c <HAL_GPIO_Init+0x120>
 8004334:	f04f 0b01 	mov.w	fp, #1
 8004338:	fa0b f909 	lsl.w	r9, fp, r9
 800433c:	ea46 0609 	orr.w	r6, r6, r9
 8004340:	e79c      	b.n	800427c <HAL_GPIO_Init+0x120>
      switch (GPIO_Init->Mode)
 8004342:	f04f 0a00 	mov.w	sl, #0
 8004346:	e747      	b.n	80041d8 <HAL_GPIO_Init+0x7c>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8004348:	2e01      	cmp	r6, #1
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 800434a:	f04f 0a08 	mov.w	sl, #8
            GPIOx->BSRR = ioposition;
 800434e:	bf0c      	ite	eq
 8004350:	6104      	streq	r4, [r0, #16]
            GPIOx->BRR = ioposition;
 8004352:	6144      	strne	r4, [r0, #20]
 8004354:	e740      	b.n	80041d8 <HAL_GPIO_Init+0x7c>
 8004356:	bf00      	nop
 8004358:	40021000 	.word	0x40021000
 800435c:	40010400 	.word	0x40010400
 8004360:	10220000 	.word	0x10220000
 8004364:	10120000 	.word	0x10120000
 8004368:	40010800 	.word	0x40010800
 800436c:	40011000 	.word	0x40011000
 8004370:	40011400 	.word	0x40011400
 8004374:	10310000 	.word	0x10310000

08004378 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8004378:	6883      	ldr	r3, [r0, #8]
 800437a:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 800437c:	bf14      	ite	ne
 800437e:	2001      	movne	r0, #1
 8004380:	2000      	moveq	r0, #0
 8004382:	4770      	bx	lr

08004384 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8004384:	b902      	cbnz	r2, 8004388 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
 8004386:	0409      	lsls	r1, r1, #16
 8004388:	6101      	str	r1, [r0, #16]
  }
}
 800438a:	4770      	bx	lr

0800438c <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  uint32_t pll_config;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800438c:	2800      	cmp	r0, #0
 800438e:	f000 81b6 	beq.w	80046fe <HAL_RCC_OscConfig+0x372>
{
 8004392:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8004396:	6803      	ldr	r3, [r0, #0]
 8004398:	4604      	mov	r4, r0
 800439a:	07dd      	lsls	r5, r3, #31
{
 800439c:	b082      	sub	sp, #8
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800439e:	d535      	bpl.n	800440c <HAL_RCC_OscConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 80043a0:	499a      	ldr	r1, [pc, #616]	; (800460c <HAL_RCC_OscConfig+0x280>)
 80043a2:	684a      	ldr	r2, [r1, #4]
 80043a4:	f002 020c 	and.w	r2, r2, #12
 80043a8:	2a04      	cmp	r2, #4
 80043aa:	f000 80ef 	beq.w	800458c <HAL_RCC_OscConfig+0x200>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80043ae:	684a      	ldr	r2, [r1, #4]
 80043b0:	f002 020c 	and.w	r2, r2, #12
 80043b4:	2a08      	cmp	r2, #8
 80043b6:	f000 80e5 	beq.w	8004584 <HAL_RCC_OscConfig+0x1f8>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80043ba:	6863      	ldr	r3, [r4, #4]
 80043bc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80043c0:	d010      	beq.n	80043e4 <HAL_RCC_OscConfig+0x58>
 80043c2:	2b00      	cmp	r3, #0
 80043c4:	f000 810c 	beq.w	80045e0 <HAL_RCC_OscConfig+0x254>
 80043c8:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80043cc:	f000 8182 	beq.w	80046d4 <HAL_RCC_OscConfig+0x348>
 80043d0:	4b8e      	ldr	r3, [pc, #568]	; (800460c <HAL_RCC_OscConfig+0x280>)
 80043d2:	681a      	ldr	r2, [r3, #0]
 80043d4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80043d8:	601a      	str	r2, [r3, #0]
 80043da:	681a      	ldr	r2, [r3, #0]
 80043dc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80043e0:	601a      	str	r2, [r3, #0]
 80043e2:	e004      	b.n	80043ee <HAL_RCC_OscConfig+0x62>
 80043e4:	4a89      	ldr	r2, [pc, #548]	; (800460c <HAL_RCC_OscConfig+0x280>)
 80043e6:	6813      	ldr	r3, [r2, #0]
 80043e8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80043ec:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80043ee:	f7ff fc3d 	bl	8003c6c <HAL_GetTick>

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80043f2:	4e86      	ldr	r6, [pc, #536]	; (800460c <HAL_RCC_OscConfig+0x280>)
        tickstart = HAL_GetTick();
 80043f4:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80043f6:	e005      	b.n	8004404 <HAL_RCC_OscConfig+0x78>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80043f8:	f7ff fc38 	bl	8003c6c <HAL_GetTick>
 80043fc:	1b40      	subs	r0, r0, r5
 80043fe:	2864      	cmp	r0, #100	; 0x64
 8004400:	f200 80ea 	bhi.w	80045d8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004404:	6833      	ldr	r3, [r6, #0]
 8004406:	039a      	lsls	r2, r3, #14
 8004408:	d5f6      	bpl.n	80043f8 <HAL_RCC_OscConfig+0x6c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800440a:	6823      	ldr	r3, [r4, #0]
 800440c:	079f      	lsls	r7, r3, #30
 800440e:	d528      	bpl.n	8004462 <HAL_RCC_OscConfig+0xd6>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8004410:	4a7e      	ldr	r2, [pc, #504]	; (800460c <HAL_RCC_OscConfig+0x280>)
 8004412:	6851      	ldr	r1, [r2, #4]
 8004414:	f011 0f0c 	tst.w	r1, #12
 8004418:	f000 808d 	beq.w	8004536 <HAL_RCC_OscConfig+0x1aa>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 800441c:	6851      	ldr	r1, [r2, #4]
 800441e:	f001 010c 	and.w	r1, r1, #12
 8004422:	2908      	cmp	r1, #8
 8004424:	f000 8083 	beq.w	800452e <HAL_RCC_OscConfig+0x1a2>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8004428:	6923      	ldr	r3, [r4, #16]
 800442a:	2b00      	cmp	r3, #0
 800442c:	f000 8118 	beq.w	8004660 <HAL_RCC_OscConfig+0x2d4>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8004430:	2201      	movs	r2, #1
 8004432:	4b77      	ldr	r3, [pc, #476]	; (8004610 <HAL_RCC_OscConfig+0x284>)

        /* Get Start Tick */
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004434:	4e75      	ldr	r6, [pc, #468]	; (800460c <HAL_RCC_OscConfig+0x280>)
        __HAL_RCC_HSI_ENABLE();
 8004436:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8004438:	f7ff fc18 	bl	8003c6c <HAL_GetTick>
 800443c:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800443e:	e005      	b.n	800444c <HAL_RCC_OscConfig+0xc0>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004440:	f7ff fc14 	bl	8003c6c <HAL_GetTick>
 8004444:	1b40      	subs	r0, r0, r5
 8004446:	2802      	cmp	r0, #2
 8004448:	f200 80c6 	bhi.w	80045d8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800444c:	6833      	ldr	r3, [r6, #0]
 800444e:	0798      	lsls	r0, r3, #30
 8004450:	d5f6      	bpl.n	8004440 <HAL_RCC_OscConfig+0xb4>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004452:	6833      	ldr	r3, [r6, #0]
 8004454:	6962      	ldr	r2, [r4, #20]
 8004456:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800445a:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800445e:	6033      	str	r3, [r6, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004460:	6823      	ldr	r3, [r4, #0]
 8004462:	071a      	lsls	r2, r3, #28
 8004464:	d41f      	bmi.n	80044a6 <HAL_RCC_OscConfig+0x11a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8004466:	075d      	lsls	r5, r3, #29
 8004468:	d542      	bpl.n	80044f0 <HAL_RCC_OscConfig+0x164>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 800446a:	4b68      	ldr	r3, [pc, #416]	; (800460c <HAL_RCC_OscConfig+0x280>)
 800446c:	69da      	ldr	r2, [r3, #28]
 800446e:	00d0      	lsls	r0, r2, #3
 8004470:	d57d      	bpl.n	800456e <HAL_RCC_OscConfig+0x1e2>
    FlagStatus       pwrclkchanged = RESET;
 8004472:	2500      	movs	r5, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8004474:	4e67      	ldr	r6, [pc, #412]	; (8004614 <HAL_RCC_OscConfig+0x288>)
 8004476:	6833      	ldr	r3, [r6, #0]
 8004478:	05d9      	lsls	r1, r3, #23
 800447a:	f140 809d 	bpl.w	80045b8 <HAL_RCC_OscConfig+0x22c>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800447e:	68e3      	ldr	r3, [r4, #12]
 8004480:	2b01      	cmp	r3, #1
 8004482:	f000 80fe 	beq.w	8004682 <HAL_RCC_OscConfig+0x2f6>
 8004486:	2b00      	cmp	r3, #0
 8004488:	f000 80ca 	beq.w	8004620 <HAL_RCC_OscConfig+0x294>
 800448c:	2b05      	cmp	r3, #5
 800448e:	4b5f      	ldr	r3, [pc, #380]	; (800460c <HAL_RCC_OscConfig+0x280>)
 8004490:	6a1a      	ldr	r2, [r3, #32]
 8004492:	f000 812c 	beq.w	80046ee <HAL_RCC_OscConfig+0x362>
 8004496:	f022 0201 	bic.w	r2, r2, #1
 800449a:	621a      	str	r2, [r3, #32]
 800449c:	6a1a      	ldr	r2, [r3, #32]
 800449e:	f022 0204 	bic.w	r2, r2, #4
 80044a2:	621a      	str	r2, [r3, #32]
 80044a4:	e0f2      	b.n	800468c <HAL_RCC_OscConfig+0x300>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80044a6:	69a3      	ldr	r3, [r4, #24]
 80044a8:	2b00      	cmp	r3, #0
 80044aa:	d04f      	beq.n	800454c <HAL_RCC_OscConfig+0x1c0>
      __HAL_RCC_LSI_ENABLE();
 80044ac:	2201      	movs	r2, #1
 80044ae:	4b58      	ldr	r3, [pc, #352]	; (8004610 <HAL_RCC_OscConfig+0x284>)
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80044b0:	4e56      	ldr	r6, [pc, #344]	; (800460c <HAL_RCC_OscConfig+0x280>)
      __HAL_RCC_LSI_ENABLE();
 80044b2:	f8c3 2480 	str.w	r2, [r3, #1152]	; 0x480
      tickstart = HAL_GetTick();
 80044b6:	f7ff fbd9 	bl	8003c6c <HAL_GetTick>
 80044ba:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80044bc:	e005      	b.n	80044ca <HAL_RCC_OscConfig+0x13e>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80044be:	f7ff fbd5 	bl	8003c6c <HAL_GetTick>
 80044c2:	1b40      	subs	r0, r0, r5
 80044c4:	2802      	cmp	r0, #2
 80044c6:	f200 8087 	bhi.w	80045d8 <HAL_RCC_OscConfig+0x24c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80044ca:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80044cc:	079b      	lsls	r3, r3, #30
 80044ce:	d5f6      	bpl.n	80044be <HAL_RCC_OscConfig+0x132>
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 80044d0:	4b51      	ldr	r3, [pc, #324]	; (8004618 <HAL_RCC_OscConfig+0x28c>)
 80044d2:	4a52      	ldr	r2, [pc, #328]	; (800461c <HAL_RCC_OscConfig+0x290>)
 80044d4:	681b      	ldr	r3, [r3, #0]
 80044d6:	fba2 2303 	umull	r2, r3, r2, r3
 80044da:	0a5b      	lsrs	r3, r3, #9
 80044dc:	9301      	str	r3, [sp, #4]
  do
  {
    __NOP();
 80044de:	bf00      	nop
  }
  while (Delay --);
 80044e0:	9b01      	ldr	r3, [sp, #4]
 80044e2:	1e5a      	subs	r2, r3, #1
 80044e4:	9201      	str	r2, [sp, #4]
 80044e6:	2b00      	cmp	r3, #0
 80044e8:	d1f9      	bne.n	80044de <HAL_RCC_OscConfig+0x152>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80044ea:	6823      	ldr	r3, [r4, #0]
 80044ec:	075d      	lsls	r5, r3, #29
 80044ee:	d4bc      	bmi.n	800446a <HAL_RCC_OscConfig+0xde>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80044f0:	69e0      	ldr	r0, [r4, #28]
 80044f2:	b1c0      	cbz	r0, 8004526 <HAL_RCC_OscConfig+0x19a>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80044f4:	4d45      	ldr	r5, [pc, #276]	; (800460c <HAL_RCC_OscConfig+0x280>)
 80044f6:	686b      	ldr	r3, [r5, #4]
 80044f8:	f003 030c 	and.w	r3, r3, #12
 80044fc:	2b08      	cmp	r3, #8
 80044fe:	f000 80d8 	beq.w	80046b2 <HAL_RCC_OscConfig+0x326>
        __HAL_RCC_PLL_DISABLE();
 8004502:	2200      	movs	r2, #0
 8004504:	4b42      	ldr	r3, [pc, #264]	; (8004610 <HAL_RCC_OscConfig+0x284>)
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8004506:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 8004508:	661a      	str	r2, [r3, #96]	; 0x60
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800450a:	f000 80fa 	beq.w	8004702 <HAL_RCC_OscConfig+0x376>
        tickstart = HAL_GetTick();
 800450e:	f7ff fbad 	bl	8003c6c <HAL_GetTick>
 8004512:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8004514:	e004      	b.n	8004520 <HAL_RCC_OscConfig+0x194>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004516:	f7ff fba9 	bl	8003c6c <HAL_GetTick>
 800451a:	1b00      	subs	r0, r0, r4
 800451c:	2802      	cmp	r0, #2
 800451e:	d85b      	bhi.n	80045d8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8004520:	682b      	ldr	r3, [r5, #0]
 8004522:	019b      	lsls	r3, r3, #6
 8004524:	d4f7      	bmi.n	8004516 <HAL_RCC_OscConfig+0x18a>
  return HAL_OK;
 8004526:	2000      	movs	r0, #0
}
 8004528:	b002      	add	sp, #8
 800452a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 800452e:	6852      	ldr	r2, [r2, #4]
 8004530:	03d6      	lsls	r6, r2, #15
 8004532:	f53f af79 	bmi.w	8004428 <HAL_RCC_OscConfig+0x9c>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8004536:	4a35      	ldr	r2, [pc, #212]	; (800460c <HAL_RCC_OscConfig+0x280>)
 8004538:	6812      	ldr	r2, [r2, #0]
 800453a:	0795      	lsls	r5, r2, #30
 800453c:	d530      	bpl.n	80045a0 <HAL_RCC_OscConfig+0x214>
 800453e:	6922      	ldr	r2, [r4, #16]
 8004540:	2a01      	cmp	r2, #1
 8004542:	d02d      	beq.n	80045a0 <HAL_RCC_OscConfig+0x214>
        return HAL_ERROR;
 8004544:	2001      	movs	r0, #1
}
 8004546:	b002      	add	sp, #8
 8004548:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 800454c:	4a30      	ldr	r2, [pc, #192]	; (8004610 <HAL_RCC_OscConfig+0x284>)
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800454e:	4e2f      	ldr	r6, [pc, #188]	; (800460c <HAL_RCC_OscConfig+0x280>)
      __HAL_RCC_LSI_DISABLE();
 8004550:	f8c2 3480 	str.w	r3, [r2, #1152]	; 0x480
      tickstart = HAL_GetTick();
 8004554:	f7ff fb8a 	bl	8003c6c <HAL_GetTick>
 8004558:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800455a:	e004      	b.n	8004566 <HAL_RCC_OscConfig+0x1da>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800455c:	f7ff fb86 	bl	8003c6c <HAL_GetTick>
 8004560:	1b40      	subs	r0, r0, r5
 8004562:	2802      	cmp	r0, #2
 8004564:	d838      	bhi.n	80045d8 <HAL_RCC_OscConfig+0x24c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8004566:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8004568:	079f      	lsls	r7, r3, #30
 800456a:	d4f7      	bmi.n	800455c <HAL_RCC_OscConfig+0x1d0>
 800456c:	e7bd      	b.n	80044ea <HAL_RCC_OscConfig+0x15e>
      __HAL_RCC_PWR_CLK_ENABLE();
 800456e:	69da      	ldr	r2, [r3, #28]
      pwrclkchanged = SET;
 8004570:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 8004572:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8004576:	61da      	str	r2, [r3, #28]
 8004578:	69db      	ldr	r3, [r3, #28]
 800457a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800457e:	9300      	str	r3, [sp, #0]
 8004580:	9b00      	ldr	r3, [sp, #0]
      pwrclkchanged = SET;
 8004582:	e777      	b.n	8004474 <HAL_RCC_OscConfig+0xe8>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8004584:	684a      	ldr	r2, [r1, #4]
 8004586:	03d0      	lsls	r0, r2, #15
 8004588:	f57f af17 	bpl.w	80043ba <HAL_RCC_OscConfig+0x2e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800458c:	4a1f      	ldr	r2, [pc, #124]	; (800460c <HAL_RCC_OscConfig+0x280>)
 800458e:	6812      	ldr	r2, [r2, #0]
 8004590:	0391      	lsls	r1, r2, #14
 8004592:	f57f af3b 	bpl.w	800440c <HAL_RCC_OscConfig+0x80>
 8004596:	6862      	ldr	r2, [r4, #4]
 8004598:	2a00      	cmp	r2, #0
 800459a:	f47f af37 	bne.w	800440c <HAL_RCC_OscConfig+0x80>
 800459e:	e7d1      	b.n	8004544 <HAL_RCC_OscConfig+0x1b8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80045a0:	491a      	ldr	r1, [pc, #104]	; (800460c <HAL_RCC_OscConfig+0x280>)
 80045a2:	6960      	ldr	r0, [r4, #20]
 80045a4:	680a      	ldr	r2, [r1, #0]
 80045a6:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 80045aa:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 80045ae:	600a      	str	r2, [r1, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80045b0:	071a      	lsls	r2, r3, #28
 80045b2:	f57f af58 	bpl.w	8004466 <HAL_RCC_OscConfig+0xda>
 80045b6:	e776      	b.n	80044a6 <HAL_RCC_OscConfig+0x11a>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80045b8:	6833      	ldr	r3, [r6, #0]
 80045ba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80045be:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 80045c0:	f7ff fb54 	bl	8003c6c <HAL_GetTick>
 80045c4:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80045c6:	6833      	ldr	r3, [r6, #0]
 80045c8:	05da      	lsls	r2, r3, #23
 80045ca:	f53f af58 	bmi.w	800447e <HAL_RCC_OscConfig+0xf2>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80045ce:	f7ff fb4d 	bl	8003c6c <HAL_GetTick>
 80045d2:	1bc0      	subs	r0, r0, r7
 80045d4:	2864      	cmp	r0, #100	; 0x64
 80045d6:	d9f6      	bls.n	80045c6 <HAL_RCC_OscConfig+0x23a>
            return HAL_TIMEOUT;
 80045d8:	2003      	movs	r0, #3
}
 80045da:	b002      	add	sp, #8
 80045dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80045e0:	4d0a      	ldr	r5, [pc, #40]	; (800460c <HAL_RCC_OscConfig+0x280>)
 80045e2:	682b      	ldr	r3, [r5, #0]
 80045e4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80045e8:	602b      	str	r3, [r5, #0]
 80045ea:	682b      	ldr	r3, [r5, #0]
 80045ec:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80045f0:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80045f2:	f7ff fb3b 	bl	8003c6c <HAL_GetTick>
 80045f6:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80045f8:	e004      	b.n	8004604 <HAL_RCC_OscConfig+0x278>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80045fa:	f7ff fb37 	bl	8003c6c <HAL_GetTick>
 80045fe:	1b80      	subs	r0, r0, r6
 8004600:	2864      	cmp	r0, #100	; 0x64
 8004602:	d8e9      	bhi.n	80045d8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8004604:	682b      	ldr	r3, [r5, #0]
 8004606:	039b      	lsls	r3, r3, #14
 8004608:	d4f7      	bmi.n	80045fa <HAL_RCC_OscConfig+0x26e>
 800460a:	e6fe      	b.n	800440a <HAL_RCC_OscConfig+0x7e>
 800460c:	40021000 	.word	0x40021000
 8004610:	42420000 	.word	0x42420000
 8004614:	40007000 	.word	0x40007000
 8004618:	20000008 	.word	0x20000008
 800461c:	10624dd3 	.word	0x10624dd3
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8004620:	4e50      	ldr	r6, [pc, #320]	; (8004764 <HAL_RCC_OscConfig+0x3d8>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004622:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8004626:	6a33      	ldr	r3, [r6, #32]
 8004628:	f023 0301 	bic.w	r3, r3, #1
 800462c:	6233      	str	r3, [r6, #32]
 800462e:	6a33      	ldr	r3, [r6, #32]
 8004630:	f023 0304 	bic.w	r3, r3, #4
 8004634:	6233      	str	r3, [r6, #32]
      tickstart = HAL_GetTick();
 8004636:	f7ff fb19 	bl	8003c6c <HAL_GetTick>
 800463a:	4607      	mov	r7, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800463c:	e004      	b.n	8004648 <HAL_RCC_OscConfig+0x2bc>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800463e:	f7ff fb15 	bl	8003c6c <HAL_GetTick>
 8004642:	1bc0      	subs	r0, r0, r7
 8004644:	4540      	cmp	r0, r8
 8004646:	d8c7      	bhi.n	80045d8 <HAL_RCC_OscConfig+0x24c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8004648:	6a33      	ldr	r3, [r6, #32]
 800464a:	0798      	lsls	r0, r3, #30
 800464c:	d4f7      	bmi.n	800463e <HAL_RCC_OscConfig+0x2b2>
    if (pwrclkchanged == SET)
 800464e:	2d00      	cmp	r5, #0
 8004650:	f43f af4e 	beq.w	80044f0 <HAL_RCC_OscConfig+0x164>
      __HAL_RCC_PWR_CLK_DISABLE();
 8004654:	4a43      	ldr	r2, [pc, #268]	; (8004764 <HAL_RCC_OscConfig+0x3d8>)
 8004656:	69d3      	ldr	r3, [r2, #28]
 8004658:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800465c:	61d3      	str	r3, [r2, #28]
 800465e:	e747      	b.n	80044f0 <HAL_RCC_OscConfig+0x164>
        __HAL_RCC_HSI_DISABLE();
 8004660:	4a41      	ldr	r2, [pc, #260]	; (8004768 <HAL_RCC_OscConfig+0x3dc>)
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8004662:	4e40      	ldr	r6, [pc, #256]	; (8004764 <HAL_RCC_OscConfig+0x3d8>)
        __HAL_RCC_HSI_DISABLE();
 8004664:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8004666:	f7ff fb01 	bl	8003c6c <HAL_GetTick>
 800466a:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800466c:	e004      	b.n	8004678 <HAL_RCC_OscConfig+0x2ec>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800466e:	f7ff fafd 	bl	8003c6c <HAL_GetTick>
 8004672:	1b40      	subs	r0, r0, r5
 8004674:	2802      	cmp	r0, #2
 8004676:	d8af      	bhi.n	80045d8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8004678:	6833      	ldr	r3, [r6, #0]
 800467a:	0799      	lsls	r1, r3, #30
 800467c:	d4f7      	bmi.n	800466e <HAL_RCC_OscConfig+0x2e2>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800467e:	6823      	ldr	r3, [r4, #0]
 8004680:	e6ef      	b.n	8004462 <HAL_RCC_OscConfig+0xd6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8004682:	4a38      	ldr	r2, [pc, #224]	; (8004764 <HAL_RCC_OscConfig+0x3d8>)
 8004684:	6a13      	ldr	r3, [r2, #32]
 8004686:	f043 0301 	orr.w	r3, r3, #1
 800468a:	6213      	str	r3, [r2, #32]
      tickstart = HAL_GetTick();
 800468c:	f7ff faee 	bl	8003c6c <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004690:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8004694:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004696:	4f33      	ldr	r7, [pc, #204]	; (8004764 <HAL_RCC_OscConfig+0x3d8>)
 8004698:	e004      	b.n	80046a4 <HAL_RCC_OscConfig+0x318>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800469a:	f7ff fae7 	bl	8003c6c <HAL_GetTick>
 800469e:	1b80      	subs	r0, r0, r6
 80046a0:	4540      	cmp	r0, r8
 80046a2:	d899      	bhi.n	80045d8 <HAL_RCC_OscConfig+0x24c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80046a4:	6a3b      	ldr	r3, [r7, #32]
 80046a6:	079b      	lsls	r3, r3, #30
 80046a8:	d5f7      	bpl.n	800469a <HAL_RCC_OscConfig+0x30e>
    if (pwrclkchanged == SET)
 80046aa:	2d00      	cmp	r5, #0
 80046ac:	f43f af20 	beq.w	80044f0 <HAL_RCC_OscConfig+0x164>
 80046b0:	e7d0      	b.n	8004654 <HAL_RCC_OscConfig+0x2c8>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80046b2:	2801      	cmp	r0, #1
 80046b4:	f43f af38 	beq.w	8004528 <HAL_RCC_OscConfig+0x19c>
        pll_config = RCC->CFGR;
 80046b8:	686b      	ldr	r3, [r5, #4]
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80046ba:	6a22      	ldr	r2, [r4, #32]
 80046bc:	f403 3180 	and.w	r1, r3, #65536	; 0x10000
 80046c0:	4291      	cmp	r1, r2
 80046c2:	f47f af3f 	bne.w	8004544 <HAL_RCC_OscConfig+0x1b8>
 80046c6:	6a60      	ldr	r0, [r4, #36]	; 0x24
            (READ_BIT(pll_config, RCC_CFGR_PLLMULL) != RCC_OscInitStruct->PLL.PLLMUL))
 80046c8:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
    return HAL_ERROR;
 80046cc:	1a18      	subs	r0, r3, r0
 80046ce:	bf18      	it	ne
 80046d0:	2001      	movne	r0, #1
 80046d2:	e729      	b.n	8004528 <HAL_RCC_OscConfig+0x19c>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80046d4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80046d8:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 80046dc:	681a      	ldr	r2, [r3, #0]
 80046de:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80046e2:	601a      	str	r2, [r3, #0]
 80046e4:	681a      	ldr	r2, [r3, #0]
 80046e6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80046ea:	601a      	str	r2, [r3, #0]
 80046ec:	e67f      	b.n	80043ee <HAL_RCC_OscConfig+0x62>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80046ee:	f042 0204 	orr.w	r2, r2, #4
 80046f2:	621a      	str	r2, [r3, #32]
 80046f4:	6a1a      	ldr	r2, [r3, #32]
 80046f6:	f042 0201 	orr.w	r2, r2, #1
 80046fa:	621a      	str	r2, [r3, #32]
 80046fc:	e7c6      	b.n	800468c <HAL_RCC_OscConfig+0x300>
    return HAL_ERROR;
 80046fe:	2001      	movs	r0, #1
}
 8004700:	4770      	bx	lr
        tickstart = HAL_GetTick();
 8004702:	f7ff fab3 	bl	8003c6c <HAL_GetTick>
 8004706:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8004708:	e005      	b.n	8004716 <HAL_RCC_OscConfig+0x38a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800470a:	f7ff faaf 	bl	8003c6c <HAL_GetTick>
 800470e:	1b80      	subs	r0, r0, r6
 8004710:	2802      	cmp	r0, #2
 8004712:	f63f af61 	bhi.w	80045d8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8004716:	682b      	ldr	r3, [r5, #0]
 8004718:	0199      	lsls	r1, r3, #6
 800471a:	d4f6      	bmi.n	800470a <HAL_RCC_OscConfig+0x37e>
        if (RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 800471c:	6a23      	ldr	r3, [r4, #32]
 800471e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8004722:	d105      	bne.n	8004730 <HAL_RCC_OscConfig+0x3a4>
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 8004724:	686a      	ldr	r2, [r5, #4]
 8004726:	68a1      	ldr	r1, [r4, #8]
 8004728:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800472c:	430a      	orrs	r2, r1
 800472e:	606a      	str	r2, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8004730:	2001      	movs	r0, #1
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8004732:	4d0c      	ldr	r5, [pc, #48]	; (8004764 <HAL_RCC_OscConfig+0x3d8>)
 8004734:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8004736:	686a      	ldr	r2, [r5, #4]
 8004738:	430b      	orrs	r3, r1
 800473a:	f422 1274 	bic.w	r2, r2, #3997696	; 0x3d0000
        __HAL_RCC_PLL_ENABLE();
 800473e:	490a      	ldr	r1, [pc, #40]	; (8004768 <HAL_RCC_OscConfig+0x3dc>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8004740:	4313      	orrs	r3, r2
 8004742:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8004744:	6608      	str	r0, [r1, #96]	; 0x60
        tickstart = HAL_GetTick();
 8004746:	f7ff fa91 	bl	8003c6c <HAL_GetTick>
 800474a:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800474c:	e005      	b.n	800475a <HAL_RCC_OscConfig+0x3ce>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800474e:	f7ff fa8d 	bl	8003c6c <HAL_GetTick>
 8004752:	1b00      	subs	r0, r0, r4
 8004754:	2802      	cmp	r0, #2
 8004756:	f63f af3f 	bhi.w	80045d8 <HAL_RCC_OscConfig+0x24c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800475a:	682b      	ldr	r3, [r5, #0]
 800475c:	019a      	lsls	r2, r3, #6
 800475e:	d5f6      	bpl.n	800474e <HAL_RCC_OscConfig+0x3c2>
 8004760:	e6e1      	b.n	8004526 <HAL_RCC_OscConfig+0x19a>
 8004762:	bf00      	nop
 8004764:	40021000 	.word	0x40021000
 8004768:	42420000 	.word	0x42420000

0800476c <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 800476c:	2800      	cmp	r0, #0
 800476e:	f000 80a1 	beq.w	80048b4 <HAL_RCC_ClockConfig+0x148>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8004772:	4a56      	ldr	r2, [pc, #344]	; (80048cc <HAL_RCC_ClockConfig+0x160>)
{
 8004774:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8004778:	6813      	ldr	r3, [r2, #0]
 800477a:	4604      	mov	r4, r0
 800477c:	f003 0307 	and.w	r3, r3, #7
 8004780:	428b      	cmp	r3, r1
 8004782:	460d      	mov	r5, r1
 8004784:	d20c      	bcs.n	80047a0 <HAL_RCC_ClockConfig+0x34>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004786:	6813      	ldr	r3, [r2, #0]
 8004788:	f023 0307 	bic.w	r3, r3, #7
 800478c:	430b      	orrs	r3, r1
 800478e:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004790:	6813      	ldr	r3, [r2, #0]
 8004792:	f003 0307 	and.w	r3, r3, #7
 8004796:	428b      	cmp	r3, r1
 8004798:	d002      	beq.n	80047a0 <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 800479a:	2001      	movs	r0, #1
}
 800479c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80047a0:	6823      	ldr	r3, [r4, #0]
 80047a2:	079e      	lsls	r6, r3, #30
 80047a4:	d514      	bpl.n	80047d0 <HAL_RCC_ClockConfig+0x64>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80047a6:	0758      	lsls	r0, r3, #29
 80047a8:	d504      	bpl.n	80047b4 <HAL_RCC_ClockConfig+0x48>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80047aa:	4949      	ldr	r1, [pc, #292]	; (80048d0 <HAL_RCC_ClockConfig+0x164>)
 80047ac:	684a      	ldr	r2, [r1, #4]
 80047ae:	f442 62e0 	orr.w	r2, r2, #1792	; 0x700
 80047b2:	604a      	str	r2, [r1, #4]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80047b4:	0719      	lsls	r1, r3, #28
 80047b6:	d504      	bpl.n	80047c2 <HAL_RCC_ClockConfig+0x56>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80047b8:	4945      	ldr	r1, [pc, #276]	; (80048d0 <HAL_RCC_ClockConfig+0x164>)
 80047ba:	684a      	ldr	r2, [r1, #4]
 80047bc:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 80047c0:	604a      	str	r2, [r1, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80047c2:	4943      	ldr	r1, [pc, #268]	; (80048d0 <HAL_RCC_ClockConfig+0x164>)
 80047c4:	68a0      	ldr	r0, [r4, #8]
 80047c6:	684a      	ldr	r2, [r1, #4]
 80047c8:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80047cc:	4302      	orrs	r2, r0
 80047ce:	604a      	str	r2, [r1, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80047d0:	07da      	lsls	r2, r3, #31
 80047d2:	d520      	bpl.n	8004816 <HAL_RCC_ClockConfig+0xaa>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80047d4:	6862      	ldr	r2, [r4, #4]
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80047d6:	4b3e      	ldr	r3, [pc, #248]	; (80048d0 <HAL_RCC_ClockConfig+0x164>)
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80047d8:	2a01      	cmp	r2, #1
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80047da:	681b      	ldr	r3, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80047dc:	d06c      	beq.n	80048b8 <HAL_RCC_ClockConfig+0x14c>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80047de:	2a02      	cmp	r2, #2
 80047e0:	d065      	beq.n	80048ae <HAL_RCC_ClockConfig+0x142>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80047e2:	079e      	lsls	r6, r3, #30
 80047e4:	d5d9      	bpl.n	800479a <HAL_RCC_ClockConfig+0x2e>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80047e6:	4e3a      	ldr	r6, [pc, #232]	; (80048d0 <HAL_RCC_ClockConfig+0x164>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80047e8:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80047ec:	6873      	ldr	r3, [r6, #4]
 80047ee:	f023 0303 	bic.w	r3, r3, #3
 80047f2:	4313      	orrs	r3, r2
 80047f4:	6073      	str	r3, [r6, #4]
    tickstart = HAL_GetTick();
 80047f6:	f7ff fa39 	bl	8003c6c <HAL_GetTick>
 80047fa:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80047fc:	e004      	b.n	8004808 <HAL_RCC_ClockConfig+0x9c>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80047fe:	f7ff fa35 	bl	8003c6c <HAL_GetTick>
 8004802:	1bc0      	subs	r0, r0, r7
 8004804:	4540      	cmp	r0, r8
 8004806:	d85a      	bhi.n	80048be <HAL_RCC_ClockConfig+0x152>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004808:	6873      	ldr	r3, [r6, #4]
 800480a:	6862      	ldr	r2, [r4, #4]
 800480c:	f003 030c 	and.w	r3, r3, #12
 8004810:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8004814:	d1f3      	bne.n	80047fe <HAL_RCC_ClockConfig+0x92>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8004816:	4a2d      	ldr	r2, [pc, #180]	; (80048cc <HAL_RCC_ClockConfig+0x160>)
 8004818:	6813      	ldr	r3, [r2, #0]
 800481a:	f003 0307 	and.w	r3, r3, #7
 800481e:	42ab      	cmp	r3, r5
 8004820:	d909      	bls.n	8004836 <HAL_RCC_ClockConfig+0xca>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004822:	6813      	ldr	r3, [r2, #0]
 8004824:	f023 0307 	bic.w	r3, r3, #7
 8004828:	432b      	orrs	r3, r5
 800482a:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800482c:	6813      	ldr	r3, [r2, #0]
 800482e:	f003 0307 	and.w	r3, r3, #7
 8004832:	42ab      	cmp	r3, r5
 8004834:	d1b1      	bne.n	800479a <HAL_RCC_ClockConfig+0x2e>
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004836:	6823      	ldr	r3, [r4, #0]
 8004838:	0758      	lsls	r0, r3, #29
 800483a:	d506      	bpl.n	800484a <HAL_RCC_ClockConfig+0xde>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800483c:	4924      	ldr	r1, [pc, #144]	; (80048d0 <HAL_RCC_ClockConfig+0x164>)
 800483e:	68e0      	ldr	r0, [r4, #12]
 8004840:	684a      	ldr	r2, [r1, #4]
 8004842:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8004846:	4302      	orrs	r2, r0
 8004848:	604a      	str	r2, [r1, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800484a:	0719      	lsls	r1, r3, #28
 800484c:	d507      	bpl.n	800485e <HAL_RCC_ClockConfig+0xf2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800484e:	4a20      	ldr	r2, [pc, #128]	; (80048d0 <HAL_RCC_ClockConfig+0x164>)
 8004850:	6921      	ldr	r1, [r4, #16]
 8004852:	6853      	ldr	r3, [r2, #4]
 8004854:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8004858:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800485c:	6053      	str	r3, [r2, #4]
  tmpreg = RCC->CFGR;
 800485e:	491c      	ldr	r1, [pc, #112]	; (80048d0 <HAL_RCC_ClockConfig+0x164>)
 8004860:	684a      	ldr	r2, [r1, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8004862:	f002 030c 	and.w	r3, r2, #12
 8004866:	2b08      	cmp	r3, #8
 8004868:	d010      	beq.n	800488c <HAL_RCC_ClockConfig+0x120>
      sysclockfreq = HSE_VALUE;
 800486a:	4b1a      	ldr	r3, [pc, #104]	; (80048d4 <HAL_RCC_ClockConfig+0x168>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800486c:	4a18      	ldr	r2, [pc, #96]	; (80048d0 <HAL_RCC_ClockConfig+0x164>)
 800486e:	481a      	ldr	r0, [pc, #104]	; (80048d8 <HAL_RCC_ClockConfig+0x16c>)
 8004870:	6852      	ldr	r2, [r2, #4]
  HAL_InitTick(uwTickPrio);
 8004872:	491a      	ldr	r1, [pc, #104]	; (80048dc <HAL_RCC_ClockConfig+0x170>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8004874:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8004878:	5c80      	ldrb	r0, [r0, r2]
 800487a:	4a19      	ldr	r2, [pc, #100]	; (80048e0 <HAL_RCC_ClockConfig+0x174>)
 800487c:	40c3      	lsrs	r3, r0
  HAL_InitTick(uwTickPrio);
 800487e:	6808      	ldr	r0, [r1, #0]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8004880:	6013      	str	r3, [r2, #0]
  HAL_InitTick(uwTickPrio);
 8004882:	f7ff f9b1 	bl	8003be8 <HAL_InitTick>
  return HAL_OK;
 8004886:	2000      	movs	r0, #0
}
 8004888:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 800488c:	4815      	ldr	r0, [pc, #84]	; (80048e4 <HAL_RCC_ClockConfig+0x178>)
 800488e:	f3c2 4383 	ubfx	r3, r2, #18, #4
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8004892:	03d2      	lsls	r2, r2, #15
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8004894:	5cc3      	ldrb	r3, [r0, r3]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8004896:	d514      	bpl.n	80048c2 <HAL_RCC_ClockConfig+0x156>
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8004898:	480e      	ldr	r0, [pc, #56]	; (80048d4 <HAL_RCC_ClockConfig+0x168>)
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 800489a:	684a      	ldr	r2, [r1, #4]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 800489c:	fb00 f303 	mul.w	r3, r0, r3
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 80048a0:	4911      	ldr	r1, [pc, #68]	; (80048e8 <HAL_RCC_ClockConfig+0x17c>)
 80048a2:	f3c2 4240 	ubfx	r2, r2, #17, #1
 80048a6:	5c8a      	ldrb	r2, [r1, r2]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 80048a8:	fbb3 f3f2 	udiv	r3, r3, r2
 80048ac:	e7de      	b.n	800486c <HAL_RCC_ClockConfig+0x100>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80048ae:	019f      	lsls	r7, r3, #6
 80048b0:	d499      	bmi.n	80047e6 <HAL_RCC_ClockConfig+0x7a>
 80048b2:	e772      	b.n	800479a <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 80048b4:	2001      	movs	r0, #1
}
 80048b6:	4770      	bx	lr
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80048b8:	039b      	lsls	r3, r3, #14
 80048ba:	d494      	bmi.n	80047e6 <HAL_RCC_ClockConfig+0x7a>
 80048bc:	e76d      	b.n	800479a <HAL_RCC_ClockConfig+0x2e>
        return HAL_TIMEOUT;
 80048be:	2003      	movs	r0, #3
 80048c0:	e76c      	b.n	800479c <HAL_RCC_ClockConfig+0x30>
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 80048c2:	4a0a      	ldr	r2, [pc, #40]	; (80048ec <HAL_RCC_ClockConfig+0x180>)
 80048c4:	fb02 f303 	mul.w	r3, r2, r3
 80048c8:	e7d0      	b.n	800486c <HAL_RCC_ClockConfig+0x100>
 80048ca:	bf00      	nop
 80048cc:	40022000 	.word	0x40022000
 80048d0:	40021000 	.word	0x40021000
 80048d4:	007a1200 	.word	0x007a1200
 80048d8:	08005878 	.word	0x08005878
 80048dc:	20000010 	.word	0x20000010
 80048e0:	20000008 	.word	0x20000008
 80048e4:	08005890 	.word	0x08005890
 80048e8:	080058a0 	.word	0x080058a0
 80048ec:	003d0900 	.word	0x003d0900

080048f0 <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 80048f0:	4b04      	ldr	r3, [pc, #16]	; (8004904 <HAL_RCC_GetPCLK1Freq+0x14>)
  return SystemCoreClock;
 80048f2:	4a05      	ldr	r2, [pc, #20]	; (8004908 <HAL_RCC_GetPCLK1Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 80048f4:	685b      	ldr	r3, [r3, #4]
 80048f6:	4905      	ldr	r1, [pc, #20]	; (800490c <HAL_RCC_GetPCLK1Freq+0x1c>)
 80048f8:	f3c3 2302 	ubfx	r3, r3, #8, #3
 80048fc:	5ccb      	ldrb	r3, [r1, r3]
 80048fe:	6810      	ldr	r0, [r2, #0]
}
 8004900:	40d8      	lsrs	r0, r3
 8004902:	4770      	bx	lr
 8004904:	40021000 	.word	0x40021000
 8004908:	20000008 	.word	0x20000008
 800490c:	08005888 	.word	0x08005888

08004910 <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8004910:	4b04      	ldr	r3, [pc, #16]	; (8004924 <HAL_RCC_GetPCLK2Freq+0x14>)
  return SystemCoreClock;
 8004912:	4a05      	ldr	r2, [pc, #20]	; (8004928 <HAL_RCC_GetPCLK2Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8004914:	685b      	ldr	r3, [r3, #4]
 8004916:	4905      	ldr	r1, [pc, #20]	; (800492c <HAL_RCC_GetPCLK2Freq+0x1c>)
 8004918:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 800491c:	5ccb      	ldrb	r3, [r1, r3]
 800491e:	6810      	ldr	r0, [r2, #0]
}
 8004920:	40d8      	lsrs	r0, r3
 8004922:	4770      	bx	lr
 8004924:	40021000 	.word	0x40021000
 8004928:	20000008 	.word	0x20000008
 800492c:	08005888 	.word	0x08005888

08004930 <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8004930:	2800      	cmp	r0, #0
 8004932:	d066      	beq.n	8004a02 <HAL_TIM_Base_Init+0xd2>
{
 8004934:	b510      	push	{r4, lr}
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8004936:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 800493a:	4604      	mov	r4, r0
 800493c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8004940:	2b00      	cmp	r3, #0
 8004942:	d045      	beq.n	80049d0 <HAL_TIM_Base_Init+0xa0>
    HAL_TIM_Base_MspInit(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8004944:	2302      	movs	r3, #2

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8004946:	6822      	ldr	r2, [r4, #0]
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8004948:	492f      	ldr	r1, [pc, #188]	; (8004a08 <HAL_TIM_Base_Init+0xd8>)
  htim->State = HAL_TIM_STATE_BUSY;
 800494a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800494e:	428a      	cmp	r2, r1
  tmpcr1 = TIMx->CR1;
 8004950:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8004952:	d042      	beq.n	80049da <HAL_TIM_Base_Init+0xaa>
 8004954:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8004958:	d011      	beq.n	800497e <HAL_TIM_Base_Init+0x4e>
 800495a:	f5a1 3194 	sub.w	r1, r1, #75776	; 0x12800
 800495e:	428a      	cmp	r2, r1
 8004960:	d00d      	beq.n	800497e <HAL_TIM_Base_Init+0x4e>
 8004962:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8004966:	428a      	cmp	r2, r1
 8004968:	d009      	beq.n	800497e <HAL_TIM_Base_Init+0x4e>
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800496a:	69a0      	ldr	r0, [r4, #24]
 800496c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004970:	4303      	orrs	r3, r0

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004972:	68e1      	ldr	r1, [r4, #12]
  TIMx->CR1 = tmpcr1;
 8004974:	6013      	str	r3, [r2, #0]

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8004976:	6863      	ldr	r3, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004978:	62d1      	str	r1, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800497a:	6293      	str	r3, [r2, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800497c:	e010      	b.n	80049a0 <HAL_TIM_Base_Init+0x70>
    tmpcr1 |= Structure->CounterMode;
 800497e:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8004980:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8004984:	6920      	ldr	r0, [r4, #16]
    tmpcr1 |= Structure->CounterMode;
 8004986:	430b      	orrs	r3, r1
    tmpcr1 &= ~TIM_CR1_CKD;
 8004988:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800498c:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800498e:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004990:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004994:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004996:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 8004998:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 800499a:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800499c:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800499e:	6291      	str	r1, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80049a0:	2301      	movs	r3, #1
 80049a2:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80049a4:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80049a8:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 80049ac:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 80049b0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 80049b4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80049b8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80049bc:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80049c0:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80049c4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 80049c8:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 80049cc:	2000      	movs	r0, #0
}
 80049ce:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 80049d0:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 80049d4:	f7ff f828 	bl	8003a28 <HAL_TIM_Base_MspInit>
 80049d8:	e7b4      	b.n	8004944 <HAL_TIM_Base_Init+0x14>
    tmpcr1 |= Structure->CounterMode;
 80049da:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80049dc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80049e0:	6921      	ldr	r1, [r4, #16]
    tmpcr1 |= Structure->CounterMode;
 80049e2:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 80049e4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80049e8:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80049ea:	69a1      	ldr	r1, [r4, #24]
 80049ec:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80049f0:	430b      	orrs	r3, r1
  TIMx->CR1 = tmpcr1;
 80049f2:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80049f4:	68e3      	ldr	r3, [r4, #12]
 80049f6:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80049f8:	6863      	ldr	r3, [r4, #4]
 80049fa:	6293      	str	r3, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 80049fc:	6963      	ldr	r3, [r4, #20]
 80049fe:	6313      	str	r3, [r2, #48]	; 0x30
 8004a00:	e7ce      	b.n	80049a0 <HAL_TIM_Base_Init+0x70>
    return HAL_ERROR;
 8004a02:	2001      	movs	r0, #1
}
 8004a04:	4770      	bx	lr
 8004a06:	bf00      	nop
 8004a08:	40012c00 	.word	0x40012c00

08004a0c <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 8004a0c:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8004a10:	2b01      	cmp	r3, #1
 8004a12:	d11f      	bne.n	8004a54 <HAL_TIM_Base_Start_IT+0x48>
  htim->State = HAL_TIM_STATE_BUSY;
 8004a14:	2202      	movs	r2, #2
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8004a16:	6803      	ldr	r3, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8004a18:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8004a1c:	68da      	ldr	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8004a1e:	490f      	ldr	r1, [pc, #60]	; (8004a5c <HAL_TIM_Base_Start_IT+0x50>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8004a20:	f042 0201 	orr.w	r2, r2, #1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8004a24:	428b      	cmp	r3, r1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8004a26:	60da      	str	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8004a28:	d009      	beq.n	8004a3e <HAL_TIM_Base_Start_IT+0x32>
 8004a2a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8004a2e:	d006      	beq.n	8004a3e <HAL_TIM_Base_Start_IT+0x32>
 8004a30:	4a0b      	ldr	r2, [pc, #44]	; (8004a60 <HAL_TIM_Base_Start_IT+0x54>)
 8004a32:	4293      	cmp	r3, r2
 8004a34:	d003      	beq.n	8004a3e <HAL_TIM_Base_Start_IT+0x32>
 8004a36:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004a3a:	4293      	cmp	r3, r2
 8004a3c:	d104      	bne.n	8004a48 <HAL_TIM_Base_Start_IT+0x3c>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8004a3e:	689a      	ldr	r2, [r3, #8]
 8004a40:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8004a44:	2a06      	cmp	r2, #6
 8004a46:	d007      	beq.n	8004a58 <HAL_TIM_Base_Start_IT+0x4c>
    __HAL_TIM_ENABLE(htim);
 8004a48:	681a      	ldr	r2, [r3, #0]
  return HAL_OK;
 8004a4a:	2000      	movs	r0, #0
    __HAL_TIM_ENABLE(htim);
 8004a4c:	f042 0201 	orr.w	r2, r2, #1
 8004a50:	601a      	str	r2, [r3, #0]
 8004a52:	4770      	bx	lr
    return HAL_ERROR;
 8004a54:	2001      	movs	r0, #1
 8004a56:	4770      	bx	lr
  return HAL_OK;
 8004a58:	2000      	movs	r0, #0
}
 8004a5a:	4770      	bx	lr
 8004a5c:	40012c00 	.word	0x40012c00
 8004a60:	40000400 	.word	0x40000400

08004a64 <HAL_TIM_Base_Stop_IT>:
  __HAL_TIM_DISABLE(htim);
 8004a64:	f241 1c11 	movw	ip, #4369	; 0x1111
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8004a68:	6802      	ldr	r2, [r0, #0]
{
 8004a6a:	4603      	mov	r3, r0
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8004a6c:	68d1      	ldr	r1, [r2, #12]
 8004a6e:	f021 0101 	bic.w	r1, r1, #1
 8004a72:	60d1      	str	r1, [r2, #12]
  __HAL_TIM_DISABLE(htim);
 8004a74:	6a11      	ldr	r1, [r2, #32]
 8004a76:	ea11 0f0c 	tst.w	r1, ip
 8004a7a:	d108      	bne.n	8004a8e <HAL_TIM_Base_Stop_IT+0x2a>
 8004a7c:	f240 4144 	movw	r1, #1092	; 0x444
 8004a80:	6a10      	ldr	r0, [r2, #32]
 8004a82:	4208      	tst	r0, r1
 8004a84:	d103      	bne.n	8004a8e <HAL_TIM_Base_Stop_IT+0x2a>
 8004a86:	6811      	ldr	r1, [r2, #0]
 8004a88:	f021 0101 	bic.w	r1, r1, #1
 8004a8c:	6011      	str	r1, [r2, #0]
  htim->State = HAL_TIM_STATE_READY;
 8004a8e:	2201      	movs	r2, #1
}
 8004a90:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8004a92:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
}
 8004a96:	4770      	bx	lr

08004a98 <HAL_TIM_PWM_MspInit>:
 8004a98:	4770      	bx	lr
 8004a9a:	bf00      	nop

08004a9c <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 8004a9c:	2800      	cmp	r0, #0
 8004a9e:	d066      	beq.n	8004b6e <HAL_TIM_PWM_Init+0xd2>
{
 8004aa0:	b510      	push	{r4, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 8004aa2:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8004aa6:	4604      	mov	r4, r0
 8004aa8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8004aac:	2b00      	cmp	r3, #0
 8004aae:	d045      	beq.n	8004b3c <HAL_TIM_PWM_Init+0xa0>
  htim->State = HAL_TIM_STATE_BUSY;
 8004ab0:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8004ab2:	6822      	ldr	r2, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8004ab4:	492f      	ldr	r1, [pc, #188]	; (8004b74 <HAL_TIM_PWM_Init+0xd8>)
  htim->State = HAL_TIM_STATE_BUSY;
 8004ab6:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8004aba:	428a      	cmp	r2, r1
  tmpcr1 = TIMx->CR1;
 8004abc:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8004abe:	d042      	beq.n	8004b46 <HAL_TIM_PWM_Init+0xaa>
 8004ac0:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8004ac4:	d011      	beq.n	8004aea <HAL_TIM_PWM_Init+0x4e>
 8004ac6:	f5a1 3194 	sub.w	r1, r1, #75776	; 0x12800
 8004aca:	428a      	cmp	r2, r1
 8004acc:	d00d      	beq.n	8004aea <HAL_TIM_PWM_Init+0x4e>
 8004ace:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8004ad2:	428a      	cmp	r2, r1
 8004ad4:	d009      	beq.n	8004aea <HAL_TIM_PWM_Init+0x4e>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004ad6:	69a0      	ldr	r0, [r4, #24]
 8004ad8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004adc:	4303      	orrs	r3, r0
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004ade:	68e1      	ldr	r1, [r4, #12]
  TIMx->CR1 = tmpcr1;
 8004ae0:	6013      	str	r3, [r2, #0]
  TIMx->PSC = Structure->Prescaler;
 8004ae2:	6863      	ldr	r3, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004ae4:	62d1      	str	r1, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8004ae6:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8004ae8:	e010      	b.n	8004b0c <HAL_TIM_PWM_Init+0x70>
    tmpcr1 |= Structure->CounterMode;
 8004aea:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8004aec:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8004af0:	6920      	ldr	r0, [r4, #16]
    tmpcr1 |= Structure->CounterMode;
 8004af2:	430b      	orrs	r3, r1
    tmpcr1 &= ~TIM_CR1_CKD;
 8004af4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004af8:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8004afa:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004afc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004b00:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004b02:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 8004b04:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 8004b06:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004b08:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8004b0a:	6291      	str	r1, [r2, #40]	; 0x28
  TIMx->EGR = TIM_EGR_UG;
 8004b0c:	2301      	movs	r3, #1
 8004b0e:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8004b10:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8004b14:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8004b18:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8004b1c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8004b20:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8004b24:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8004b28:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8004b2c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8004b30:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 8004b34:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8004b38:	2000      	movs	r0, #0
}
 8004b3a:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8004b3c:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 8004b40:	f7ff ffaa 	bl	8004a98 <HAL_TIM_PWM_MspInit>
 8004b44:	e7b4      	b.n	8004ab0 <HAL_TIM_PWM_Init+0x14>
    tmpcr1 |= Structure->CounterMode;
 8004b46:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8004b48:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8004b4c:	6921      	ldr	r1, [r4, #16]
    tmpcr1 |= Structure->CounterMode;
 8004b4e:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 8004b50:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8004b54:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004b56:	69a1      	ldr	r1, [r4, #24]
 8004b58:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004b5c:	430b      	orrs	r3, r1
  TIMx->CR1 = tmpcr1;
 8004b5e:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004b60:	68e3      	ldr	r3, [r4, #12]
 8004b62:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8004b64:	6863      	ldr	r3, [r4, #4]
 8004b66:	6293      	str	r3, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 8004b68:	6963      	ldr	r3, [r4, #20]
 8004b6a:	6313      	str	r3, [r2, #48]	; 0x30
 8004b6c:	e7ce      	b.n	8004b0c <HAL_TIM_PWM_Init+0x70>
    return HAL_ERROR;
 8004b6e:	2001      	movs	r0, #1
}
 8004b70:	4770      	bx	lr
 8004b72:	bf00      	nop
 8004b74:	40012c00 	.word	0x40012c00

08004b78 <HAL_TIM_PWM_ConfigChannel>:
{
 8004b78:	4603      	mov	r3, r0
  __HAL_LOCK(htim);
 8004b7a:	f890 003c 	ldrb.w	r0, [r0, #60]	; 0x3c
 8004b7e:	2801      	cmp	r0, #1
 8004b80:	f000 80c5 	beq.w	8004d0e <HAL_TIM_PWM_ConfigChannel+0x196>
 8004b84:	2001      	movs	r0, #1
{
 8004b86:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(htim);
 8004b88:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c
  switch (Channel)
 8004b8c:	2a0c      	cmp	r2, #12
 8004b8e:	d808      	bhi.n	8004ba2 <HAL_TIM_PWM_ConfigChannel+0x2a>
 8004b90:	e8df f002 	tbb	[pc, r2]
 8004b94:	0707073b 	.word	0x0707073b
 8004b98:	07070765 	.word	0x07070765
 8004b9c:	07070792 	.word	0x07070792
 8004ba0:	0d          	.byte	0x0d
 8004ba1:	00          	.byte	0x00
  __HAL_UNLOCK(htim);
 8004ba2:	2200      	movs	r2, #0
 8004ba4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  switch (Channel)
 8004ba8:	2001      	movs	r0, #1
}
 8004baa:	bcf0      	pop	{r4, r5, r6, r7}
 8004bac:	4770      	bx	lr
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8004bae:	681a      	ldr	r2, [r3, #0]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004bb0:	680e      	ldr	r6, [r1, #0]
  tmpccer = TIMx->CCER;
 8004bb2:	6a10      	ldr	r0, [r2, #32]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8004bb4:	6a14      	ldr	r4, [r2, #32]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8004bb6:	f420 5000 	bic.w	r0, r0, #8192	; 0x2000
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8004bba:	f424 5480 	bic.w	r4, r4, #4096	; 0x1000
 8004bbe:	6214      	str	r4, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8004bc0:	6855      	ldr	r5, [r2, #4]
  tmpccmrx = TIMx->CCMR2;
 8004bc2:	69d4      	ldr	r4, [r2, #28]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8004bc4:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004bc8:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8004bcc:	688e      	ldr	r6, [r1, #8]
 8004bce:	ea40 3006 	orr.w	r0, r0, r6, lsl #12

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004bd2:	4e68      	ldr	r6, [pc, #416]	; (8004d74 <HAL_TIM_PWM_ConfigChannel+0x1fc>)
 8004bd4:	42b2      	cmp	r2, r6
 8004bd6:	f000 80b8 	beq.w	8004d4a <HAL_TIM_PWM_ConfigChannel+0x1d2>
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004bda:	6055      	str	r5, [r2, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8004bdc:	684d      	ldr	r5, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8004bde:	61d4      	str	r4, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8004be0:	690c      	ldr	r4, [r1, #16]
  TIMx->CCR4 = OC_Config->Pulse;
 8004be2:	6415      	str	r5, [r2, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004be4:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8004be6:	69d1      	ldr	r1, [r2, #28]
  HAL_StatusTypeDef status = HAL_OK;
 8004be8:	2000      	movs	r0, #0
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8004bea:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 8004bee:	61d1      	str	r1, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8004bf0:	69d1      	ldr	r1, [r2, #28]
 8004bf2:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8004bf6:	61d1      	str	r1, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8004bf8:	69d1      	ldr	r1, [r2, #28]
 8004bfa:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
 8004bfe:	61d1      	str	r1, [r2, #28]
  __HAL_UNLOCK(htim);
 8004c00:	2200      	movs	r2, #0
 8004c02:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 8004c06:	bcf0      	pop	{r4, r5, r6, r7}
 8004c08:	4770      	bx	lr
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8004c0a:	681a      	ldr	r2, [r3, #0]
  tmpccmrx |= OC_Config->OCMode;
 8004c0c:	680e      	ldr	r6, [r1, #0]
  tmpccer = TIMx->CCER;
 8004c0e:	6a10      	ldr	r0, [r2, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004c10:	6a14      	ldr	r4, [r2, #32]
  tmpccer &= ~TIM_CCER_CC1P;
 8004c12:	f020 0002 	bic.w	r0, r0, #2
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004c16:	f024 0401 	bic.w	r4, r4, #1
 8004c1a:	6214      	str	r4, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8004c1c:	6855      	ldr	r5, [r2, #4]
  tmpccmrx = TIMx->CCMR1;
 8004c1e:	6994      	ldr	r4, [r2, #24]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8004c20:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 8004c24:	4334      	orrs	r4, r6
  tmpccer |= OC_Config->OCPolarity;
 8004c26:	688e      	ldr	r6, [r1, #8]
 8004c28:	4330      	orrs	r0, r6
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8004c2a:	4e52      	ldr	r6, [pc, #328]	; (8004d74 <HAL_TIM_PWM_ConfigChannel+0x1fc>)
 8004c2c:	42b2      	cmp	r2, r6
 8004c2e:	d070      	beq.n	8004d12 <HAL_TIM_PWM_ConfigChannel+0x19a>
  TIMx->CR2 = tmpcr2;
 8004c30:	6055      	str	r5, [r2, #4]
  TIMx->CCR1 = OC_Config->Pulse;
 8004c32:	684d      	ldr	r5, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 8004c34:	6194      	str	r4, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8004c36:	690c      	ldr	r4, [r1, #16]
  TIMx->CCR1 = OC_Config->Pulse;
 8004c38:	6355      	str	r5, [r2, #52]	; 0x34
  TIMx->CCER = tmpccer;
 8004c3a:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8004c3c:	6991      	ldr	r1, [r2, #24]
  HAL_StatusTypeDef status = HAL_OK;
 8004c3e:	2000      	movs	r0, #0
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8004c40:	f041 0108 	orr.w	r1, r1, #8
 8004c44:	6191      	str	r1, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8004c46:	6991      	ldr	r1, [r2, #24]
 8004c48:	f021 0104 	bic.w	r1, r1, #4
 8004c4c:	6191      	str	r1, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8004c4e:	6991      	ldr	r1, [r2, #24]
 8004c50:	4321      	orrs	r1, r4
 8004c52:	6191      	str	r1, [r2, #24]
  __HAL_UNLOCK(htim);
 8004c54:	2200      	movs	r2, #0
 8004c56:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 8004c5a:	bcf0      	pop	{r4, r5, r6, r7}
 8004c5c:	4770      	bx	lr
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8004c5e:	681a      	ldr	r2, [r3, #0]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004c60:	680e      	ldr	r6, [r1, #0]
  tmpccer = TIMx->CCER;
 8004c62:	6a10      	ldr	r0, [r2, #32]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004c64:	6a14      	ldr	r4, [r2, #32]
  tmpccer &= ~TIM_CCER_CC2P;
 8004c66:	f020 0020 	bic.w	r0, r0, #32
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004c6a:	f024 0410 	bic.w	r4, r4, #16
 8004c6e:	6214      	str	r4, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8004c70:	6855      	ldr	r5, [r2, #4]
  tmpccmrx = TIMx->CCMR1;
 8004c72:	6994      	ldr	r4, [r2, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8004c74:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004c78:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8004c7c:	688e      	ldr	r6, [r1, #8]
 8004c7e:	ea40 1006 	orr.w	r0, r0, r6, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8004c82:	4e3c      	ldr	r6, [pc, #240]	; (8004d74 <HAL_TIM_PWM_ConfigChannel+0x1fc>)
 8004c84:	42b2      	cmp	r2, r6
 8004c86:	d051      	beq.n	8004d2c <HAL_TIM_PWM_ConfigChannel+0x1b4>
  TIMx->CR2 = tmpcr2;
 8004c88:	6055      	str	r5, [r2, #4]
  TIMx->CCR2 = OC_Config->Pulse;
 8004c8a:	684d      	ldr	r5, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 8004c8c:	6194      	str	r4, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8004c8e:	690c      	ldr	r4, [r1, #16]
  TIMx->CCR2 = OC_Config->Pulse;
 8004c90:	6395      	str	r5, [r2, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8004c92:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8004c94:	6991      	ldr	r1, [r2, #24]
  HAL_StatusTypeDef status = HAL_OK;
 8004c96:	2000      	movs	r0, #0
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8004c98:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 8004c9c:	6191      	str	r1, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8004c9e:	6991      	ldr	r1, [r2, #24]
 8004ca0:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8004ca4:	6191      	str	r1, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8004ca6:	6991      	ldr	r1, [r2, #24]
 8004ca8:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
 8004cac:	6191      	str	r1, [r2, #24]
  __HAL_UNLOCK(htim);
 8004cae:	2200      	movs	r2, #0
 8004cb0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 8004cb4:	bcf0      	pop	{r4, r5, r6, r7}
 8004cb6:	4770      	bx	lr
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8004cb8:	681a      	ldr	r2, [r3, #0]
  tmpccmrx |= OC_Config->OCMode;
 8004cba:	680e      	ldr	r6, [r1, #0]
  tmpccer = TIMx->CCER;
 8004cbc:	6a10      	ldr	r0, [r2, #32]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8004cbe:	6a14      	ldr	r4, [r2, #32]
  tmpccer &= ~TIM_CCER_CC3P;
 8004cc0:	f420 7000 	bic.w	r0, r0, #512	; 0x200
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8004cc4:	f424 7480 	bic.w	r4, r4, #256	; 0x100
 8004cc8:	6214      	str	r4, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8004cca:	6855      	ldr	r5, [r2, #4]
  tmpccmrx = TIMx->CCMR2;
 8004ccc:	69d4      	ldr	r4, [r2, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8004cce:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 8004cd2:	4334      	orrs	r4, r6
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8004cd4:	688e      	ldr	r6, [r1, #8]
 8004cd6:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8004cda:	4e26      	ldr	r6, [pc, #152]	; (8004d74 <HAL_TIM_PWM_ConfigChannel+0x1fc>)
 8004cdc:	42b2      	cmp	r2, r6
 8004cde:	d03a      	beq.n	8004d56 <HAL_TIM_PWM_ConfigChannel+0x1de>
  TIMx->CR2 = tmpcr2;
 8004ce0:	6055      	str	r5, [r2, #4]
  TIMx->CCR3 = OC_Config->Pulse;
 8004ce2:	684d      	ldr	r5, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8004ce4:	61d4      	str	r4, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8004ce6:	690c      	ldr	r4, [r1, #16]
  TIMx->CCR3 = OC_Config->Pulse;
 8004ce8:	63d5      	str	r5, [r2, #60]	; 0x3c
  TIMx->CCER = tmpccer;
 8004cea:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8004cec:	69d1      	ldr	r1, [r2, #28]
  HAL_StatusTypeDef status = HAL_OK;
 8004cee:	2000      	movs	r0, #0
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8004cf0:	f041 0108 	orr.w	r1, r1, #8
 8004cf4:	61d1      	str	r1, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8004cf6:	69d1      	ldr	r1, [r2, #28]
 8004cf8:	f021 0104 	bic.w	r1, r1, #4
 8004cfc:	61d1      	str	r1, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8004cfe:	69d1      	ldr	r1, [r2, #28]
 8004d00:	4321      	orrs	r1, r4
 8004d02:	61d1      	str	r1, [r2, #28]
  __HAL_UNLOCK(htim);
 8004d04:	2200      	movs	r2, #0
 8004d06:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 8004d0a:	bcf0      	pop	{r4, r5, r6, r7}
 8004d0c:	4770      	bx	lr
  __HAL_LOCK(htim);
 8004d0e:	2002      	movs	r0, #2
}
 8004d10:	4770      	bx	lr
    tmpccer |= OC_Config->OCNPolarity;
 8004d12:	68ce      	ldr	r6, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
 8004d14:	f020 0008 	bic.w	r0, r0, #8
    tmpccer |= OC_Config->OCNPolarity;
 8004d18:	4330      	orrs	r0, r6
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8004d1a:	f425 7540 	bic.w	r5, r5, #768	; 0x300
    tmpcr2 |= OC_Config->OCNIdleState;
 8004d1e:	e9d1 6705 	ldrd	r6, r7, [r1, #20]
 8004d22:	433e      	orrs	r6, r7
    tmpccer &= ~TIM_CCER_CC1NE;
 8004d24:	f020 0004 	bic.w	r0, r0, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 8004d28:	4335      	orrs	r5, r6
 8004d2a:	e781      	b.n	8004c30 <HAL_TIM_PWM_ConfigChannel+0xb8>
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8004d2c:	68ce      	ldr	r6, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 8004d2e:	f020 0080 	bic.w	r0, r0, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8004d32:	ea40 1006 	orr.w	r0, r0, r6, lsl #4
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8004d36:	f425 6540 	bic.w	r5, r5, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8004d3a:	e9d1 6705 	ldrd	r6, r7, [r1, #20]
 8004d3e:	433e      	orrs	r6, r7
    tmpccer &= ~TIM_CCER_CC2NE;
 8004d40:	f020 0040 	bic.w	r0, r0, #64	; 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8004d44:	ea45 0586 	orr.w	r5, r5, r6, lsl #2
 8004d48:	e79e      	b.n	8004c88 <HAL_TIM_PWM_ConfigChannel+0x110>
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8004d4a:	694e      	ldr	r6, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4;
 8004d4c:	f425 4580 	bic.w	r5, r5, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8004d50:	ea45 1586 	orr.w	r5, r5, r6, lsl #6
 8004d54:	e741      	b.n	8004bda <HAL_TIM_PWM_ConfigChannel+0x62>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8004d56:	68ce      	ldr	r6, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 8004d58:	f420 6000 	bic.w	r0, r0, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8004d5c:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8004d60:	f425 5540 	bic.w	r5, r5, #12288	; 0x3000
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8004d64:	e9d1 6705 	ldrd	r6, r7, [r1, #20]
 8004d68:	433e      	orrs	r6, r7
    tmpccer &= ~TIM_CCER_CC3NE;
 8004d6a:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8004d6e:	ea45 1506 	orr.w	r5, r5, r6, lsl #4
 8004d72:	e7b5      	b.n	8004ce0 <HAL_TIM_PWM_ConfigChannel+0x168>
 8004d74:	40012c00 	.word	0x40012c00

08004d78 <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 8004d78:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8004d7c:	2b01      	cmp	r3, #1
 8004d7e:	d075      	beq.n	8004e6c <HAL_TIM_ConfigClockSource+0xf4>
 8004d80:	4602      	mov	r2, r0
  htim->State = HAL_TIM_STATE_BUSY;
 8004d82:	2302      	movs	r3, #2
  __HAL_LOCK(htim);
 8004d84:	2001      	movs	r0, #1
{
 8004d86:	b430      	push	{r4, r5}
  tmpsmcr = htim->Instance->SMCR;
 8004d88:	6814      	ldr	r4, [r2, #0]
  __HAL_LOCK(htim);
 8004d8a:	f882 003c 	strb.w	r0, [r2, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 8004d8e:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
  tmpsmcr = htim->Instance->SMCR;
 8004d92:	68a3      	ldr	r3, [r4, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8004d94:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8004d98:	f023 0377 	bic.w	r3, r3, #119	; 0x77
  htim->Instance->SMCR = tmpsmcr;
 8004d9c:	60a3      	str	r3, [r4, #8]
  switch (sClockSourceConfig->ClockSource)
 8004d9e:	680b      	ldr	r3, [r1, #0]
 8004da0:	2b60      	cmp	r3, #96	; 0x60
 8004da2:	d065      	beq.n	8004e70 <HAL_TIM_ConfigClockSource+0xf8>
 8004da4:	d824      	bhi.n	8004df0 <HAL_TIM_ConfigClockSource+0x78>
 8004da6:	2b40      	cmp	r3, #64	; 0x40
 8004da8:	d07c      	beq.n	8004ea4 <HAL_TIM_ConfigClockSource+0x12c>
 8004daa:	d94b      	bls.n	8004e44 <HAL_TIM_ConfigClockSource+0xcc>
 8004dac:	2b50      	cmp	r3, #80	; 0x50
 8004dae:	d117      	bne.n	8004de0 <HAL_TIM_ConfigClockSource+0x68>
  HAL_StatusTypeDef status = HAL_OK;
 8004db0:	2000      	movs	r0, #0
                               sClockSourceConfig->ClockPolarity,
 8004db2:	684b      	ldr	r3, [r1, #4]
                               sClockSourceConfig->ClockFilter);
 8004db4:	68cd      	ldr	r5, [r1, #12]
{
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8004db6:	6a21      	ldr	r1, [r4, #32]
  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4U);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8004db8:	f021 010a 	bic.w	r1, r1, #10
  tmpccer |= TIM_ICPolarity;
 8004dbc:	4319      	orrs	r1, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004dbe:	6a23      	ldr	r3, [r4, #32]
 8004dc0:	f023 0301 	bic.w	r3, r3, #1
 8004dc4:	6223      	str	r3, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004dc6:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8004dc8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8004dcc:	ea43 1305 	orr.w	r3, r3, r5, lsl #4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8004dd0:	61a3      	str	r3, [r4, #24]
  TIMx->CCER = tmpccer;
 8004dd2:	6221      	str	r1, [r4, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8004dd4:	68a3      	ldr	r3, [r4, #8]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8004dd6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8004dda:	f043 0357 	orr.w	r3, r3, #87	; 0x57
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8004dde:	60a3      	str	r3, [r4, #8]
  htim->State = HAL_TIM_STATE_READY;
 8004de0:	2101      	movs	r1, #1
  __HAL_UNLOCK(htim);
 8004de2:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8004de4:	f882 103d 	strb.w	r1, [r2, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8004de8:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
}
 8004dec:	bc30      	pop	{r4, r5}
 8004dee:	4770      	bx	lr
  switch (sClockSourceConfig->ClockSource)
 8004df0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8004df4:	d038      	beq.n	8004e68 <HAL_TIM_ConfigClockSource+0xf0>
 8004df6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8004dfa:	d110      	bne.n	8004e1e <HAL_TIM_ConfigClockSource+0xa6>

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8004dfc:	e9d1 5301 	ldrd	r5, r3, [r1, #4]
  tmpsmcr = TIMx->SMCR;
 8004e00:	68a0      	ldr	r0, [r4, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8004e02:	432b      	orrs	r3, r5
 8004e04:	68cd      	ldr	r5, [r1, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8004e06:	f420 417f 	bic.w	r1, r0, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8004e0a:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8004e0e:	430b      	orrs	r3, r1

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8004e10:	60a3      	str	r3, [r4, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8004e12:	68a3      	ldr	r3, [r4, #8]
  HAL_StatusTypeDef status = HAL_OK;
 8004e14:	2000      	movs	r0, #0
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8004e16:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8004e1a:	60a3      	str	r3, [r4, #8]
      break;
 8004e1c:	e7e0      	b.n	8004de0 <HAL_TIM_ConfigClockSource+0x68>
  switch (sClockSourceConfig->ClockSource)
 8004e1e:	2b70      	cmp	r3, #112	; 0x70
 8004e20:	d1de      	bne.n	8004de0 <HAL_TIM_ConfigClockSource+0x68>
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8004e22:	e9d1 5301 	ldrd	r5, r3, [r1, #4]
  tmpsmcr = TIMx->SMCR;
 8004e26:	68a0      	ldr	r0, [r4, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8004e28:	432b      	orrs	r3, r5
 8004e2a:	68cd      	ldr	r5, [r1, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8004e2c:	f420 417f 	bic.w	r1, r0, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8004e30:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8004e34:	430b      	orrs	r3, r1
  TIMx->SMCR = tmpsmcr;
 8004e36:	60a3      	str	r3, [r4, #8]
      tmpsmcr = htim->Instance->SMCR;
 8004e38:	68a3      	ldr	r3, [r4, #8]
  HAL_StatusTypeDef status = HAL_OK;
 8004e3a:	2000      	movs	r0, #0
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8004e3c:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
 8004e40:	60a3      	str	r3, [r4, #8]
      break;
 8004e42:	e7cd      	b.n	8004de0 <HAL_TIM_ConfigClockSource+0x68>
  switch (sClockSourceConfig->ClockSource)
 8004e44:	2b20      	cmp	r3, #32
 8004e46:	d002      	beq.n	8004e4e <HAL_TIM_ConfigClockSource+0xd6>
 8004e48:	d90a      	bls.n	8004e60 <HAL_TIM_ConfigClockSource+0xe8>
 8004e4a:	2b30      	cmp	r3, #48	; 0x30
 8004e4c:	d1c8      	bne.n	8004de0 <HAL_TIM_ConfigClockSource+0x68>
  tmpsmcr = TIMx->SMCR;
 8004e4e:	68a1      	ldr	r1, [r4, #8]
  HAL_StatusTypeDef status = HAL_OK;
 8004e50:	2000      	movs	r0, #0
  tmpsmcr &= ~TIM_SMCR_TS;
 8004e52:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8004e56:	430b      	orrs	r3, r1
 8004e58:	f043 0307 	orr.w	r3, r3, #7
  TIMx->SMCR = tmpsmcr;
 8004e5c:	60a3      	str	r3, [r4, #8]
}
 8004e5e:	e7bf      	b.n	8004de0 <HAL_TIM_ConfigClockSource+0x68>
  switch (sClockSourceConfig->ClockSource)
 8004e60:	f033 0110 	bics.w	r1, r3, #16
 8004e64:	d1bc      	bne.n	8004de0 <HAL_TIM_ConfigClockSource+0x68>
 8004e66:	e7f2      	b.n	8004e4e <HAL_TIM_ConfigClockSource+0xd6>
  HAL_StatusTypeDef status = HAL_OK;
 8004e68:	2000      	movs	r0, #0
 8004e6a:	e7b9      	b.n	8004de0 <HAL_TIM_ConfigClockSource+0x68>
  __HAL_LOCK(htim);
 8004e6c:	2002      	movs	r0, #2
}
 8004e6e:	4770      	bx	lr
  tmpccer = TIMx->CCER;
 8004e70:	6a23      	ldr	r3, [r4, #32]
                               sClockSourceConfig->ClockPolarity,
 8004e72:	6848      	ldr	r0, [r1, #4]
                               sClockSourceConfig->ClockFilter);
 8004e74:	68cd      	ldr	r5, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004e76:	6a21      	ldr	r1, [r4, #32]
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8004e78:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004e7c:	f021 0110 	bic.w	r1, r1, #16
 8004e80:	6221      	str	r1, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004e82:	69a1      	ldr	r1, [r4, #24]
  tmpccer |= (TIM_ICPolarity << 4U);
 8004e84:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8004e88:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8004e8c:	ea41 3105 	orr.w	r1, r1, r5, lsl #12
  TIMx->CCMR1 = tmpccmr1 ;
 8004e90:	61a1      	str	r1, [r4, #24]
  TIMx->CCER = tmpccer;
 8004e92:	6223      	str	r3, [r4, #32]
  tmpsmcr = TIMx->SMCR;
 8004e94:	68a3      	ldr	r3, [r4, #8]
  HAL_StatusTypeDef status = HAL_OK;
 8004e96:	2000      	movs	r0, #0
  tmpsmcr &= ~TIM_SMCR_TS;
 8004e98:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8004e9c:	f043 0367 	orr.w	r3, r3, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
 8004ea0:	60a3      	str	r3, [r4, #8]
}
 8004ea2:	e79d      	b.n	8004de0 <HAL_TIM_ConfigClockSource+0x68>
                               sClockSourceConfig->ClockPolarity,
 8004ea4:	684b      	ldr	r3, [r1, #4]
                               sClockSourceConfig->ClockFilter);
 8004ea6:	68cd      	ldr	r5, [r1, #12]
  tmpccer = TIMx->CCER;
 8004ea8:	6a21      	ldr	r1, [r4, #32]
  HAL_StatusTypeDef status = HAL_OK;
 8004eaa:	2000      	movs	r0, #0
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8004eac:	f021 010a 	bic.w	r1, r1, #10
  tmpccer |= TIM_ICPolarity;
 8004eb0:	4319      	orrs	r1, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004eb2:	6a23      	ldr	r3, [r4, #32]
 8004eb4:	f023 0301 	bic.w	r3, r3, #1
 8004eb8:	6223      	str	r3, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004eba:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8004ebc:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8004ec0:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8004ec4:	61a3      	str	r3, [r4, #24]
  TIMx->CCER = tmpccer;
 8004ec6:	6221      	str	r1, [r4, #32]
  tmpsmcr = TIMx->SMCR;
 8004ec8:	68a3      	ldr	r3, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8004eca:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8004ece:	f043 0347 	orr.w	r3, r3, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
 8004ed2:	60a3      	str	r3, [r4, #8]
}
 8004ed4:	e784      	b.n	8004de0 <HAL_TIM_ConfigClockSource+0x68>
 8004ed6:	bf00      	nop

08004ed8 <HAL_TIM_OC_DelayElapsedCallback>:
 8004ed8:	4770      	bx	lr
 8004eda:	bf00      	nop

08004edc <HAL_TIM_IC_CaptureCallback>:
 8004edc:	4770      	bx	lr
 8004ede:	bf00      	nop

08004ee0 <HAL_TIM_PWM_PulseFinishedCallback>:
 8004ee0:	4770      	bx	lr
 8004ee2:	bf00      	nop

08004ee4 <HAL_TIM_TriggerCallback>:
 8004ee4:	4770      	bx	lr
 8004ee6:	bf00      	nop

08004ee8 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8004ee8:	6803      	ldr	r3, [r0, #0]
{
 8004eea:	b510      	push	{r4, lr}
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8004eec:	691a      	ldr	r2, [r3, #16]
{
 8004eee:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8004ef0:	0791      	lsls	r1, r2, #30
 8004ef2:	d502      	bpl.n	8004efa <HAL_TIM_IRQHandler+0x12>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8004ef4:	68da      	ldr	r2, [r3, #12]
 8004ef6:	0792      	lsls	r2, r2, #30
 8004ef8:	d45f      	bmi.n	8004fba <HAL_TIM_IRQHandler+0xd2>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8004efa:	691a      	ldr	r2, [r3, #16]
 8004efc:	0750      	lsls	r0, r2, #29
 8004efe:	d502      	bpl.n	8004f06 <HAL_TIM_IRQHandler+0x1e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8004f00:	68da      	ldr	r2, [r3, #12]
 8004f02:	0751      	lsls	r1, r2, #29
 8004f04:	d446      	bmi.n	8004f94 <HAL_TIM_IRQHandler+0xac>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8004f06:	691a      	ldr	r2, [r3, #16]
 8004f08:	0712      	lsls	r2, r2, #28
 8004f0a:	d502      	bpl.n	8004f12 <HAL_TIM_IRQHandler+0x2a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8004f0c:	68da      	ldr	r2, [r3, #12]
 8004f0e:	0710      	lsls	r0, r2, #28
 8004f10:	d42e      	bmi.n	8004f70 <HAL_TIM_IRQHandler+0x88>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8004f12:	691a      	ldr	r2, [r3, #16]
 8004f14:	06d2      	lsls	r2, r2, #27
 8004f16:	d502      	bpl.n	8004f1e <HAL_TIM_IRQHandler+0x36>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8004f18:	68da      	ldr	r2, [r3, #12]
 8004f1a:	06d0      	lsls	r0, r2, #27
 8004f1c:	d418      	bmi.n	8004f50 <HAL_TIM_IRQHandler+0x68>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8004f1e:	691a      	ldr	r2, [r3, #16]
 8004f20:	07d1      	lsls	r1, r2, #31
 8004f22:	d502      	bpl.n	8004f2a <HAL_TIM_IRQHandler+0x42>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8004f24:	68da      	ldr	r2, [r3, #12]
 8004f26:	07d2      	lsls	r2, r2, #31
 8004f28:	d45d      	bmi.n	8004fe6 <HAL_TIM_IRQHandler+0xfe>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8004f2a:	691a      	ldr	r2, [r3, #16]
 8004f2c:	0610      	lsls	r0, r2, #24
 8004f2e:	d502      	bpl.n	8004f36 <HAL_TIM_IRQHandler+0x4e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8004f30:	68da      	ldr	r2, [r3, #12]
 8004f32:	0611      	lsls	r1, r2, #24
 8004f34:	d45f      	bmi.n	8004ff6 <HAL_TIM_IRQHandler+0x10e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8004f36:	691a      	ldr	r2, [r3, #16]
 8004f38:	0652      	lsls	r2, r2, #25
 8004f3a:	d502      	bpl.n	8004f42 <HAL_TIM_IRQHandler+0x5a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8004f3c:	68da      	ldr	r2, [r3, #12]
 8004f3e:	0650      	lsls	r0, r2, #25
 8004f40:	d461      	bmi.n	8005006 <HAL_TIM_IRQHandler+0x11e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8004f42:	691a      	ldr	r2, [r3, #16]
 8004f44:	0691      	lsls	r1, r2, #26
 8004f46:	d502      	bpl.n	8004f4e <HAL_TIM_IRQHandler+0x66>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8004f48:	68da      	ldr	r2, [r3, #12]
 8004f4a:	0692      	lsls	r2, r2, #26
 8004f4c:	d443      	bmi.n	8004fd6 <HAL_TIM_IRQHandler+0xee>
}
 8004f4e:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8004f50:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8004f54:	2208      	movs	r2, #8
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8004f56:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8004f58:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8004f5a:	69db      	ldr	r3, [r3, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 8004f5c:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8004f5e:	f413 7f40 	tst.w	r3, #768	; 0x300
 8004f62:	d064      	beq.n	800502e <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8004f64:	f7ff ffba 	bl	8004edc <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004f68:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8004f6a:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004f6c:	7722      	strb	r2, [r4, #28]
 8004f6e:	e7d6      	b.n	8004f1e <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8004f70:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8004f74:	2204      	movs	r2, #4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8004f76:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8004f78:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8004f7a:	69db      	ldr	r3, [r3, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 8004f7c:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8004f7e:	0799      	lsls	r1, r3, #30
 8004f80:	d152      	bne.n	8005028 <HAL_TIM_IRQHandler+0x140>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8004f82:	f7ff ffa9 	bl	8004ed8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8004f86:	4620      	mov	r0, r4
 8004f88:	f7ff ffaa 	bl	8004ee0 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004f8c:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8004f8e:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004f90:	7722      	strb	r2, [r4, #28]
 8004f92:	e7be      	b.n	8004f12 <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8004f94:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8004f98:	2202      	movs	r2, #2
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8004f9a:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8004f9c:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8004f9e:	699b      	ldr	r3, [r3, #24]
        HAL_TIM_IC_CaptureCallback(htim);
 8004fa0:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8004fa2:	f413 7f40 	tst.w	r3, #768	; 0x300
 8004fa6:	d13c      	bne.n	8005022 <HAL_TIM_IRQHandler+0x13a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8004fa8:	f7ff ff96 	bl	8004ed8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8004fac:	4620      	mov	r0, r4
 8004fae:	f7ff ff97 	bl	8004ee0 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004fb2:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8004fb4:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004fb6:	7722      	strb	r2, [r4, #28]
 8004fb8:	e7a5      	b.n	8004f06 <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8004fba:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8004fbe:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8004fc0:	6119      	str	r1, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8004fc2:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8004fc4:	699b      	ldr	r3, [r3, #24]
 8004fc6:	079b      	lsls	r3, r3, #30
 8004fc8:	d025      	beq.n	8005016 <HAL_TIM_IRQHandler+0x12e>
          HAL_TIM_IC_CaptureCallback(htim);
 8004fca:	f7ff ff87 	bl	8004edc <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004fce:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8004fd0:	6823      	ldr	r3, [r4, #0]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8004fd2:	7722      	strb	r2, [r4, #28]
 8004fd4:	e791      	b.n	8004efa <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8004fd6:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 8004fda:	4620      	mov	r0, r4
}
 8004fdc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8004fe0:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8004fe2:	f000 b85d 	b.w	80050a0 <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8004fe6:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 8004fea:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8004fec:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8004fee:	f7fc fe65 	bl	8001cbc <HAL_TIM_PeriodElapsedCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8004ff2:	6823      	ldr	r3, [r4, #0]
 8004ff4:	e799      	b.n	8004f2a <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8004ff6:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 8004ffa:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8004ffc:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8004ffe:	f000 f851 	bl	80050a4 <HAL_TIMEx_BreakCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8005002:	6823      	ldr	r3, [r4, #0]
 8005004:	e797      	b.n	8004f36 <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8005006:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
 800500a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800500c:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 800500e:	f7ff ff69 	bl	8004ee4 <HAL_TIM_TriggerCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8005012:	6823      	ldr	r3, [r4, #0]
 8005014:	e795      	b.n	8004f42 <HAL_TIM_IRQHandler+0x5a>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8005016:	f7ff ff5f 	bl	8004ed8 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800501a:	4620      	mov	r0, r4
 800501c:	f7ff ff60 	bl	8004ee0 <HAL_TIM_PWM_PulseFinishedCallback>
 8005020:	e7d5      	b.n	8004fce <HAL_TIM_IRQHandler+0xe6>
        HAL_TIM_IC_CaptureCallback(htim);
 8005022:	f7ff ff5b 	bl	8004edc <HAL_TIM_IC_CaptureCallback>
 8005026:	e7c4      	b.n	8004fb2 <HAL_TIM_IRQHandler+0xca>
        HAL_TIM_IC_CaptureCallback(htim);
 8005028:	f7ff ff58 	bl	8004edc <HAL_TIM_IC_CaptureCallback>
 800502c:	e7ae      	b.n	8004f8c <HAL_TIM_IRQHandler+0xa4>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800502e:	f7ff ff53 	bl	8004ed8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005032:	4620      	mov	r0, r4
 8005034:	f7ff ff54 	bl	8004ee0 <HAL_TIM_PWM_PulseFinishedCallback>
 8005038:	e796      	b.n	8004f68 <HAL_TIM_IRQHandler+0x80>
 800503a:	bf00      	nop

0800503c <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 800503c:	f890 203c 	ldrb.w	r2, [r0, #60]	; 0x3c
 8005040:	2a01      	cmp	r2, #1
 8005042:	d027      	beq.n	8005094 <HAL_TIMEx_MasterConfigSynchronization+0x58>
 8005044:	4603      	mov	r3, r0

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8005046:	2002      	movs	r0, #2

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8005048:	681a      	ldr	r2, [r3, #0]
{
 800504a:	b430      	push	{r4, r5}
  htim->State = HAL_TIM_STATE_BUSY;
 800504c:	f883 003d 	strb.w	r0, [r3, #61]	; 0x3d
  tmpcr2 = htim->Instance->CR2;
 8005050:	6850      	ldr	r0, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8005052:	680c      	ldr	r4, [r1, #0]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8005054:	4d10      	ldr	r5, [pc, #64]	; (8005098 <HAL_TIMEx_MasterConfigSynchronization+0x5c>)
  tmpcr2 &= ~TIM_CR2_MMS;
 8005056:	f020 0070 	bic.w	r0, r0, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800505a:	4320      	orrs	r0, r4
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800505c:	42aa      	cmp	r2, r5
  tmpsmcr = htim->Instance->SMCR;
 800505e:	6894      	ldr	r4, [r2, #8]
  htim->Instance->CR2 = tmpcr2;
 8005060:	6050      	str	r0, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8005062:	d009      	beq.n	8005078 <HAL_TIMEx_MasterConfigSynchronization+0x3c>
 8005064:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8005068:	d006      	beq.n	8005078 <HAL_TIMEx_MasterConfigSynchronization+0x3c>
 800506a:	480c      	ldr	r0, [pc, #48]	; (800509c <HAL_TIMEx_MasterConfigSynchronization+0x60>)
 800506c:	4282      	cmp	r2, r0
 800506e:	d003      	beq.n	8005078 <HAL_TIMEx_MasterConfigSynchronization+0x3c>
 8005070:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 8005074:	4282      	cmp	r2, r0
 8005076:	d104      	bne.n	8005082 <HAL_TIMEx_MasterConfigSynchronization+0x46>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8005078:	6849      	ldr	r1, [r1, #4]
    tmpsmcr &= ~TIM_SMCR_MSM;
 800507a:	f024 0480 	bic.w	r4, r4, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800507e:	430c      	orrs	r4, r1

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8005080:	6094      	str	r4, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 8005082:	2200      	movs	r2, #0
  htim->State = HAL_TIM_STATE_READY;
 8005084:	2101      	movs	r1, #1
  __HAL_UNLOCK(htim);
 8005086:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_READY;
 800508a:	f883 103d 	strb.w	r1, [r3, #61]	; 0x3d

  return HAL_OK;
 800508e:	4610      	mov	r0, r2
}
 8005090:	bc30      	pop	{r4, r5}
 8005092:	4770      	bx	lr
  __HAL_LOCK(htim);
 8005094:	2002      	movs	r0, #2
}
 8005096:	4770      	bx	lr
 8005098:	40012c00 	.word	0x40012c00
 800509c:	40000400 	.word	0x40000400

080050a0 <HAL_TIMEx_CommutCallback>:
 80050a0:	4770      	bx	lr
 80050a2:	bf00      	nop

080050a4 <HAL_TIMEx_BreakCallback>:
 80050a4:	4770      	bx	lr
 80050a6:	bf00      	nop

080050a8 <HAL_UART_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if (huart == NULL)
 80050a8:	2800      	cmp	r0, #0
 80050aa:	d065      	beq.n	8005178 <HAL_UART_Init+0xd0>
{
 80050ac:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
#if defined(USART_CR1_OVER8)
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
#endif /* USART_CR1_OVER8 */

  if (huart->gState == HAL_UART_STATE_RESET)
 80050ae:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80050b2:	4604      	mov	r4, r0
 80050b4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80050b8:	2b00      	cmp	r3, #0
 80050ba:	d055      	beq.n	8005168 <HAL_UART_Init+0xc0>
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1,
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);
#else
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 80050bc:	e9d4 2602 	ldrd	r2, r6, [r4, #8]
  huart->gState = HAL_UART_STATE_BUSY;
 80050c0:	2124      	movs	r1, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 80050c2:	6823      	ldr	r3, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80050c4:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  __HAL_UART_DISABLE(huart);
 80050c8:	68d9      	ldr	r1, [r3, #12]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 80050ca:	6920      	ldr	r0, [r4, #16]
  __HAL_UART_DISABLE(huart);
 80050cc:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
             tmpreg);
#endif /* USART_CR1_OVER8 */

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80050d0:	69a5      	ldr	r5, [r4, #24]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 80050d2:	4302      	orrs	r2, r0
 80050d4:	6960      	ldr	r0, [r4, #20]
  __HAL_UART_DISABLE(huart);
 80050d6:	60d9      	str	r1, [r3, #12]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80050d8:	6919      	ldr	r1, [r3, #16]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 80050da:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80050dc:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
 80050e0:	4331      	orrs	r1, r6
 80050e2:	6119      	str	r1, [r3, #16]
  MODIFY_REG(huart->Instance->CR1,
 80050e4:	68d9      	ldr	r1, [r3, #12]


  if(huart->Instance == USART1)
 80050e6:	4825      	ldr	r0, [pc, #148]	; (800517c <HAL_UART_Init+0xd4>)
  MODIFY_REG(huart->Instance->CR1,
 80050e8:	f421 51b0 	bic.w	r1, r1, #5632	; 0x1600
 80050ec:	f021 010c 	bic.w	r1, r1, #12
 80050f0:	430a      	orrs	r2, r1
 80050f2:	60da      	str	r2, [r3, #12]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80050f4:	695a      	ldr	r2, [r3, #20]
  if(huart->Instance == USART1)
 80050f6:	4283      	cmp	r3, r0
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80050f8:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80050fc:	ea42 0205 	orr.w	r2, r2, r5
 8005100:	615a      	str	r2, [r3, #20]
  if(huart->Instance == USART1)
 8005102:	d036      	beq.n	8005172 <HAL_UART_Init+0xca>
  {
    pclk = HAL_RCC_GetPCLK2Freq();
  }
  else
  {
    pclk = HAL_RCC_GetPCLK1Freq();
 8005104:	f7ff fbf4 	bl	80048f0 <HAL_RCC_GetPCLK1Freq>
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
#else
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8005108:	6862      	ldr	r2, [r4, #4]
 800510a:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 800510e:	0092      	lsls	r2, r2, #2
 8005110:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8005114:	fbb3 f3f2 	udiv	r3, r3, r2
 8005118:	f04f 0e64 	mov.w	lr, #100	; 0x64
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800511c:	2500      	movs	r5, #0
  huart->gState = HAL_UART_STATE_READY;
 800511e:	f04f 0c20 	mov.w	ip, #32
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8005122:	4817      	ldr	r0, [pc, #92]	; (8005180 <HAL_UART_Init+0xd8>)
 8005124:	6821      	ldr	r1, [r4, #0]
 8005126:	fba0 6203 	umull	r6, r2, r0, r3
 800512a:	0952      	lsrs	r2, r2, #5
 800512c:	fb0e 3312 	mls	r3, lr, r2, r3
 8005130:	011b      	lsls	r3, r3, #4
 8005132:	3332      	adds	r3, #50	; 0x32
 8005134:	fba0 0303 	umull	r0, r3, r0, r3
 8005138:	0112      	lsls	r2, r2, #4
 800513a:	eb02 1253 	add.w	r2, r2, r3, lsr #5
 800513e:	608a      	str	r2, [r1, #8]
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8005140:	690b      	ldr	r3, [r1, #16]
  return HAL_OK;
 8005142:	4628      	mov	r0, r5
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8005144:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8005148:	610b      	str	r3, [r1, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800514a:	694b      	ldr	r3, [r1, #20]
 800514c:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 8005150:	614b      	str	r3, [r1, #20]
  __HAL_UART_ENABLE(huart);
 8005152:	68cb      	ldr	r3, [r1, #12]
 8005154:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8005158:	60cb      	str	r3, [r1, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800515a:	6465      	str	r5, [r4, #68]	; 0x44
  huart->gState = HAL_UART_STATE_READY;
 800515c:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
  huart->RxState = HAL_UART_STATE_READY;
 8005160:	f884 c042 	strb.w	ip, [r4, #66]	; 0x42
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8005164:	6365      	str	r5, [r4, #52]	; 0x34
}
 8005166:	bd70      	pop	{r4, r5, r6, pc}
    huart->Lock = HAL_UNLOCKED;
 8005168:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_UART_MspInit(huart);
 800516c:	f7fe fcba 	bl	8003ae4 <HAL_UART_MspInit>
 8005170:	e7a4      	b.n	80050bc <HAL_UART_Init+0x14>
    pclk = HAL_RCC_GetPCLK2Freq();
 8005172:	f7ff fbcd 	bl	8004910 <HAL_RCC_GetPCLK2Freq>
 8005176:	e7c7      	b.n	8005108 <HAL_UART_Init+0x60>
    return HAL_ERROR;
 8005178:	2001      	movs	r0, #1
}
 800517a:	4770      	bx	lr
 800517c:	40013800 	.word	0x40013800
 8005180:	51eb851f 	.word	0x51eb851f

08005184 <HAL_UART_Transmit>:
{
 8005184:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005188:	461d      	mov	r5, r3
  if (huart->gState == HAL_UART_STATE_READY)
 800518a:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 800518e:	2b20      	cmp	r3, #32
 8005190:	d16b      	bne.n	800526a <HAL_UART_Transmit+0xe6>
    if ((pData == NULL) || (Size == 0U))
 8005192:	4688      	mov	r8, r1
 8005194:	b109      	cbz	r1, 800519a <HAL_UART_Transmit+0x16>
 8005196:	4617      	mov	r7, r2
 8005198:	b912      	cbnz	r2, 80051a0 <HAL_UART_Transmit+0x1c>
      return  HAL_ERROR;
 800519a:	2001      	movs	r0, #1
}
 800519c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80051a0:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80051a2:	f04f 0900 	mov.w	r9, #0
 80051a6:	4604      	mov	r4, r0
 80051a8:	f8c0 9044 	str.w	r9, [r0, #68]	; 0x44
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80051ac:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
    tickstart = HAL_GetTick();
 80051b0:	f7fe fd5c 	bl	8003c6c <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80051b4:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 80051b6:	4606      	mov	r6, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80051b8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferSize = Size;
 80051bc:	84a7      	strh	r7, [r4, #36]	; 0x24
    huart->TxXferCount = Size;
 80051be:	84e7      	strh	r7, [r4, #38]	; 0x26
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80051c0:	d056      	beq.n	8005270 <HAL_UART_Transmit+0xec>
    while (huart->TxXferCount > 0U)
 80051c2:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 80051c4:	b29b      	uxth	r3, r3
 80051c6:	2b00      	cmp	r3, #0
 80051c8:	d07b      	beq.n	80052c2 <HAL_UART_Transmit+0x13e>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80051ca:	6823      	ldr	r3, [r4, #0]
 80051cc:	1c69      	adds	r1, r5, #1
 80051ce:	d11b      	bne.n	8005208 <HAL_UART_Transmit+0x84>
 80051d0:	681a      	ldr	r2, [r3, #0]
 80051d2:	0612      	lsls	r2, r2, #24
 80051d4:	d5fc      	bpl.n	80051d0 <HAL_UART_Transmit+0x4c>
      if (pdata8bits == NULL)
 80051d6:	f1b8 0f00 	cmp.w	r8, #0
 80051da:	d041      	beq.n	8005260 <HAL_UART_Transmit+0xdc>
        huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
 80051dc:	f818 2b01 	ldrb.w	r2, [r8], #1
 80051e0:	605a      	str	r2, [r3, #4]
      huart->TxXferCount--;
 80051e2:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 80051e4:	3a01      	subs	r2, #1
 80051e6:	b292      	uxth	r2, r2
 80051e8:	84e2      	strh	r2, [r4, #38]	; 0x26
    while (huart->TxXferCount > 0U)
 80051ea:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 80051ec:	b292      	uxth	r2, r2
 80051ee:	2a00      	cmp	r2, #0
 80051f0:	d1ec      	bne.n	80051cc <HAL_UART_Transmit+0x48>
 80051f2:	1c68      	adds	r0, r5, #1
 80051f4:	d142      	bne.n	800527c <HAL_UART_Transmit+0xf8>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80051f6:	681a      	ldr	r2, [r3, #0]
 80051f8:	0651      	lsls	r1, r2, #25
 80051fa:	d5fc      	bpl.n	80051f6 <HAL_UART_Transmit+0x72>
    huart->gState = HAL_UART_STATE_READY;
 80051fc:	2320      	movs	r3, #32
 80051fe:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    return HAL_OK;
 8005202:	2000      	movs	r0, #0
}
 8005204:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8005208:	681a      	ldr	r2, [r3, #0]
 800520a:	0617      	lsls	r7, r2, #24
 800520c:	d4e3      	bmi.n	80051d6 <HAL_UART_Transmit+0x52>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 800520e:	b12d      	cbz	r5, 800521c <HAL_UART_Transmit+0x98>
 8005210:	f7fe fd2c 	bl	8003c6c <HAL_GetTick>
 8005214:	1b80      	subs	r0, r0, r6
 8005216:	4285      	cmp	r5, r0
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8005218:	6823      	ldr	r3, [r4, #0]
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 800521a:	d2d7      	bcs.n	80051cc <HAL_UART_Transmit+0x48>
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800521c:	f103 020c 	add.w	r2, r3, #12
 8005220:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8005224:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005228:	f103 000c 	add.w	r0, r3, #12
 800522c:	e840 2100 	strex	r1, r2, [r0]
 8005230:	2900      	cmp	r1, #0
 8005232:	d1f3      	bne.n	800521c <HAL_UART_Transmit+0x98>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005234:	f103 0214 	add.w	r2, r3, #20
 8005238:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800523c:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005240:	f103 0014 	add.w	r0, r3, #20
 8005244:	e840 2100 	strex	r1, r2, [r0]
 8005248:	2900      	cmp	r1, #0
 800524a:	d1f3      	bne.n	8005234 <HAL_UART_Transmit+0xb0>
        huart->gState  = HAL_UART_STATE_READY;
 800524c:	2320      	movs	r3, #32
        __HAL_UNLOCK(huart);
 800524e:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
        huart->gState  = HAL_UART_STATE_READY;
 8005252:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        huart->RxState = HAL_UART_STATE_READY;
 8005256:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      return HAL_TIMEOUT;
 800525a:	2003      	movs	r0, #3
}
 800525c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
 8005260:	f839 2b02 	ldrh.w	r2, [r9], #2
 8005264:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8005268:	e7ba      	b.n	80051e0 <HAL_UART_Transmit+0x5c>
    return HAL_BUSY;
 800526a:	2002      	movs	r0, #2
}
 800526c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8005270:	6923      	ldr	r3, [r4, #16]
 8005272:	2b00      	cmp	r3, #0
 8005274:	d1a5      	bne.n	80051c2 <HAL_UART_Transmit+0x3e>
 8005276:	46c1      	mov	r9, r8
      pdata8bits  = NULL;
 8005278:	4698      	mov	r8, r3
 800527a:	e7a2      	b.n	80051c2 <HAL_UART_Transmit+0x3e>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800527c:	681a      	ldr	r2, [r3, #0]
 800527e:	0652      	lsls	r2, r2, #25
 8005280:	d4bc      	bmi.n	80051fc <HAL_UART_Transmit+0x78>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8005282:	b12d      	cbz	r5, 8005290 <HAL_UART_Transmit+0x10c>
 8005284:	f7fe fcf2 	bl	8003c6c <HAL_GetTick>
 8005288:	1b83      	subs	r3, r0, r6
 800528a:	429d      	cmp	r5, r3
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800528c:	6823      	ldr	r3, [r4, #0]
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 800528e:	d2b0      	bcs.n	80051f2 <HAL_UART_Transmit+0x6e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005290:	f103 020c 	add.w	r2, r3, #12
 8005294:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8005298:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800529c:	f103 000c 	add.w	r0, r3, #12
 80052a0:	e840 2100 	strex	r1, r2, [r0]
 80052a4:	2900      	cmp	r1, #0
 80052a6:	d1f3      	bne.n	8005290 <HAL_UART_Transmit+0x10c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80052a8:	f103 0214 	add.w	r2, r3, #20
 80052ac:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80052b0:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80052b4:	f103 0014 	add.w	r0, r3, #20
 80052b8:	e840 2100 	strex	r1, r2, [r0]
 80052bc:	2900      	cmp	r1, #0
 80052be:	d1f3      	bne.n	80052a8 <HAL_UART_Transmit+0x124>
 80052c0:	e7c4      	b.n	800524c <HAL_UART_Transmit+0xc8>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80052c2:	6823      	ldr	r3, [r4, #0]
 80052c4:	e795      	b.n	80051f2 <HAL_UART_Transmit+0x6e>
 80052c6:	bf00      	nop

080052c8 <HAL_UART_Receive>:
{
 80052c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80052cc:	461f      	mov	r7, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 80052ce:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
 80052d2:	2b20      	cmp	r3, #32
 80052d4:	d176      	bne.n	80053c4 <HAL_UART_Receive+0xfc>
    if ((pData == NULL) || (Size == 0U))
 80052d6:	4688      	mov	r8, r1
 80052d8:	b109      	cbz	r1, 80052de <HAL_UART_Receive+0x16>
 80052da:	4616      	mov	r6, r2
 80052dc:	b912      	cbnz	r2, 80052e4 <HAL_UART_Receive+0x1c>
      return  HAL_ERROR;
 80052de:	2001      	movs	r0, #1
}
 80052e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 80052e4:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80052e6:	f04f 0900 	mov.w	r9, #0
 80052ea:	4604      	mov	r4, r0
 80052ec:	f8c0 9044 	str.w	r9, [r0, #68]	; 0x44
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 80052f0:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80052f4:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
    tickstart = HAL_GetTick();
 80052f8:	f7fe fcb8 	bl	8003c6c <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80052fc:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 80052fe:	4605      	mov	r5, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8005300:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->RxXferSize = Size;
 8005304:	85a6      	strh	r6, [r4, #44]	; 0x2c
    huart->RxXferCount = Size;
 8005306:	85e6      	strh	r6, [r4, #46]	; 0x2e
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8005308:	d05f      	beq.n	80053ca <HAL_UART_Receive+0x102>
    while (huart->RxXferCount > 0U)
 800530a:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 800530c:	b29b      	uxth	r3, r3
 800530e:	b1eb      	cbz	r3, 800534c <HAL_UART_Receive+0x84>
 8005310:	1c78      	adds	r0, r7, #1
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8005312:	6823      	ldr	r3, [r4, #0]
 8005314:	d120      	bne.n	8005358 <HAL_UART_Receive+0x90>
 8005316:	681a      	ldr	r2, [r3, #0]
 8005318:	0691      	lsls	r1, r2, #26
 800531a:	d5fc      	bpl.n	8005316 <HAL_UART_Receive+0x4e>
      if (pdata8bits == NULL)
 800531c:	f1b8 0f00 	cmp.w	r8, #0
 8005320:	d04a      	beq.n	80053b8 <HAL_UART_Receive+0xf0>
        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 8005322:	68a2      	ldr	r2, [r4, #8]
 8005324:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8005328:	d004      	beq.n	8005334 <HAL_UART_Receive+0x6c>
 800532a:	2a00      	cmp	r2, #0
 800532c:	d140      	bne.n	80053b0 <HAL_UART_Receive+0xe8>
 800532e:	6922      	ldr	r2, [r4, #16]
 8005330:	2a00      	cmp	r2, #0
 8005332:	d13d      	bne.n	80053b0 <HAL_UART_Receive+0xe8>
          *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8005334:	685b      	ldr	r3, [r3, #4]
 8005336:	b2db      	uxtb	r3, r3
 8005338:	f808 3b01 	strb.w	r3, [r8], #1
      huart->RxXferCount--;
 800533c:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
 800533e:	3a01      	subs	r2, #1
 8005340:	b292      	uxth	r2, r2
 8005342:	85e2      	strh	r2, [r4, #46]	; 0x2e
    while (huart->RxXferCount > 0U)
 8005344:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8005346:	b29b      	uxth	r3, r3
 8005348:	2b00      	cmp	r3, #0
 800534a:	d1e1      	bne.n	8005310 <HAL_UART_Receive+0x48>
    huart->RxState = HAL_UART_STATE_READY;
 800534c:	2320      	movs	r3, #32
 800534e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    return HAL_OK;
 8005352:	2000      	movs	r0, #0
}
 8005354:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8005358:	681a      	ldr	r2, [r3, #0]
 800535a:	0692      	lsls	r2, r2, #26
 800535c:	d4de      	bmi.n	800531c <HAL_UART_Receive+0x54>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 800535e:	b12f      	cbz	r7, 800536c <HAL_UART_Receive+0xa4>
 8005360:	f7fe fc84 	bl	8003c6c <HAL_GetTick>
 8005364:	1b40      	subs	r0, r0, r5
 8005366:	4287      	cmp	r7, r0
 8005368:	d2d2      	bcs.n	8005310 <HAL_UART_Receive+0x48>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800536a:	6823      	ldr	r3, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800536c:	f103 020c 	add.w	r2, r3, #12
 8005370:	e852 2f00 	ldrex	r2, [r2]
 8005374:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005378:	f103 000c 	add.w	r0, r3, #12
 800537c:	e840 2100 	strex	r1, r2, [r0]
 8005380:	2900      	cmp	r1, #0
 8005382:	d1f3      	bne.n	800536c <HAL_UART_Receive+0xa4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005384:	f103 0214 	add.w	r2, r3, #20
 8005388:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800538c:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005390:	f103 0014 	add.w	r0, r3, #20
 8005394:	e840 2100 	strex	r1, r2, [r0]
 8005398:	2900      	cmp	r1, #0
 800539a:	d1f3      	bne.n	8005384 <HAL_UART_Receive+0xbc>
        huart->gState  = HAL_UART_STATE_READY;
 800539c:	2320      	movs	r3, #32
        __HAL_UNLOCK(huart);
 800539e:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
        huart->gState  = HAL_UART_STATE_READY;
 80053a2:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        huart->RxState = HAL_UART_STATE_READY;
 80053a6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        return HAL_TIMEOUT;
 80053aa:	2003      	movs	r0, #3
}
 80053ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 80053b0:	685b      	ldr	r3, [r3, #4]
 80053b2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80053b6:	e7bf      	b.n	8005338 <HAL_UART_Receive+0x70>
        *pdata16bits = (uint16_t)(huart->Instance->DR & 0x01FF);
 80053b8:	685b      	ldr	r3, [r3, #4]
 80053ba:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80053be:	f829 3b02 	strh.w	r3, [r9], #2
        pdata16bits++;
 80053c2:	e7bb      	b.n	800533c <HAL_UART_Receive+0x74>
    return HAL_BUSY;
 80053c4:	2002      	movs	r0, #2
}
 80053c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80053ca:	6923      	ldr	r3, [r4, #16]
 80053cc:	2b00      	cmp	r3, #0
 80053ce:	d19c      	bne.n	800530a <HAL_UART_Receive+0x42>
 80053d0:	46c1      	mov	r9, r8
      pdata8bits  = NULL;
 80053d2:	4698      	mov	r8, r3
 80053d4:	e799      	b.n	800530a <HAL_UART_Receive+0x42>
 80053d6:	bf00      	nop

080053d8 <memset>:
 80053d8:	4603      	mov	r3, r0
 80053da:	4402      	add	r2, r0
 80053dc:	4293      	cmp	r3, r2
 80053de:	d100      	bne.n	80053e2 <memset+0xa>
 80053e0:	4770      	bx	lr
 80053e2:	f803 1b01 	strb.w	r1, [r3], #1
 80053e6:	e7f9      	b.n	80053dc <memset+0x4>

080053e8 <__libc_init_array>:
 80053e8:	b570      	push	{r4, r5, r6, lr}
 80053ea:	2600      	movs	r6, #0
 80053ec:	4d0c      	ldr	r5, [pc, #48]	; (8005420 <__libc_init_array+0x38>)
 80053ee:	4c0d      	ldr	r4, [pc, #52]	; (8005424 <__libc_init_array+0x3c>)
 80053f0:	1b64      	subs	r4, r4, r5
 80053f2:	10a4      	asrs	r4, r4, #2
 80053f4:	42a6      	cmp	r6, r4
 80053f6:	d109      	bne.n	800540c <__libc_init_array+0x24>
 80053f8:	f000 f828 	bl	800544c <_init>
 80053fc:	2600      	movs	r6, #0
 80053fe:	4d0a      	ldr	r5, [pc, #40]	; (8005428 <__libc_init_array+0x40>)
 8005400:	4c0a      	ldr	r4, [pc, #40]	; (800542c <__libc_init_array+0x44>)
 8005402:	1b64      	subs	r4, r4, r5
 8005404:	10a4      	asrs	r4, r4, #2
 8005406:	42a6      	cmp	r6, r4
 8005408:	d105      	bne.n	8005416 <__libc_init_array+0x2e>
 800540a:	bd70      	pop	{r4, r5, r6, pc}
 800540c:	f855 3b04 	ldr.w	r3, [r5], #4
 8005410:	4798      	blx	r3
 8005412:	3601      	adds	r6, #1
 8005414:	e7ee      	b.n	80053f4 <__libc_init_array+0xc>
 8005416:	f855 3b04 	ldr.w	r3, [r5], #4
 800541a:	4798      	blx	r3
 800541c:	3601      	adds	r6, #1
 800541e:	e7f2      	b.n	8005406 <__libc_init_array+0x1e>
 8005420:	080058a4 	.word	0x080058a4
 8005424:	080058a4 	.word	0x080058a4
 8005428:	080058a4 	.word	0x080058a4
 800542c:	080058a8 	.word	0x080058a8

08005430 <memcpy>:
 8005430:	440a      	add	r2, r1
 8005432:	4291      	cmp	r1, r2
 8005434:	f100 33ff 	add.w	r3, r0, #4294967295
 8005438:	d100      	bne.n	800543c <memcpy+0xc>
 800543a:	4770      	bx	lr
 800543c:	b510      	push	{r4, lr}
 800543e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8005442:	4291      	cmp	r1, r2
 8005444:	f803 4f01 	strb.w	r4, [r3, #1]!
 8005448:	d1f9      	bne.n	800543e <memcpy+0xe>
 800544a:	bd10      	pop	{r4, pc}

0800544c <_init>:
 800544c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800544e:	bf00      	nop
 8005450:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005452:	bc08      	pop	{r3}
 8005454:	469e      	mov	lr, r3
 8005456:	4770      	bx	lr

08005458 <_fini>:
 8005458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800545a:	bf00      	nop
 800545c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800545e:	bc08      	pop	{r3}
 8005460:	469e      	mov	lr, r3
 8005462:	4770      	bx	lr
